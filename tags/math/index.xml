<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Math on Clark Kromenaker</title><link>https://kromenak.github.io/tags/math/</link><description>Recent content in Math on Clark Kromenaker</description><generator>Hugo</generator><language>en-us</language><managingEditor>kromenak@gmail.com (Clark Kromenaker)</managingEditor><webMaster>kromenak@gmail.com (Clark Kromenaker)</webMaster><lastBuildDate>Fri, 16 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://kromenak.github.io/tags/math/index.xml" rel="self" type="application/rss+xml"/><item><title>G-Engine #9: Quaternions</title><link>https://kromenak.github.io/post/gengine-09-quaternions/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://kromenak.github.io/post/gengine-09-quaternions/</guid><description>&lt;p>Way back in 
&lt;a href="https://kromenak.github.io/post/gengine-04-rendering">G-Engine #4&lt;/a>, we rendered a triangle, and there was much rejoicing. Since then, the posts in this series have primarily focused on implementing mathematical constructs in code. This point is the final math pre-requisite before we can move on to more interesting things.&lt;/p>
&lt;p>Think of a game engine as its own little universe: at first, there is nothing - the void. Concepts such as time, position, and orientation don&amp;rsquo;t exist yet. Suddenly, the game loop and delta time introduces the concept of time. With vectors, we can convey positions, directions, and distances. Slowly, our universe takes shape and we can convey important concepts in code.&lt;/p>
&lt;p>But what about rotations? Vectors can store position, direction, and scale data, but they are not effective structures for 3D rotations. We need some other option to convey rotations in code.&lt;/p>
&lt;p>One structure that is very effective for 3D rotations is the &lt;strong>Quaternion&lt;/strong>. Much-maligned for their apparent complexity, Quaternions allow us to efficiently store and use 3D rotation data. In this post, we&amp;rsquo;ll explore why we use quaternions, what they are, how to perform common operations with them, and finally I&amp;rsquo;ll provide some tips for writing your own &lt;code>Quaternion&lt;/code> class.&lt;/p></description></item><item><title>G-Engine #8: Matrices</title><link>https://kromenak.github.io/post/gengine-08-matrices/</link><pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://kromenak.github.io/post/gengine-08-matrices/</guid><description>&lt;p>Matrices are vital tools for 3D rendering. Graphics libraries expect you to use matrices to represent positions, rotations, and scales of 3D objects. Furthermore, matrices provide a convenient/effective mechanism for representing hierarchies of 3D objects and coordinate systems.&lt;/p>
&lt;p>This post will briefly explain what matrices are, explain commonly used operations for 3D game development, and provide tips for writing matrix classes for your game engine.&lt;/p></description></item><item><title>G-Engine #7: Vectors</title><link>https://kromenak.github.io/post/gengine-07-vectors/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://kromenak.github.io/post/gengine-07-vectors/</guid><description>&lt;p>We have added a basic math library to the 3D engine, but we&amp;rsquo;re still missing several fundamental mathematical building blocks to move forward and build full-fledged 3D environments. In particular, I want to implement Vectors, Matrices, and Quaternions. This post will cover &lt;strong>Vectors&lt;/strong>, which enable the engine to represent important spacial concepts such as &amp;ldquo;position&amp;rdquo; and &amp;ldquo;direction&amp;rdquo;.&lt;/p></description></item></channel></rss>