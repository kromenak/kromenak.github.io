<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Unity on Clark Kromenaker</title><link>https://clarkkromenaker.com/tags/unity/</link><description>Recent content in Unity on Clark Kromenaker</description><generator>Hugo</generator><language>en-us</language><managingEditor>kromenak@gmail.com (Clark Kromenaker)</managingEditor><webMaster>kromenak@gmail.com (Clark Kromenaker)</webMaster><lastBuildDate>Sat, 01 Jun 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://clarkkromenaker.com/tags/unity/index.xml" rel="self" type="application/rss+xml"/><item><title>Saving Memory with C# Structs</title><link>https://clarkkromenaker.com/post/csharp-structs/</link><pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/csharp-structs/</guid><description>&lt;p>In C++, there&amp;rsquo;s little difference between &lt;code>class&lt;/code> and &lt;code>struct&lt;/code>: a &lt;code>class&lt;/code> defaults to &amp;ldquo;private&amp;rdquo; access and a &lt;code>struct&lt;/code> defaults to &amp;ldquo;public&amp;rdquo; access. There are no other &lt;em>technical&lt;/em> differences between the two, though structs are often used for small and simple data types.&lt;/p>
&lt;p>C# mimics the syntax of C++ to some degree and also provides &lt;code>class&lt;/code> and &lt;code>struct&lt;/code>. However, in this case, the technical difference is quite large! In this post, I&amp;rsquo;ll briefly explain that difference and highlight a scenario where using a &lt;code>struct&lt;/code> saved a lot of memory on a project I worked on.&lt;/p></description></item><item><title>When to Inherit from MonoBehaviour</title><link>https://clarkkromenaker.com/post/unity-monobehaviour-usage/</link><pubDate>Thu, 14 Mar 2013 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/unity-monobehaviour-usage/</guid><description>&lt;p>When you create a new C# class in Unity, it automatically inherits from the &lt;code>MonoBehaviour&lt;/code> class, which is Unity&amp;rsquo;s base class for components. In Unity, you tend to create a lot of components, but it&amp;rsquo;s important to keep in mind that you don&amp;rsquo;t &lt;em>have to&lt;/em>.&lt;/p>
&lt;p>When I was new to Unity, I thought everything should inherit from &lt;code>MonoBehaviour&lt;/code> - that&amp;rsquo;s just how you work in Unity! Some of my students have also had this misconception. In fact, there are often scenarios where it makes more sense to not inherit at all, or to inherit from another base class. This post explains situations where it makes sense to use MonoBehaviour, and some cases where you&amp;rsquo;d be better off without it.&lt;/p></description></item><item><title>Encapsulate Unity Inspector Variables</title><link>https://clarkkromenaker.com/post/unity-inspector-variables/</link><pubDate>Sat, 18 Aug 2012 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/unity-inspector-variables/</guid><description>&lt;p>When writing a Unity component, it&amp;rsquo;s likely that you&amp;rsquo;ll want to expose some variables in the Unity Editor&amp;rsquo;s Inspector, so that either you or a designer can modify those values without having to recompile the script. However, the default method of exposing variables in the inspector can break class encapsulation in an undesirable way. This post explores ways to expose variables in the Inspector without sacrificing your class&amp;rsquo;s encapsulation.&lt;/p></description></item></channel></rss>