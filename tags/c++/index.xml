<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on Clark Kromenaker</title><link>https://clarkkromenaker.com/tags/c++/</link><description>Recent content in C++ on Clark Kromenaker</description><generator>Hugo</generator><language>en-us</language><managingEditor>kromenak@gmail.com (Clark Kromenaker)</managingEditor><webMaster>kromenak@gmail.com (Clark Kromenaker)</webMaster><lastBuildDate>Sat, 15 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://clarkkromenaker.com/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Reading to EOF</title><link>https://clarkkromenaker.com/post/cpp-eof/</link><pubDate>Sat, 15 Apr 2023 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/cpp-eof/</guid><description>&lt;p>Here&amp;rsquo;s a simple programming task: read everything from a file into memory. To do this, you need to open the file, read the data, and stop reading when you reach the end of the file (abbreviated &amp;ldquo;EOF&amp;rdquo;).&lt;/p>
&lt;p>But how do you KNOW you&amp;rsquo;ve reached the end of a file? That&amp;rsquo;s a simple question with a slightly complex/misleading answer.&lt;/p></description></item><item><title>C-Strings in C++</title><link>https://clarkkromenaker.com/post/cpp-cstrings/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/cpp-cstrings/</guid><description>&lt;p>Strings in C are simply arrays of &lt;code>char&lt;/code> values - or in other words, a contiguous block of memory containing &lt;code>chars&lt;/code>. C++ inherits that representation, but also provides a safer and easier-to-use option called &lt;code>std::string&lt;/code>. In C++, the old C-style strings are often called &lt;strong>C-Strings&lt;/strong>.&lt;/p>
&lt;p>Most C++ gurus would advise you to avoid C-Strings and just use &lt;code>std::string&lt;/code>. And it is true that &lt;code>std::string&lt;/code> is safer and easier to use than C-Strings. Whereas &lt;code>std::string&lt;/code> manages memory for you and has a ton of built-in functionality, C-Strings are essentially just blocks of &lt;code>char&lt;/code> memory that you must manipulate with error-prone and inconsistent functions.&lt;/p>
&lt;p>However, avoiding C-Strings entirely is difficult - sometimes you inherit code that&amp;rsquo;s using them, sometimes SDKs or libraries require you to use them, sometimes they are the most efficient option.&lt;/p>
&lt;p>C-Strings can be confusing to work with. There are a variety of functions used to manipulate C-Strings, but some are deprecated or insecure, some are only available in certain compilers, and some have intricate ins and outs for using them properly.&lt;/p>
&lt;p>So, my goal with this post is to catalogue some common operations you&amp;rsquo;d want to perform on C-Strings and identify the best options available, what to avoid, and what pitfalls exist.&lt;/p></description></item><item><title>Accessing Managers in C++</title><link>https://clarkkromenaker.com/post/cpp-manager-access/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/cpp-manager-access/</guid><description>&lt;p>Every game or game engine has at least a few managers under the hood. A manager is a collection of functions and data whose purpose is to &amp;ldquo;manage&amp;rdquo; something. You may send HTTP requests through an &lt;code>HttpManager&lt;/code>. You may track the player&amp;rsquo;s inventory with an &lt;code>InventoryManager&lt;/code>. You may play audio through an &lt;code>AudioManager&lt;/code>. And so on.&lt;/p>
&lt;p>How you access a manager is a seemingly mundane decision that can be surprisingly complex and paralyzing. Do you pass the manager as a function parameter? Use a global variable? Make a bunch of static functions or a namespace? Devise more elaborate mechanisms? Each option has pros and cons, and personal preference comes into play as well. Changing your mind later can incur significant refactoring overhead.&lt;/p>
&lt;p>I&amp;rsquo;ve been coding games for about a decade now, so I&amp;rsquo;ve developed some opinions and ideas on this subject. I don&amp;rsquo;t think there&amp;rsquo;s a &amp;ldquo;best&amp;rdquo; or &amp;ldquo;right&amp;rdquo; way to do this, but there are a few ways to consider that might be useful in varying contexts.&lt;/p>
&lt;p>Below, I&amp;rsquo;ll review several access options along with some pros/cons of each.&lt;/p></description></item><item><title>G-Engine #9: Quaternions</title><link>https://clarkkromenaker.com/post/gengine-09-quaternions/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-09-quaternions/</guid><description>&lt;p>Way back in 
&lt;a href="https://clarkkromenaker.com/post/gengine-04-rendering">G-Engine #4&lt;/a>, we rendered a triangle, and there was much rejoicing. Since then, the posts in this series have primarily focused on implementing mathematical constructs in code. This point is the final math pre-requisite before we can move on to more interesting things.&lt;/p>
&lt;p>Think of a game engine as its own little universe: at first, there is nothing - the void. Concepts such as time, position, and orientation don&amp;rsquo;t exist yet. Suddenly, the game loop and delta time introduces the concept of time. With vectors, we can convey positions, directions, and distances. Slowly, our universe takes shape and we can convey important concepts in code.&lt;/p>
&lt;p>But what about rotations? Vectors can store position, direction, and scale data, but they are not effective structures for 3D rotations. We need some other option to convey rotations in code.&lt;/p>
&lt;p>One structure that is very effective for 3D rotations is the &lt;strong>Quaternion&lt;/strong>. Much-maligned for their apparent complexity, Quaternions allow us to efficiently store and use 3D rotation data. In this post, we&amp;rsquo;ll explore why we use quaternions, what they are, how to perform common operations with them, and finally I&amp;rsquo;ll provide some tips for writing your own &lt;code>Quaternion&lt;/code> class.&lt;/p></description></item><item><title>G-Engine #8: Matrices</title><link>https://clarkkromenaker.com/post/gengine-08-matrices/</link><pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-08-matrices/</guid><description>&lt;p>Matrices are vital tools for 3D rendering. Graphics libraries expect you to use matrices to represent positions, rotations, and scales of 3D objects. Furthermore, matrices provide a convenient/effective mechanism for representing hierarchies of 3D objects and coordinate systems.&lt;/p>
&lt;p>This post will briefly explain what matrices are, explain commonly used operations for 3D game development, and provide tips for writing matrix classes for your game engine.&lt;/p></description></item><item><title>G-Engine #7: Vectors</title><link>https://clarkkromenaker.com/post/gengine-07-vectors/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-07-vectors/</guid><description>&lt;p>We have added a basic math library to the 3D engine, but we&amp;rsquo;re still missing several fundamental mathematical building blocks to move forward and build full-fledged 3D environments. In particular, I want to implement Vectors, Matrices, and Quaternions. This post will cover &lt;strong>Vectors&lt;/strong>, which enable the engine to represent important spacial concepts such as &amp;ldquo;position&amp;rdquo; and &amp;ldquo;direction&amp;rdquo;.&lt;/p></description></item><item><title>G-Engine #6: Math Library</title><link>https://clarkkromenaker.com/post/gengine-06-math/</link><pubDate>Wed, 27 Nov 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-06-math/</guid><description>&lt;p>After my post about 
&lt;a href="https://clarkkromenaker.com/post/gengine-04-rendering">rendering basics&lt;/a>, I had a fairly underwhelming final result: a single triangle being rendered in 3D. But it&amp;rsquo;s progress! My next goals are to do two seemingly simple things: move the virtual &amp;ldquo;camera&amp;rdquo; around my 3D environment to view the triangle from different perspectives, and move the triangle itself to different locations in 3D space.&lt;/p>
&lt;p>If we were just writing some graphics library sample code, achieving those two goals would not be too tricky: we could just use some OpenGL convenience methods and objects that provide the math needed. However, if our goal is to build a full game engine, it is better to create our own mathematical constructs that lay the groundwork for 3D world features we&amp;rsquo;ll want in the future, such as translation/rotation/scaling of objects, and parenting.&lt;/p>
&lt;p>One of the first things I need to address is my lack of math library. This post will explore a basic useful math library for a 3D game engine. Future posts will build upon this math library core to add support for 3D vector math, matrices, quaternions, and more!&lt;/p></description></item><item><title>G-Engine #5: GK3 Assets Overview</title><link>https://clarkkromenaker.com/post/gengine-05-asset-types/</link><pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-05-asset-types/</guid><description>&lt;p>Previous posts in this series have focused on the technical aspects of getting the G-Engine up and running. For this post, I&amp;rsquo;m going to take a short break from writing engine code to instead analyze how GK3 is built. It&amp;rsquo;ll be important to understand this as I move forward and try to recreate it.&lt;/p>
&lt;p>As a data-driven game, GK3 makes heavy use of various custom data and file formats. I&amp;rsquo;ll refer to each piece of data as an &lt;strong>asset&lt;/strong>.&lt;/p>
&lt;p>A key challenge in this project is understanding what the different asset types are, how they relate to one another, how to parse and load them into memory, and how to make use of them at runtime in a meaningful way. The developers would have documented all this, but much of that is unavailable to me - time for some detective work!&lt;/p>
&lt;p>This post focuses on those first two questions: what are the different asset types, and how do they relate to one another? We&amp;rsquo;ll take a look at the various assets, what they do, and the web of relationships between them.&lt;/p></description></item><item><title>G-Engine #4: Basic 3D Rendering</title><link>https://clarkkromenaker.com/post/gengine-04-rendering/</link><pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-04-rendering/</guid><description>&lt;p>In the last G-Engine post, we got the game loop and frame &amp;ldquo;delta time&amp;rdquo; calculations working. We&amp;rsquo;ve now got a blank, empty game window - yay? Despite the unimpressive result, we&amp;rsquo;ve got a beating heart under the hood: an update loop being called at roughly 60 frames per second.&lt;/p>
&lt;p>Empty windows are no fun, so my next goal is to get something - anything - rendering in the game window. Graphics are a vital and exciting part of any game, and rendering provides us vital visual feedback as we move on to implementing and debugging 3D object placement, cameras, rotations, and data loading for 3D meshes and animations.&lt;/p>
&lt;p>This post will focus on rendering a single triangle on screen. Though the result is simple, we&amp;rsquo;ll cover a lot of ground towards building a 3D rendering system that will be extended and enhanced as we move forward.&lt;/p></description></item><item><title>G-Engine #3: Game Loop</title><link>https://clarkkromenaker.com/post/gengine-03-game-loop/</link><pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-03-game-loop/</guid><description>&lt;p>In my last G-Engine post, I did some setup work and finally got a basic OS window appearing that could be moved around, minimized/maximized, and closed. Good start!&lt;/p>
&lt;p>In this post, we&amp;rsquo;ll do a bit more planning, and then we&amp;rsquo;ll structure our code into a high-level class (&lt;code>GEngine&lt;/code>) that&amp;rsquo;ll be more conducive to building an engine than just shoving everything into the &lt;code>main&lt;/code> function. We&amp;rsquo;ll also implement our &amp;ldquo;delta time&amp;rdquo; calculations, which will be critical for updating the state of our game as we move forward.&lt;/p></description></item><item><title>G-Engine #2: Project Setup</title><link>https://clarkkromenaker.com/post/gengine-02-setup/</link><pubDate>Sat, 27 Oct 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-02-setup/</guid><description>&lt;p>The previous post introduced the G-Engine project. So here we are, ready to build a 3D game engine! This post walks through some early decisions, starting from absolutely nothing to having just an empty application window that can be moved around and closed.&lt;/p>
&lt;p>This is not the most exciting end result, but there are plenty of important decisions to be made before we dig into actually writing game engine code.&lt;/p></description></item><item><title>Insert, Push, and Emplace</title><link>https://clarkkromenaker.com/post/cpp-emplace/</link><pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/cpp-emplace/</guid><description>&lt;p>Standard C++ containers (or collections) are essential tools. Some, like vector, queue, deque, and stack are list-like: elements are accessed by position. Others, such as map or set, are more associative in nature: elements are accessed by a key.&lt;/p>
&lt;p>To add an object to a vector, you can call &lt;strong>insert&lt;/strong> or &lt;strong>push_back&lt;/strong>. Stacks and queues both allow you to add elements using &lt;strong>push&lt;/strong>. Map allows insertions with &lt;strong>insert&lt;/strong> or using the &lt;strong>[ ] operator&lt;/strong>.&lt;/p>
&lt;p>In C++11 and beyond, all these containers have new functions that seem to behave similarly to the above methods: &lt;strong>emplace&lt;/strong>, &lt;strong>emplace_back&lt;/strong>, and &lt;strong>emplace_front&lt;/strong>.&lt;/p>
&lt;p>Which begs the question: what&amp;rsquo;s the difference between these different methods of adding items to collections?&lt;/p></description></item></channel></rss>