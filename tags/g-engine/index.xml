<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>G-Engine on Clark Kromenaker</title><link>https://clarkkromenaker.com/tags/g-engine/</link><description>Recent content in G-Engine on Clark Kromenaker</description><generator>Hugo</generator><language>en-us</language><managingEditor>kromenak@gmail.com (Clark Kromenaker)</managingEditor><webMaster>kromenak@gmail.com (Clark Kromenaker)</webMaster><lastBuildDate>Fri, 16 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://clarkkromenaker.com/tags/g-engine/index.xml" rel="self" type="application/rss+xml"/><item><title>G-Engine #9: Quaternions</title><link>https://clarkkromenaker.com/post/gengine-09-quaternions/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-09-quaternions/</guid><description>&lt;p>Way back in 
&lt;a href="https://clarkkromenaker.com/post/gengine-04-rendering">G-Engine #4&lt;/a>, we rendered a triangle, and there was much rejoicing. Since then, the posts in this series have primarily focused on implementing mathematical constructs in code. This point is the final math pre-requisite before we can move on to more interesting things.&lt;/p>
&lt;p>Think of a game engine as its own little universe: at first, there is nothing - the void. Concepts such as time, position, and orientation don&amp;rsquo;t exist yet. Suddenly, the game loop and delta time introduces the concept of time. With vectors, we can convey positions, directions, and distances. Slowly, our universe takes shape and we can convey important concepts in code.&lt;/p>
&lt;p>But what about rotations? Vectors can store position, direction, and scale data, but they are not effective structures for 3D rotations. We need some other option to convey rotations in code.&lt;/p>
&lt;p>One structure that is very effective for 3D rotations is the &lt;strong>Quaternion&lt;/strong>. Much-maligned for their apparent complexity, Quaternions allow us to efficiently store and use 3D rotation data. In this post, we&amp;rsquo;ll explore why we use quaternions, what they are, how to perform common operations with them, and finally I&amp;rsquo;ll provide some tips for writing your own &lt;code>Quaternion&lt;/code> class.&lt;/p></description></item><item><title>G-Engine #8: Matrices</title><link>https://clarkkromenaker.com/post/gengine-08-matrices/</link><pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-08-matrices/</guid><description>&lt;p>Matrices are vital tools for 3D rendering. Graphics libraries expect you to use matrices to represent positions, rotations, and scales of 3D objects. Furthermore, matrices provide a convenient/effective mechanism for representing hierarchies of 3D objects and coordinate systems.&lt;/p>
&lt;p>This post will briefly explain what matrices are, explain commonly used operations for 3D game development, and provide tips for writing matrix classes for your game engine.&lt;/p></description></item><item><title>G-Engine #7: Vectors</title><link>https://clarkkromenaker.com/post/gengine-07-vectors/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-07-vectors/</guid><description>&lt;p>We have added a basic math library to the 3D engine, but we&amp;rsquo;re still missing several fundamental mathematical building blocks to move forward and build full-fledged 3D environments. In particular, I want to implement Vectors, Matrices, and Quaternions. This post will cover &lt;strong>Vectors&lt;/strong>, which enable the engine to represent important spacial concepts such as &amp;ldquo;position&amp;rdquo; and &amp;ldquo;direction&amp;rdquo;.&lt;/p></description></item><item><title>G-Engine #6: Math Library</title><link>https://clarkkromenaker.com/post/gengine-06-math/</link><pubDate>Wed, 27 Nov 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-06-math/</guid><description>&lt;p>After my post about 
&lt;a href="https://clarkkromenaker.com/post/gengine-04-rendering">rendering basics&lt;/a>, I had a fairly underwhelming final result: a single triangle being rendered in 3D. But it&amp;rsquo;s progress! My next goals are to do two seemingly simple things: move the virtual &amp;ldquo;camera&amp;rdquo; around my 3D environment to view the triangle from different perspectives, and move the triangle itself to different locations in 3D space.&lt;/p>
&lt;p>If we were just writing some graphics library sample code, achieving those two goals would not be too tricky: we could just use some OpenGL convenience methods and objects that provide the math needed. However, if our goal is to build a full game engine, it is better to create our own mathematical constructs that lay the groundwork for 3D world features we&amp;rsquo;ll want in the future, such as translation/rotation/scaling of objects, and parenting.&lt;/p>
&lt;p>One of the first things I need to address is my lack of math library. This post will explore a basic useful math library for a 3D game engine. Future posts will build upon this math library core to add support for 3D vector math, matrices, quaternions, and more!&lt;/p></description></item><item><title>G-Engine #5: GK3 Assets Overview</title><link>https://clarkkromenaker.com/post/gengine-05-asset-types/</link><pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-05-asset-types/</guid><description>&lt;p>Previous posts in this series have focused on the technical aspects of getting the G-Engine up and running. For this post, I&amp;rsquo;m going to take a short break from writing engine code to instead analyze how GK3 is built. It&amp;rsquo;ll be important to understand this as I move forward and try to recreate it.&lt;/p>
&lt;p>As a data-driven game, GK3 makes heavy use of various custom data and file formats. I&amp;rsquo;ll refer to each piece of data as an &lt;strong>asset&lt;/strong>.&lt;/p>
&lt;p>A key challenge in this project is understanding what the different asset types are, how they relate to one another, how to parse and load them into memory, and how to make use of them at runtime in a meaningful way. The developers would have documented all this, but much of that is unavailable to me - time for some detective work!&lt;/p>
&lt;p>This post focuses on those first two questions: what are the different asset types, and how do they relate to one another? We&amp;rsquo;ll take a look at the various assets, what they do, and the web of relationships between them.&lt;/p></description></item><item><title>G-Engine #4: Basic 3D Rendering</title><link>https://clarkkromenaker.com/post/gengine-04-rendering/</link><pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-04-rendering/</guid><description>&lt;p>In the last G-Engine post, we got the game loop and frame &amp;ldquo;delta time&amp;rdquo; calculations working. We&amp;rsquo;ve now got a blank, empty game window - yay? Despite the unimpressive result, we&amp;rsquo;ve got a beating heart under the hood: an update loop being called at roughly 60 frames per second.&lt;/p>
&lt;p>Empty windows are no fun, so my next goal is to get something - anything - rendering in the game window. Graphics are a vital and exciting part of any game, and rendering provides us vital visual feedback as we move on to implementing and debugging 3D object placement, cameras, rotations, and data loading for 3D meshes and animations.&lt;/p>
&lt;p>This post will focus on rendering a single triangle on screen. Though the result is simple, we&amp;rsquo;ll cover a lot of ground towards building a 3D rendering system that will be extended and enhanced as we move forward.&lt;/p></description></item><item><title>G-Engine #3: Game Loop</title><link>https://clarkkromenaker.com/post/gengine-03-game-loop/</link><pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-03-game-loop/</guid><description>&lt;p>In my last G-Engine post, I did some setup work and finally got a basic OS window appearing that could be moved around, minimized/maximized, and closed. Good start!&lt;/p>
&lt;p>In this post, we&amp;rsquo;ll do a bit more planning, and then we&amp;rsquo;ll structure our code into a high-level class (&lt;code>GEngine&lt;/code>) that&amp;rsquo;ll be more conducive to building an engine than just shoving everything into the &lt;code>main&lt;/code> function. We&amp;rsquo;ll also implement our &amp;ldquo;delta time&amp;rdquo; calculations, which will be critical for updating the state of our game as we move forward.&lt;/p></description></item><item><title>G-Engine #2: Project Setup</title><link>https://clarkkromenaker.com/post/gengine-02-setup/</link><pubDate>Sat, 27 Oct 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-02-setup/</guid><description>&lt;p>The previous post introduced the G-Engine project. So here we are, ready to build a 3D game engine! This post walks through some early decisions, starting from absolutely nothing to having just an empty application window that can be moved around and closed.&lt;/p>
&lt;p>This is not the most exciting end result, but there are plenty of important decisions to be made before we dig into actually writing game engine code.&lt;/p></description></item><item><title>G-Engine #1: Introduction</title><link>https://clarkkromenaker.com/post/gengine-01-introduction/</link><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-01-introduction/</guid><description>&lt;p>I&amp;rsquo;ve always wanted to write a game engine. But building a game engine without a game can be difficult to do! The needs of the game drive the engine&amp;rsquo;s features. Plus, without art assets, how do you show off the engine&amp;rsquo;s features?&lt;/p>
&lt;p>To get around this problem, I thought it&amp;rsquo;d be cool to build a game engine that&amp;rsquo;s capable of running a game that I played and thoroughly enjoyed when I was in my teens: &lt;em>Gabriel Knight 3: Blood of the Sacred, Blood of the Damned&lt;/em>. In late 2017, I took the dive and started working on it!&lt;/p>
&lt;p>This post (and those following it) document my progress. In this introductory post, I&amp;rsquo;ll explain what &lt;em>Gabriel Knight&lt;/em> is, why I&amp;rsquo;m excited about it, and what I hope to accomplish.&lt;/p></description></item></channel></rss>