<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Writing C++ Binary Reader/Writer Classes - Clark Kromenaker</title>
<meta name=description content="Perhaps I was spoiled by the 
C# BinaryReader class, but I found myself really missing that functionality when I started spending more time with C++. Sure, C++ has constructs for reading and writing binary data, but nothing quite so easy-to-use as the BinaryReader (and BinaryWriter) that C# provides.
Because of this, I decided to write my own versions of these classes for use in GEngine. In this post, I&rsquo;ll quickly run through how to do this and how to extend the reader/writer to also work with memory streams, which is something C++ doesn&rsquo;t exactly support out-of-the-box."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"http:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"http:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http:\/\/clarkkromenaker.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"http:\/\/clarkkromenaker.com\/post\/wip\/cpp-binary-read-write\/","name":"Writing c binary reader writer classes"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"Writing C\u002b\u002b Binary Reader\/Writer Classes","description":"Perhaps I was spoiled by the C# BinaryReader class, but I found myself really missing that functionality when I started spending more time with C\u002b\u002b. Sure, C\u002b\u002b has constructs for reading and writing binary data, but nothing quite so easy-to-use as the BinaryReader (and BinaryWriter) that C# provides.\nBecause of this, I decided to write my own versions of these classes for use in GEngine. In this post, I\u0026rsquo;ll quickly run through how to do this and how to extend the reader\/writer to also work with memory streams, which is something C\u002b\u002b doesn\u0026rsquo;t exactly support out-of-the-box.\n","inLanguage":"en","wordCount":1955,"datePublished":"2022-03-13T00:00:00","dateModified":"2022-03-13T00:00:00","image":"http:\/\/clarkkromenaker.com\/img\/avatar-icon.png","keywords":["C\u002b\u002b"],"mainEntityOfPage":"http:\/\/clarkkromenaker.com\/post\/wip\/cpp-binary-read-write\/","publisher":{"@type":"Organization","name":"http:\/\/clarkkromenaker.com\/","logo":{"@type":"ImageObject","url":"http:\/\/clarkkromenaker.com\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="Writing C++ Binary Reader/Writer Classes"><meta property="og:description" content="Perhaps I was spoiled by the 
C# BinaryReader class, but I found myself really missing that functionality when I started spending more time with C++. Sure, C++ has constructs for reading and writing binary data, but nothing quite so easy-to-use as the BinaryReader (and BinaryWriter) that C# provides.
Because of this, I decided to write my own versions of these classes for use in GEngine. In this post, I&rsquo;ll quickly run through how to do this and how to extend the reader/writer to also work with memory streams, which is something C++ doesn&rsquo;t exactly support out-of-the-box."><meta property="og:image" content="http://clarkkromenaker.com/img/avatar-icon.png"><meta property="og:url" content="http://clarkkromenaker.com/post/wip/cpp-binary-read-write/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="Writing C++ Binary Reader/Writer Classes"><meta name=twitter:description content="Perhaps I was spoiled by the 
C# BinaryReader class, but I found myself really missing that functionality when I started spending more time with C++. Sure, C++ has constructs for reading and writing â€¦"><meta name=twitter:image content="http://clarkkromenaker.com/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=http://clarkkromenaker.com/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=http://clarkkromenaker.com/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=http://clarkkromenaker.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=http://clarkkromenaker.com/css/syntax.css><link rel=stylesheet href=http://clarkkromenaker.com/css/codeblock.css><link rel=stylesheet href=http://clarkkromenaker.com//css/portfolio.css><link rel=stylesheet href=http://clarkkromenaker.com//css/misc.css><link rel=stylesheet href=http://clarkkromenaker.com//css/overrides.css><script src=http://clarkkromenaker.com//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=http://clarkkromenaker.com/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=http://clarkkromenaker.com/><img class=avatar-img src=http://clarkkromenaker.com/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Writing C++ Binary Reader/Writer Classes</h1><span class=post-meta><i class=fas></i>Posted on March 13, 2022</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>Perhaps I was spoiled by the
<a href=https://docs.microsoft.com/en-us/dotnet/api/system.io.binaryreader target=_blank>C# BinaryReader class</a>, but I found myself really missing that functionality when I started spending more time with C++. Sure, C++ has constructs for reading and writing binary data, but nothing quite so easy-to-use as the BinaryReader (and BinaryWriter) that C# provides.</p><p>Because of this, I decided to write my own versions of these classes for use in GEngine. In this post, I&rsquo;ll quickly run through how to do this and how to extend the reader/writer to also work with memory streams, which is something C++ doesn&rsquo;t exactly support out-of-the-box.</p><h1 id=reading-and-writing-binary-data-in-c>Reading and Writing Binary Data in C++</h1><p>So, what tools does C++ provide for us to build on? Well, the standard library provides &ldquo;stream objects&rdquo;, <code>istream</code> and <code>ostream</code>, for reading and writing data respectively. Both provide an interface to read and write byte data: <code>istream</code> provides <code>read(char* in, int size)</code> and <code>ostream</code> provides <code>write(char* out, int size)</code>.</p><p>However, these stream objects only provide an interface for reading and writing; both classes require you to provide a &ldquo;stream buffer&rdquo; which actually contains the data being read or written. The standard library provides a few stream buffers for you, along with istream/ostream subclasses for using them:</p><ul><li><code>filebuf</code> is a stream buffer that uses a file as the buffer. The stream objects <code>ifstream</code> and <code>ofstream</code> are provided to read and write from files.</li><li><code>stringbuf</code> is a stream buffer that uses <code>std::string</code> as the buffer. The stream objects <code>isstream</code>, <code>osstream</code>, and <code>sstream</code> are provided for reading, writing, or both.</li></ul><p>You might notice that this list seems very short and incomplete&mldr;what about writing to a byte array!? We&rsquo;ll fix that later.</p><h1 id=binaryreader>BinaryReader</h1><p>If we base our BinaryReader off the C# class, we can identify some basic requirements:</p><ul><li>Constructors to specify what to read from (we&rsquo;ll start with files).</li><li>Methods to read basic types (signed and unsigned 8/16/32/64-bit values).</li><li>Methods to read strings.</li><li>Methods to change reader&rsquo;s position.</li></ul><p>Based on this, we can come up with a class declaration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;istream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BinaryReader</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Constructor to read from a file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>BinaryReader</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>filePath</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>BinaryReader</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Read basic types
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint8_t</span> <span class=nf>ReadByte</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kt>int8_t</span> <span class=nf>ReadSByte</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>uint16_t</span> <span class=nf>ReadUShort</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kt>int16_t</span> <span class=nf>ReadShort</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>uint32_t</span> <span class=nf>ReadUInt</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kt>int32_t</span> <span class=nf>ReadInt</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>uint64_t</span> <span class=nf>ReadULong</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint64_t</span> <span class=nf>ReadLong</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=nf>ReadFloat</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=nf>ReadDouble</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Read strings
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=nf>ReadString</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>size</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//TODO: various alternative string reading functions
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// Position manipulation
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=nf>Seek</span><span class=p>(</span><span class=kt>int</span> <span class=n>position</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>Skip</span><span class=p>(</span><span class=kt>int</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=nf>GetPosition</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=o>*</span> <span class=n>mStream</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>The constructor just creates an <code>ifstream</code> to read in binary data; the destructor deletes it. It might be nice to NOT use dynamic memory allocation here, but we will need to support multiple <code>std::istream</code> subclasses eventually:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fstream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>BinaryReader</span><span class=o>::</span><span class=n>BinaryReader</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>filePath</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mStream</span> <span class=o>=</span> <span class=k>new</span> <span class=n>std</span><span class=o>::</span><span class=n>ifstream</span><span class=p>(</span><span class=n>filePath</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ios</span><span class=o>::</span><span class=n>in</span> <span class=o>|</span> <span class=n>std</span><span class=o>::</span><span class=n>ios</span><span class=o>::</span><span class=n>binary</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BinaryReader</span><span class=o>::~</span><span class=n>BinaryReader</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>mStream</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Reading in basic types is fairly simple, once you figure out the syntax. Here are a couple examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=n>BinaryReader</span><span class=o>::</span><span class=n>ReadByte</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>read</span><span class=p>(</span><span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>val</span><span class=p>),</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// read in 1 byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int32_t</span> <span class=n>BinaryReader</span><span class=o>::</span><span class=n>ReadInt</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int32_t</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>read</span><span class=p>(</span><span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>val</span><span class=p>),</span> <span class=mi>4</span><span class=p>);</span> <span class=c1>// read in 4 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Dealing with strings can get a bit complicated, as there are a variety of ways you may decide to store that data. Do you use variable-length or fixed-size string buffers? Do you store the length of the string in the data, or assume the reader/writer will be aware of the size?</p><p>Here&rsquo;s one way to read a string, if you know the exact size of the string in question:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryReader</span><span class=o>::</span><span class=n>ReadString</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>size</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure we&#39;ve got enough capacity for the string data.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Use &#34;resize&#34; rather than &#34;reserve&#34; so that the string&#39;s size member is set correctly.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This implicitly ensures a null terminator is present as well.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>str</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Directly modify the string data; a little dangerous!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>read</span><span class=p>(</span><span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=n>data</span><span class=p>()),</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It&rsquo;s also fairly common to allocate a fixed-size buffer for the string, even if the string might be shorter than that. This approach works for that case:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryReader</span><span class=o>::</span><span class=n>ReadStringBuffer</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>bufferSize</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Read string per usual. BUT this may give incorrect results:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// If buffer size is greater than string size (due to null terminator), str.size() is incorrect
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ReadString</span><span class=p>(</span><span class=n>bufferSize</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Reduce string size if null terminator exists before end of string.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>str</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>str</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The length of a string is sometimes encoded alongside the binary data, so you could also do something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// For lack of a better term, &#34;tiny&#34; here means that the string length is less than 255 chars, so the size could be stored as a 8-bit value.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>BinaryReader</span><span class=o>::</span><span class=n>ReadTinyString</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>size</span> <span class=o>=</span> <span class=n>ReadByte</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ReadString</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>size</span><span class=p>),</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To manipulate the position of the reader, you can manipulate the underlying stream:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryReader</span><span class=o>::</span><span class=n>Seek</span><span class=p>(</span><span class=kt>int</span> <span class=n>position</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// It&#39;s possible we&#39;ve hit EOF, especially if we&#39;re jumping around a lot.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// If we are trying to seek on an EOF stream, clear the error flags and do the seek.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span><span class=p>(</span><span class=n>mStream</span><span class=o>-&gt;</span><span class=n>eof</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>mStream</span><span class=o>-&gt;</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>seekg</span><span class=p>(</span><span class=n>position</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ios</span><span class=o>::</span><span class=n>beg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryReader</span><span class=o>::</span><span class=n>Skip</span><span class=p>(</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>seekg</span><span class=p>(</span><span class=n>count</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ios</span><span class=o>::</span><span class=n>cur</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>GetPosition</span><span class=p>()</span> <span class=k>const</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>mStream</span><span class=o>-&gt;</span><span class=n>tellg</span><span class=p>());</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=binarywriter>BinaryWriter</h1><p>The BinaryWriter is a reflection of BinaryReader, but it&rsquo;s also simpler in some ways. The class declaration is very similar, with reads replaced with writes. We&rsquo;re also using an <code>ostream</code> instead of an <code>istream</code>.</p><p>The constructor still creates the stream, while the destructor destroys it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>BinaryWriter</span><span class=o>::</span><span class=n>BinaryWriter</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>filePath</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mStream</span> <span class=o>=</span> <span class=k>new</span> <span class=n>std</span><span class=o>::</span><span class=n>ofstream</span><span class=p>(</span><span class=n>filePath</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ios</span><span class=o>::</span><span class=n>out</span> <span class=o>|</span> <span class=n>std</span><span class=o>::</span><span class=n>ios</span><span class=o>::</span><span class=n>binary</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BinaryWriter</span><span class=o>::~</span><span class=n>BinaryWriter</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>mStream</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Again, dealing with basic types is rote, once you figure out the syntax:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryWriter</span><span class=o>::</span><span class=n>WriteByte</span><span class=p>(</span><span class=kt>uint8_t</span> <span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>write</span><span class=p>(</span><span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>val</span><span class=p>),</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryWriter</span><span class=o>::</span><span class=n>WriteInt</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>write</span><span class=p>(</span><span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>val</span><span class=p>),</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Strings are even a bit simpler. Writing a string can be as simple as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryWriter</span><span class=o>::</span><span class=n>WriteString</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Writing a string without recording its size!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This is fine if writer &amp; reader have established a clear protocol.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>write</span><span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>str</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If using a fixed-size string buffer, you could do this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryWriter</span><span class=o>::</span><span class=n>WriteStringBuffer</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>bufferSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Write the string data, but not more than the passed in size!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This *may* truncate the string data, if not careful.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>writeSize</span> <span class=o>=</span> <span class=n>str</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>writeSize</span> <span class=o>&gt;</span> <span class=n>bufferSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>writeSize</span> <span class=o>=</span> <span class=n>bufferSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>write</span><span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=n>writeSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Fill remaining space (if any) with null terminators.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>writeSize</span> <span class=o>&lt;</span> <span class=n>bufferSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>mStream</span><span class=o>-&gt;</span><span class=n>put</span><span class=p>(</span><span class=sc>&#39;\0&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>writeSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And versions with size encoded are simple as well:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryWriter</span><span class=o>::</span><span class=n>WriteTinyString</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// A &#34;tiny&#34; string must be &lt;= 255 chars.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WriteByte</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=n>size</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>    <span class=n>WriteString</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Position manipulation is nearly identical to the reader, though <code>seekp</code>/<code>tellp</code> are used, rather than <code>seekg</code>/<code>tellg</code>.</p><h1 id=adding-memory-buffer-support>Adding Memory Buffer Support</h1><p>All that&rsquo;s great if you want to read and write binary files using a straightforward API. But what about reading and writing memory buffers? Ideally, you&rsquo;d want to be able to do something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>memory</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BinaryWriter</span> <span class=nf>writer</span><span class=p>(</span><span class=n>memory</span><span class=p>,</span> <span class=mi>256</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>writer</span><span class=p>.</span><span class=n>WriteByte</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>writer</span><span class=p>.</span><span class=n>WriteTinyString</span><span class=p>(</span><span class=s>&#34;Hello, World!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BinaryReader</span> <span class=nf>reader</span><span class=p>(</span><span class=n>memory</span><span class=p>,</span> <span class=mi>256</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=n>version</span> <span class=o>=</span> <span class=n>reader</span><span class=p>.</span><span class=n>ReadByte</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>message</span> <span class=o>=</span> <span class=n>reader</span><span class=p>.</span><span class=n>ReadTinyString</span><span class=p>();</span>
</span></span></code></pre></div><p>The good news is, this is possible to do, even EASY to do! But figuring out how to do it (if you&rsquo;re not super familiar with the standard library) sure is a pain. But fortunately, after plenty of trial and error, I&rsquo;ve got something that does the trick.</p><p>We are going to add to the list of stream readers/buffers mentioned earlier:</p><ul><li><code>membuf</code> is a stream buffer that uses a byte array (memory) as a buffer. The stream objects <code>imstream</code> and <code>omstream</code> are provided to read and write memory.</li></ul><h2 id=creating-membuf>Creating <code>membuf</code></h2><p>To create our own &ldquo;stream buffer&rdquo; that uses a byte array instead of a file or string, we need to create a class that inherits from <code>std::streambuf</code>.</p><p><code>std::streambuf</code> is already capable of storing pointers to byte data and tracking the current position in that data as you read and write. However, we do need to provide implementations for seek functions, or else functions related to changing the stream position won&rsquo;t work correctly.</p><p>The declaration for <code>membuf</code> is pretty simple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;streambuf&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>membuf</span> <span class=o>:</span> <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>streambuf</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>membuf</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>streampos</span> <span class=n>seekoff</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>streamoff</span> <span class=n>off</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>seekdir</span> <span class=n>way</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>openmode</span> <span class=n>which</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>in</span> <span class=o>|</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>out</span><span class=p>)</span> <span class=k>override</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>streampos</span> <span class=n>seekpos</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>streampos</span> <span class=n>pos</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>openmode</span> <span class=n>which</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>in</span> <span class=o>|</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>out</span><span class=p>)</span> <span class=k>override</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>std::streambuf</code> maintains two sets of pointers: the &ldquo;get&rdquo; pointer (for reading), and the &ldquo;put&rdquo; pointer (for writing). Our constructor simply sets <code>std::streambuf</code>&rsquo;s&rsquo; read/write pointers to the passed-in byte data pointer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>membuf</span><span class=o>::</span><span class=n>membuf</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// setg is used for input (reading)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// setp is used for output (writing)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// We don&#39;t know if this membuf will be used for reading or writing, so just do both!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>setg</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>data</span> <span class=o>+</span> <span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>setp</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>data</span> <span class=o>+</span> <span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The biggest function to implement for <code>membuf</code> is <code>seekoff</code>, without which seeking in the memory buffer would fail. We must implement this function for both reading and writing. Its purpose is simply to update the &ldquo;current position&rdquo; in the buffer based on a desired offset:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>streampos</span> <span class=n>membuf</span><span class=o>::</span><span class=n>seekoff</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>streamoff</span> <span class=n>off</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>seekdir</span> <span class=n>way</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>openmode</span> <span class=n>which</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Determine whether we&#39;re doing out or in.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>out</span> <span class=o>=</span> <span class=p>((</span><span class=n>which</span> <span class=o>&amp;</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>out</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>in</span> <span class=o>=</span> <span class=p>((</span><span class=n>which</span> <span class=o>&amp;</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>in</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>out</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>in</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Determine which pointers to use for beg/cur/end.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span><span class=o>*</span> <span class=n>beg</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>cur</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>end</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>beg</span> <span class=o>=</span> <span class=n>pbase</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=n>pptr</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>end</span> <span class=o>=</span> <span class=n>epptr</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=n>in</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>beg</span> <span class=o>=</span> <span class=n>eback</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=n>gptr</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>end</span> <span class=o>=</span> <span class=n>egptr</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Need these pointers to be valid!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>beg</span> <span class=o>==</span> <span class=k>nullptr</span> <span class=o>||</span> <span class=n>cur</span> <span class=o>==</span> <span class=k>nullptr</span> <span class=o>||</span> <span class=n>end</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate update based on way and offset.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>way</span> <span class=o>==</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>beg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=n>beg</span> <span class=o>+</span> <span class=n>off</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=n>way</span> <span class=o>==</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>cur</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>+=</span> <span class=n>off</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=n>way</span> <span class=o>==</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=n>end</span> <span class=o>-</span> <span class=n>off</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Clamp to begin/end.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>cur</span> <span class=o>&gt;</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=n>cur</span> <span class=o>&lt;</span> <span class=n>beg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=n>beg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Update pointers.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>setp</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>cur</span><span class=p>,</span> <span class=n>end</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=n>in</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>setg</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>cur</span><span class=p>,</span> <span class=n>end</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Return current offset from beginning.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>cur</span> <span class=o>-</span> <span class=n>beg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The function <code>seekpos</code> also needs to be implemented, but is quite straightforward:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>streampos</span> <span class=n>membuf</span><span class=o>::</span><span class=n>seekpos</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>streampos</span> <span class=n>pos</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>openmode</span> <span class=n>which</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// This just always goes from the beginning.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>seekoff</span><span class=p>(</span><span class=n>pos</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ios_base</span><span class=o>::</span><span class=n>beg</span><span class=p>,</span> <span class=n>which</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>There are other functions from <code>std::streambuf</code> that we could override, but only these are needed to get correct behavior!</p><h1 id=creating-imstream-and-omstream>Creating <code>imstream</code> And <code>omstream</code></h1><p>Since BinaryReader uses an <code>istream</code> and BinaryWriter uses an <code>ostream</code>, we need subclasses of each that work with <code>membuf</code>.</p><p>It turns out these are pretty trivial to write. It&rsquo;s just a wrapper around a <code>membuf</code> with a constructor. The declarations of each:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Input stream that uses memory buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;istream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>imstream</span> <span class=o>:</span> <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>istream</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>imstream</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>membuf</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output stream that uses memory buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;ostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>omstream</span> <span class=o>:</span> <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>omstream</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>membuf</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>And the constructors for each:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>imstream</span><span class=o>::</span><span class=n>imstream</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>buffer</span><span class=p>(</span><span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>data</span><span class=p>),</span> <span class=n>length</span><span class=p>)</span> <span class=c1>// you&#39;d expect an imstream to be const (reading only, no writing), and it is...
</span></span></span><span class=line><span class=cl><span class=c1></span>                                            <span class=c1>// but in this case, you&#39;ve got to &#34;trust us&#34; because streambufs require non-const pointers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>omstream</span><span class=o>::</span><span class=n>omstream</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>buffer</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=conclusion>Conclusion</h1><p>That&rsquo;s about it! When you look at the code for these classes in totality, they aren&rsquo;t <em>that</em> complicated, and they aren&rsquo;t even that much code. However, there isn&rsquo;t much documentation I could find for how to do this correctly, so it took awhile to get right. Hopefully this article helps to save you some time!</p><p>Working and in-use versions of these classes can be found as part of G-Engine;
<a href=https://github.com/kromenak/gengine/tree/master/Source/IO target=_blank>check it out!</a></p><div class=blog-tags><a href=http://clarkkromenaker.com//tags/c++/>C++</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=http://clarkkromenaker.com/post/cpp-manager-access/ data-toggle=tooltip data-placement=top title="Accessing Managers in C++">&larr; Previous Post</a></li><li class=next><a href=http://clarkkromenaker.com/post/cpp-cstrings/ data-toggle=tooltip data-placement=top title="C-Strings in C++">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2024</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=http://clarkkromenaker.com/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>