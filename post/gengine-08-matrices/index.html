<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>G-Engine #8: Matrices - Clark Kromenaker</title>
<meta name=description content="Matrices are vital tools for 3D rendering. Graphics libraries expect you to use matrices to represent positions, rotations, and scales of 3D objects. Furthermore, matrices provide a convenient/effective mechanism for representing hierarchies of 3D objects and coordinate systems.
This post will briefly explain what matrices are, explain commonly used operations for 3D game development, and provide tips for writing matrix classes for your game engine."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/clarkkromenaker.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/clarkkromenaker.com\/post\/gengine-08-matrices\/","name":"G engine #8 matrices"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"G-Engine #8: Matrices","description":"Matrices are vital tools for 3D rendering. Graphics libraries expect you to use matrices to represent positions, rotations, and scales of 3D objects. Furthermore, matrices provide a convenient\/effective mechanism for representing hierarchies of 3D objects and coordinate systems.\nThis post will briefly explain what matrices are, explain commonly used operations for 3D game development, and provide tips for writing matrix classes for your game engine.\n","inLanguage":"en","wordCount":4238,"datePublished":"2020-07-04T00:00:00","dateModified":"2020-07-04T00:00:00","image":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","keywords":["G-Engine, C\u002b\u002b, Math"],"mainEntityOfPage":"https:\/\/clarkkromenaker.com\/post\/gengine-08-matrices\/","publisher":{"@type":"Organization","name":"https:\/\/clarkkromenaker.com\/","logo":{"@type":"ImageObject","url":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="G-Engine #8: Matrices"><meta property="og:description" content="Matrices are vital tools for 3D rendering. Graphics libraries expect you to use matrices to represent positions, rotations, and scales of 3D objects. Furthermore, matrices provide a convenient/effective mechanism for representing hierarchies of 3D objects and coordinate systems.
This post will briefly explain what matrices are, explain commonly used operations for 3D game development, and provide tips for writing matrix classes for your game engine."><meta property="og:image" content="https://clarkkromenaker.com/img/avatar-icon.png"><meta property="og:url" content="https://clarkkromenaker.com/post/gengine-08-matrices/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="G-Engine #8: Matrices"><meta name=twitter:description content="Matrices are vital tools for 3D rendering. Graphics libraries expect you to use matrices to represent positions, rotations, and scales of 3D objects. Furthermore, matrices provide a â€¦"><meta name=twitter:image content="https://clarkkromenaker.com/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://clarkkromenaker.com/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://clarkkromenaker.com/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://clarkkromenaker.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://clarkkromenaker.com/css/syntax.css><link rel=stylesheet href=https://clarkkromenaker.com/css/codeblock.css><link rel=stylesheet href=https://clarkkromenaker.com//css/portfolio.css><link rel=stylesheet href=https://clarkkromenaker.com//css/misc.css><link rel=stylesheet href=https://clarkkromenaker.com//css/overrides.css><script src=https://clarkkromenaker.com//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://clarkkromenaker.com/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://clarkkromenaker.com/><img class=avatar-img src=https://clarkkromenaker.com/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>G-Engine #8: Matrices</h1><span class=post-meta><i class=fas></i>Posted on July 4, 2020</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>Matrices are vital tools for 3D rendering. Graphics libraries expect you to use matrices to represent positions, rotations, and scales of 3D objects. Furthermore, matrices provide a convenient/effective mechanism for representing hierarchies of 3D objects and coordinate systems.</p><p>This post will briefly explain what matrices are, explain commonly used operations for 3D game development, and provide tips for writing matrix classes for your game engine.</p><h1 id=what-is-a-matrix>What is a Matrix?</h1><p>A matrix is a 2D collection of numbers. A defining characteristic of a matrix is its size: the number of <strong>rows</strong> and <strong>columns</strong> it has.</p><p>Size is expressed using &ldquo;<em>row</em> x <em>column</em>&rdquo; form - for example, a 2x4 matrix has 2 rows and 4 columns:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>0</span> <span class=mi>8</span> <span class=mi>9</span> <span class=o>-</span><span class=mi>2</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>3</span> <span class=mi>2</span> <span class=mi>4</span> <span class=mi>10</span> <span class=o>|</span>
</span></span></code></pre></div><p>In a 3D game engine, we&rsquo;ll commonly deal with 3x3 and 4x4 matrices. Here&rsquo;s an example of a 3x3 matrix:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>5</span> <span class=mi>3</span> <span class=mi>2</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>6</span> <span class=mi>1</span> <span class=mi>0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>4</span> <span class=mi>3</span> <span class=mi>2</span> <span class=o>|</span>
</span></span></code></pre></div><p>And here&rsquo;s an example of a 4x4 matrix:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>2</span> <span class=mi>6</span> <span class=mi>0</span> <span class=mi>0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>4</span> <span class=mi>4</span> <span class=mi>8</span> <span class=mi>3</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>2</span> <span class=mi>0</span> <span class=mi>1</span> <span class=mi>1</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>4</span> <span class=mi>9</span> <span class=mi>5</span> <span class=mi>7</span> <span class=o>|</span>
</span></span></code></pre></div><h2 id=referencing-elements>Referencing Elements</h2><p>Each number in a matrix is called an <strong>element</strong> (or an <strong>entry</strong>). Elements are identified using row and column indexes, where element <code>(0, 0)</code> is in the top-left corner. Rows proceed downward and columns proceed to the right.</p><p>For example, in the above 4x4 matrix, the number 8 is at element <code>(1, 2)</code> and the number 9 is at element <code>(3, 1)</code>.</p><p>Here&rsquo;s a 4x4 matrix showing each element&rsquo;s row/column indexes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=o>|</span>
</span></span></code></pre></div><p>Be careful of this &ldquo;gotcha&rdquo;: the notation to identify each matrix element may seem similar to cartesian coordinates. However, it is exactly opposite: the first number represents the row (&ldquo;y axis&rdquo;) and the second represents the column (&ldquo;x axis&rdquo;).</p><p>You may also see libraries that do not use 0-based indexes, so watch out for that! For my part, I prefer 0-based indexes to match arrays.</p><h2 id=matrix-terminology>Matrix Terminology</h2><p>Numerous terms exist to describe matrices with various attributes: particular sizes, particular numbers at particular positions, etc. Here, I&rsquo;ll quickly highlight a few of the most common ones.</p><p>A matrix with the same number of rows and columns is called a <strong>square matrix</strong>. A 4x4 matrix is square; a 2x5 is not.</p><p>The <strong>diagonal</strong> of a matrix are the entries where the row and column are equal, such as <code>(0, 0)</code> or <code>(1, 1)</code> or <code>(2, 2)</code>. A <strong>diagonal matrix</strong> only has non-zero entries on the diagonal of the matrix. Here&rsquo;s an example of a diagonal matrix:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>5</span> <span class=mi>0</span> <span class=mi>0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>0</span> <span class=mi>1</span> <span class=mi>0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>2</span> <span class=o>|</span>
</span></span></code></pre></div><p>The <strong>trace</strong> of a matrix is the sum of the elements along the diagonal. The trace of the above matrix is 8.</p><p>The <strong>Identity matrix</strong> is a diagonal matrix with only the number 1 present. This matrix has a special purpose when used in multiplication, which we&rsquo;ll describe later. Here is a 3x3 Identity matrix:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>1</span> <span class=mi>0</span> <span class=mi>0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>0</span> <span class=mi>1</span> <span class=mi>0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>1</span> <span class=o>|</span>
</span></span></code></pre></div><h1 id=why-matrices>Why Matrices?</h1><p>Perhaps you learned about matrices in high school and wondered what practical application they&rsquo;d have&mldr;well, 3D graphics, as it turns out! They are vital for expressing certain data to 3D graphics systems.</p><p>In my vector post, we briefy discussed how a 3D coordinate system is defined by an <strong>origin</strong> and three <strong>axes</strong> (x/y/z). We can actually compactly and efficiently represent a 3D coordinate system&rsquo;s origin and three axes in matrix form:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// First column: x-axis direction vector
</span></span></span><span class=line><span class=cl><span class=c1>// Second column: y-axis direction vector
</span></span></span><span class=line><span class=cl><span class=c1>// Third column: z-axis direction vector
</span></span></span><span class=line><span class=cl><span class=c1>// Fourth column: origin position vector
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>|</span> <span class=n>xx</span> <span class=n>yx</span> <span class=n>zx</span> <span class=n>tx</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=n>xy</span> <span class=n>yy</span> <span class=n>zy</span> <span class=n>ty</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=n>xz</span> <span class=n>yz</span> <span class=n>zz</span> <span class=n>tz</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>0</span>  <span class=mi>0</span>  <span class=mi>0</span>  <span class=mi>1</span>  <span class=o>|</span>
</span></span></code></pre></div><p>We&rsquo;ll discuss this more in a future post - I bring it up here just to highlight why matrices are used for 3D graphics data.</p><p>Using just one coordinate system, we can position all the objects in our game world. But if we create many coordinate systems, and if we nest them within one another, we can create hierarchies of objects (sometimes referred to as object <strong>parenting</strong> or a <strong>transform hierarchy</strong>).</p><p>A matrix representing a coordinate system also represents a <strong>transformation</strong> from that coordinate system to the parent coodinate system. We can use matrix multiplication to <strong>transform</strong> vectors and points between coordinate systems, which is helpful both for 3D rendering and for gameplay programming.</p><p>However, we&rsquo;re getting a little ahead of ourselves! Before we can do cool stuff with matrices in our game engine, we need to know how to use matrices, and we need to write classes so we can use matrices in code.</p><h1 id=matrix-operations>Matrix Operations</h1><p>There are just a few matrix operations that we need to worry about, but they are fairly complex. Here, I&rsquo;ll aim to explain how these operations work at a surface level.</p><h2 id=matrix-addition-and-subtraction>Matrix Addition and Subtraction</h2><p>Matrices can be added and subtracted from one another - doing so simply adds or subtracts corresponding elements in the output matrix. Here&rsquo;s a simply addition example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>4</span> <span class=mi>6</span> <span class=o>|</span>   <span class=o>|</span> <span class=mi>2</span> <span class=mi>2</span> <span class=o>|</span>   <span class=o>|</span> <span class=mi>6</span> <span class=mi>8</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>2</span> <span class=mi>5</span> <span class=o>|</span> <span class=o>+</span> <span class=o>|</span> <span class=mi>7</span> <span class=mi>1</span> <span class=o>|</span> <span class=o>=</span> <span class=o>|</span> <span class=mi>9</span> <span class=mi>6</span> <span class=o>|</span>
</span></span></code></pre></div><p>You can only add or subtract matrices that are the same size.</p><p>Matrix addition and subtraction are not super useful in a 3D game engine. The real magic comes from matrix multiplication.</p><h2 id=matrix-multiplication>Matrix Multiplication</h2><p>Multiplying matrices is not so simple. Rather than multiplying corresponding elements, you make use of the <strong>dot product</strong> to combine rows/columns of the two input matrices to generate elements in the output matrix.</p><p>We discussed the
<a href=/post/gengine-07-vectors>dot product</a> previously, which allows us to take two vectors and generate a single number as an output. We can treat the individual rows or columns of a matrix as though they are vectors.</p><p>For example, to calculate entry <code>(2, 3)</code> of the output matrix, you take <code>row 2</code> of the first input matrix and <code>column 3</code> of the second input matrix. You treat each as vectors and perform the dot product. The result of the dot product is just a number, which we put at entry <code>(2, 3)</code> in the result matrix.</p><p>Here&rsquo;s a more concrete example.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>4</span> <span class=mi>1</span> <span class=mi>2</span> <span class=o>|</span>   <span class=o>|</span> <span class=mi>3</span> <span class=mi>2</span> <span class=mi>3</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>3</span> <span class=mi>9</span> <span class=mi>5</span> <span class=o>|</span> <span class=o>*</span> <span class=o>|</span> <span class=mi>9</span> <span class=mi>8</span> <span class=mi>1</span> <span class=o>|</span> <span class=o>=</span> <span class=o>?</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>1</span> <span class=mi>3</span> <span class=mi>2</span> <span class=o>|</span>   <span class=o>|</span> <span class=mi>6</span> <span class=mi>2</span> <span class=mi>4</span> <span class=o>|</span>
</span></span></code></pre></div><p>To calculate entry <code>(0, 0)</code> in the result matrix, we must take <code>row 0</code> from the first matrix and <code>column 0</code> from the second matrix and perform the dot product:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=mi>4</span> <span class=o>*</span> <span class=mi>3</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=mi>9</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=mi>6</span><span class=p>)</span> <span class=o>=</span> <span class=mi>12</span> <span class=o>+</span> <span class=mi>9</span> <span class=o>+</span> <span class=mi>12</span> <span class=o>=</span> <span class=mi>33</span>
</span></span></code></pre></div><p>So, the value at entry <code>(0, 0)</code> in our result matrix will be <code>33</code>.</p><p>If we perform this process for EVERY result matrix entry, we end up with this result:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>33</span>  <span class=mi>20</span> <span class=mi>21</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>120</span> <span class=mi>88</span> <span class=mi>38</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>42</span>  <span class=mi>30</span> <span class=mi>14</span> <span class=o>|</span>
</span></span></code></pre></div><h3 id=size-restrictions>Size Restrictions</h3><p>The above multiplication process is shown between two matrices of the same size. Can you multiply a 2x1 matrix and a 6x5 matrix? What size would the result matrix be?</p><p>There is a restriction on what matrices can be multiplied together:</p><blockquote><p>The number of columns in the first input matrix must be equal to the number of rows in the second input matrix.</p></blockquote><p>You can also derive the size of the resulting matrix:</p><blockquote><p>The result matrix will always have the number of rows in the first input matrix and the number of columns in the second input matrix.</p></blockquote><p>Here are several examples to illustrate this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>4x4 and 4x4: CAN multiply, output is 4x4
</span></span><span class=line><span class=cl>4x4 and 3x3: CAN NOT multiply
</span></span><span class=line><span class=cl>2x3 and 3x2: CAN multiply, output is 2x2
</span></span><span class=line><span class=cl>3x2 and 2x3: CAN multiply, output is 3x3
</span></span><span class=line><span class=cl>1x4 and 4x4: CAN multiply, output is 1x4
</span></span><span class=line><span class=cl>4x4 and 1x4: CAN NOT multiply
</span></span><span class=line><span class=cl>4x4 and 4x1: CAN multiply, output is 4x1
</span></span></code></pre></div><p>An easy way to remember this is the &ldquo;inner/outer&rdquo; rule, which you can see in the above examples: write the sizes of the two input matrices; if the inner numbers match, you can multiply; the output size matches the outer numbers.</p><p>Notice the last three examples: which matrix is on the left-hand side vs. right-hand side CAN have an effect on whether you can multiply! And flipping the rows/columns can make a previously impossible multiplication possible.</p><h3 id=identity-multiplication>Identity Multiplication</h3><p>The Identity matrix is special because it acts like the number <code>1</code> in normal multiplication: multiplying by the identity matrix has no effect!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>5</span> <span class=mi>2</span> <span class=o>|</span>   <span class=o>|</span> <span class=mi>1</span> <span class=mi>0</span> <span class=o>|</span>   <span class=o>|</span> <span class=mi>5</span> <span class=mi>2</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>4</span> <span class=mi>9</span> <span class=o>|</span> <span class=o>*</span> <span class=o>|</span> <span class=mi>0</span> <span class=mi>1</span> <span class=o>|</span> <span class=o>=</span> <span class=o>|</span> <span class=mi>4</span> <span class=mi>9</span> <span class=o>|</span>
</span></span></code></pre></div><h2 id=transposing>Transposing</h2><p>Transposing a matrix simply involves converting all rows to columns or columns to rows. Every matrix has a transpose. If you transpose a transpose, you get&mldr;the original matrix back!</p><p>For example, these two matrices are transposes of one another:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>| 1 2 3 |  | 1 4 7 |
</span></span><span class=line><span class=cl>| 4 5 6 |  | 2 5 8 |
</span></span><span class=line><span class=cl>| 7 8 9 |  | 3 6 9 |
</span></span></code></pre></div><h2 id=vector-multiplication>Vector Multiplication</h2><p>The ability to multiply a vector by a matrix ends up being one of the most vital tools in our toolbox because it allows us to &ldquo;transform&rdquo; a vector (i.e. scale, rotate, or translate it).</p><p>When multiplying a vector by a matrix, we &ldquo;pretend&rdquo; that the vector is a matrix. For example, a 4D vector can be treated as either a 1x4 or a 4x1 matrix. These are referred to as <strong>row vectors</strong> and <strong>column vectors</strong> respectively.</p><p>After representing the vector as a matrix, we can then multiply the two using normal matrix multiplication. The output is a matrix, but we can interpret it as a vector.</p><p>For example, consider the 4D vector <code>(3, 5, 8, 1)</code>. We can multiply it by a matrix in two possible ways.</p><p>Using a row vector:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>              <span class=o>|</span> <span class=mi>1</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>              <span class=o>|</span> <span class=mi>0</span> <span class=mi>1</span> <span class=mi>0</span> <span class=mi>0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>3</span> <span class=mi>5</span> <span class=mi>7</span> <span class=mi>1</span> <span class=o>|</span> <span class=o>*</span> <span class=o>|</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>1</span> <span class=mi>0</span> <span class=o>|</span> <span class=o>=</span> <span class=o>|</span> <span class=mi>5</span> <span class=mi>7</span> <span class=mi>9</span> <span class=mi>1</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>              <span class=o>|</span> <span class=mi>2</span> <span class=mi>2</span> <span class=mi>2</span> <span class=mi>1</span> <span class=o>|</span>
</span></span></code></pre></div><p>Using a column vector:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>|</span> <span class=mi>1</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>2</span> <span class=o>|</span>   <span class=o>|</span> <span class=mi>3</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>0</span> <span class=mi>1</span> <span class=mi>0</span> <span class=mi>2</span> <span class=o>|</span>   <span class=o>|</span> <span class=mi>5</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>1</span> <span class=mi>2</span> <span class=o>|</span> <span class=o>*</span> <span class=o>|</span> <span class=mi>7</span> <span class=o>|</span> <span class=o>=</span> <span class=o>|</span> <span class=mi>5</span> <span class=mi>7</span> <span class=mi>9</span> <span class=mi>1</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>1</span> <span class=o>|</span>   <span class=o>|</span> <span class=mi>1</span> <span class=o>|</span>
</span></span></code></pre></div><p>A couple interesting things to note about these operations:</p><ul><li>Due to matrix multiplication size restrictions, the vector must be on the left side when using a row vector and it must be on the right side when using a column vector.</li><li>If the matrix is transposed when switching from row to column vector (or vice-versa), the result is exactly the same.</li></ul><p>The 4x4 matrix used above is an example of a simple <strong>transformation matrix</strong> that moves a point by <code>(2, 2, 2)</code>. Look at the input and output vectors, and you&rsquo;ll see that is indeed the case: the input was <code>(3, 5, 7)</code> and the output was <code>(5, 7, 9)</code>. Again, we&rsquo;ll talk more about transformation matrices in a future post.</p><h2 id=inversion>Inversion</h2><p>Let&rsquo;s say you multiply a vector <code>v1</code> by matrix <code>M</code> to get vector <code>v2</code>. Does some matrix exist that would allow you to undo that operation?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>v1</span> <span class=o>*</span> <span class=n>M</span> <span class=o>=</span> <span class=n>v2</span> <span class=c1>// Transforms v1 to v2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v2</span> <span class=o>*</span> <span class=o>?</span> <span class=o>=</span> <span class=n>v1</span> <span class=c1>// Transforms v2 back to v1
</span></span></span></code></pre></div><p>This is called the <strong>inverse matrix</strong> of <code>M</code>, which undoes, or performs the opposite operations, of the original matrix. To calculate the inverse matrix, we must <strong>invert</strong> <code>M</code>.</p><p>Since an inverse matrix undoes the original matrix, the result of multiplying the two is the Identity matrix!</p><p>Not every matrix has an inverse. There are a few rules:</p><ul><li>Only square matrices have inverses.</li><li>A matrix only has an inverse if its <strong>determinant</strong> is non-zero.</li></ul><p>Calculating the determinant is a fairly complex process that gets more and more complex as the matrix gets larger. Fortunately, for game development purposes, we really only need to be able to calculate the determinant for 3D, 4D (and maybe 2D) matrices. Explaining the logic for calculating the determinant is best done with pictures, so I&rsquo;ll delegate that responsibility to an existing resource (such as
<a href=https://www.mathsisfun.com/algebra/matrix-determinant.html target=_blank>this page</a>)</p><p>Actually calculating the inverse is <em>also</em> not a simple task! There are a couple options. First, there is a &ldquo;by hand&rdquo; method of calculating the inverse known as
<a href=https://en.wikipedia.org/wiki/Gaussian_elimination target=_blank>Gauss-Jordan Elimination</a>, but this method is not ideal for writing code. Another option exists, but it requires us to define a few more terms (I know, it&rsquo;s complicated).</p><p>Let&rsquo;s say you have a 3x3 matrix M, and you remove row <em>i</em> and column <em>j</em> (thereby making it a 2x2 matrix). If you calculate the determinant of the 2x2 matrix, that value is called the <strong>cofactor</strong> of element (i,j) for the 3x3 matrix. If you do this for every row/column combination you end up with a <strong>cofactor matrix</strong> (where every value in the original matrix has been replaced by the associated cofactor value).</p><p>Now, furthermore, if you transpose the cofactor matrix, you end up with a matrix called the <strong>adjugate</strong> of M.</p><p>Given all that, the inverse of a matrix can be calculated as <strong>the adjugate matrix divided by the determinant!</strong> Whew! The introduction of the above terminology is probably a bit head-spinning at first. But it defines a step-by-step process we can use to calculate the inverse matrix.</p><p>This calculation also reinforces the fact that an inverse only exists if the determinant is non-zero. Since we must divide by the determinant to calculate the inverse, and we can&rsquo;t divide by zero, it&rsquo;s not possible to calculate the inverse of a matrix with a zero determinant.</p><p>Feel free to check out the inverse functions in the G-Engine source code. These make use of some optimizations covered in the book &ldquo;Foundations of Game Engine Development, Volume 1: Mathematics&rdquo; by Eric Lengyel, which I&rsquo;d highly recommend checking out.</p><h1 id=writing-matrix-classes>Writing Matrix Classes</h1><p>Fortunately, a 3D game engine only really needs to support 3x3 and 4x4 matrices to be effective. Technically, a 3D game engine also makes use of single-row and single-column matrices (such as 1x3, 1x4, 3x1, 4x1). However, we can simply use our existing <code>Vector3</code> and <code>Vector4</code> classes for those!</p><p>A matrix class should support at least the following operations:</p><ul><li>Construction, Copy Construction, and Assignment</li><li>Equality checks</li><li>Get/set elements via row/column notation</li><li>Get/set rows and columns as Vectors</li><li>Matrix multiplication</li><li>Vector multiplication (using row and column vectors)</li><li>Calculate transpose matrix</li><li>Calculate inverse matrix</li></ul><p>The 4x4 Matrix class used in G-Engine can be found here:
<a href=/files/Matrix4.h>header</a> and
<a href=/files/Matrix4.cpp>source</a>.</p><p>A 3x3 Matrix class, as well as the latest 4x4 Matrix class, can be
<a href=https://github.com/kromenak/gengine target=_blank>found on GitHub</a>).</p><p>Next, I&rsquo;ll highlight some considerations when writing matrix classes.</p><h2 id=naming>Naming</h2><p>I decided to name the 3x3 and 4x4 classes <code>Matrix3</code> and <code>Matrix4</code> respectively. I&rsquo;ve also seen <code>Matrix4x4</code> or <code>Matrix4D</code> or even <code>Mat4</code> used in some engines. There&rsquo;s no right answer here, but our goal is to make the name clear without being overly verbose.</p><h2 id=data-layout>Data Layout</h2><p>In code, our matrix elements can be representd as a <code>float</code> array. A 3x3 matrix has 9 values and a 4x4 matrix has 16 values.</p><p>A 2D array seems like a natural choice, but a 1D array can also be used. For example, consider the 16 values for a 4x4 array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 2D array approach
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>float</span> <span class=n>mVals</span><span class=p>[</span><span class=mi>4</span><span class=p>][</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 1D array approach
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>float</span> <span class=n>mVals</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
</span></span></code></pre></div><p>Both approaches lead to the same contiguous memory allocation. We can visualize how the 2D array elements correlate to 1D elements:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>3</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=c1>// contiguous 2D array indexes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span> <span class=mo>00</span> <span class=p>]</span> <span class=p>[</span> <span class=mo>01</span> <span class=p>]</span> <span class=p>[</span> <span class=mo>02</span> <span class=p>]</span> <span class=p>[</span> <span class=mo>03</span> <span class=p>]</span> <span class=p>[</span> <span class=mo>04</span> <span class=p>]</span> <span class=p>[</span> <span class=mo>05</span> <span class=p>]</span> <span class=c1>// contiguous 1D array indexes
</span></span></span></code></pre></div><p>As you can see, element <code>mVals[0][3]</code> is right next to <code>mVals[1][0]</code> in memory.</p><p>Because these are fixed-size arrays, there is no overhead or performance loss that I&rsquo;m aware of by using a 2D array over a 1D array.</p><p>One benefit of the 2D approach is not having to calculate indexes manually - the compiler can do it for you:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Access element (3, 2) of a 2D array:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mVals</span><span class=p>[</span><span class=mi>3</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Access element (3, 2) of a 1D array:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mVals</span><span class=p>[</span><span class=mi>3</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span></code></pre></div><p>A 2D array may also appear in the debugger in a more easily readable format. For this reason, I&rsquo;ve actually seen the 2D approach more frequently recommended.</p><p>As with vectors, a matrix class should ONLY contain the array data member - no other data should be stored inside the class! You&rsquo;ll be using matrices a lot, and they need to be as lean and efficient as possible.</p><h2 id=column-major-and-row-major-orderings>Column-Major and Row-Major Orderings</h2><p>I think we can all agree that the first element in our C++ array (<code>mVals[0]</code> or <code>mVals[0][0]</code>) should correlate to element <code>(0, 0)</code> (upper-left corner) of the matrix. (Right?)</p><p>However, what should be stored at the second element of our C++ array (<code>mVals[1]</code> or <code>mVals[0][1]</code>)? We could put elements <code>(0, 1)</code> or <code>(1, 0)</code> there.</p><p>In other words, should we store matrix columns or matrix rows contiguously in memory? These two options are referred to as <strong>column-major</strong> and <strong>row-major</strong> orderings respectively.</p><p>For example, here are how the elements of a 3x3 matrix correlate to array indexes in column-major ordering:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Indices for 1D (left) and 2D (right) arrays using column-major ordering:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>|</span> <span class=mi>0</span> <span class=mi>3</span> <span class=mi>6</span> <span class=o>|</span>  <span class=o>|</span> <span class=mi>0</span><span class=p>,</span><span class=mi>0</span> <span class=mi>1</span><span class=p>,</span><span class=mi>0</span> <span class=mi>2</span><span class=p>,</span><span class=mi>0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>1</span> <span class=mi>4</span> <span class=mi>7</span> <span class=o>|</span>  <span class=o>|</span> <span class=mi>0</span><span class=p>,</span><span class=mi>1</span> <span class=mi>1</span><span class=p>,</span><span class=mi>1</span> <span class=mi>2</span><span class=p>,</span><span class=mi>1</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>2</span> <span class=mi>5</span> <span class=mi>8</span> <span class=o>|</span>  <span class=o>|</span> <span class=mi>0</span><span class=p>,</span><span class=mi>2</span> <span class=mi>1</span><span class=p>,</span><span class=mi>2</span> <span class=mi>2</span><span class=p>,</span><span class=mi>2</span> <span class=o>|</span>
</span></span></code></pre></div><p>And here&rsquo;s how they correlate when using row-major ordering:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Indices for 1D (left) and 2D (right) arrays using row-major ordering:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>|</span> <span class=mi>0</span> <span class=mi>1</span> <span class=mi>2</span> <span class=o>|</span>  <span class=o>|</span> <span class=mi>0</span><span class=p>,</span><span class=mi>0</span> <span class=mi>0</span><span class=p>,</span><span class=mi>1</span> <span class=mi>0</span><span class=p>,</span><span class=mi>2</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span> <span class=o>|</span>  <span class=o>|</span> <span class=mi>1</span><span class=p>,</span><span class=mi>0</span> <span class=mi>1</span><span class=p>,</span><span class=mi>1</span> <span class=mi>1</span><span class=p>,</span><span class=mi>2</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=mi>6</span> <span class=mi>7</span> <span class=mi>8</span> <span class=o>|</span>  <span class=o>|</span> <span class=mi>2</span><span class=p>,</span><span class=mi>0</span> <span class=mi>2</span><span class=p>,</span><span class=mi>1</span> <span class=mi>2</span><span class=p>,</span><span class=mi>2</span> <span class=o>|</span>
</span></span></code></pre></div><p>When using a 1D array, the index that correlates to each matrix element changes depending on the convention you use. For example, element <code>(1, 2)</code> is index [7] in column-major and index [5] in row-major. When using a 2D array, the column-major approach requires you to swap the two numbers while row-major keeps them identical. For example, element <code>(1, 2)</code> is index [2][1] in column-major and index [1][2] in row-major.</p><p>OK, great! Now why would you choose one ordering or the other? WHO CARES!?</p><p>The main reason to choose one or the other relates to how valuable it is to use contiguous values in memory. For example, let&rsquo;s say that you want to be able to extract a column from your matrix and interpret it as a <code>Vector3</code>. How you do that will depend on your data ordering:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Let&#39;s assume we have a 3x3 matrix with values stored in a 1D array.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// If data is column-major, we can simply reinterpret memory directly.
</span></span></span><span class=line><span class=cl><span class=c1>// This is more efficent (no copies).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Vector3</span><span class=o>&amp;</span> <span class=n>GetFirstColumn</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>Vector3</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>mVals</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// If data is row-major, we can&#39;t do that, so we must create a new vector.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Vector3</span> <span class=nf>GetFirstColumn</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>Vector3</span><span class=p>(</span><span class=n>mVals</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>mVals</span><span class=p>[</span><span class=mi>4</span><span class=p>],</span> <span class=n>mVals</span><span class=p>[</span><span class=mi>8</span><span class=p>]);</span> <span class=p>}</span>
</span></span></code></pre></div><p>Storing data in column-major order makes it more efficient to extract columns, and storing data in row-major order makes it more efficient to extract rows.</p><p>Later on, when we use matrices to represent coordinate system transforms, it will be helpful to be able to extract the rows or columns of a matrix efficiently. Whether rows or columns need to be extracted will depend on the order the data is stored in the matrix. And THAT depends on whether you choose to use column vectors or row vectors!</p><p>In the
<a href=#writing-a-vector-class>Vector Multiplication</a> section, we demonstrated how multiplication works when using column vectors and row vectors. The data in the matrix is transposed depending on which you use:</p><ul><li>When you use row vectors, the rows of the matrix are meaningful and convenient to be able to extract efficiently.</li><li>When you use column vectors, the columns of the matrix are meaningful and convenient to be able to extract efficiently.</li></ul><p>In G-Engine, I chose to use &ldquo;column vectors&rdquo; as the convention when multiplying vectors by matrices. Therefore, it will be convenient to be able to extract columns from my matrices. Therefore, I chose to use column-major ordering for my matrix data.</p><h2 id=matrix-construction>Matrix Construction</h2><p>To construct a matrix, you probably want a default constructor that just uses the default implementation. This is most efficient, but it&rsquo;s important to realize that, since we don&rsquo;t set the initial values of our matrix values array, it&rsquo;ll contain garbage unless you assign the values. We&rsquo;ll usually do this immediately after construction, so this is OK.</p><p>Another common constructor allows you to set each value of the matrix at construction time. It&rsquo;s best to keep this straightforward: just provide an argument for each entry, and lay out the arguments in a way that visually makes sense, regardless of whether you are storing column-major or row-major under the hood.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Matrix3</span> <span class=nf>mat</span><span class=p>(</span><span class=n>v00</span><span class=p>,</span> <span class=n>v01</span><span class=p>,</span> <span class=n>v02</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>v10</span><span class=p>,</span> <span class=n>v11</span><span class=p>,</span> <span class=n>v12</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>v20</span><span class=p>,</span> <span class=n>v21</span><span class=p>,</span> <span class=n>v22</span><span class=p>);</span>
</span></span></code></pre></div><p>You may want to have a constructor that takes in a 2D array of values. If you do this, I&rsquo;d still recommend that you allow values to be provided in a way that visually makes sense, regardless of internal storage ordering. But in my opinion, it&rsquo;s not worth having a 2D array constructor for a matrix, especially if you use column-major ordering, because it gets confusing: should each &ldquo;row&rdquo; of the 2D array correspond to a column? Avoid the confusion and use the previous constructor instead.</p><h2 id=dont-inherit>Don&rsquo;t Inherit</h2><p>As with vectors, it may seem like <code>Matrix4</code> could inherit from <code>Matrix3</code>, but that is not actually a good idea. Despite having similar data and similar functions, each class is unique enough to warrant not doing any sort of inheritance. We also do not want the overhead of virtual functions introduced into our matrix classes, which should be very lightweight!</p><h2 id=private-data-members>Private Data Members</h2><p>Unlike vectors, I think it is a good idea to keep matrix data private and make use of operator overloads and other accessor functions to access the data in meaningful ways.</p><p>Elements can be retrieved or modified using row/column notation by overloading C++ <code>operator()</code>. Rows or columns can be interpreted as <code>Vector3</code> instances and returned by overloading <code>operator[]</code> or with functions like <code>GetRows</code> or <code>GetColumns</code>.</p><p>One nice thing about keeping matrix data private is that outside code can use the matrix class without having to worry about whether you used a 1D or 2D array or whether the data is in column-major or row-major ordering. You can even change the array dimension or ordering at a later time, and the code using your matrix will probably not have to change.</p><p>Graphics libraries are an exception to this rule and may need to access raw array data from the matrix class - this can be accomplished by providing a function that returns a pointer to the internal array. This is accomplished in G-Engine by providing an implicit conversion operator for <code>float*</code>.</p><h2 id=careful-naming-to-signal-usage>Careful Naming to Signal Usage</h2><p>As with vectors, be careful to name member functions in a way that signals whether the function modifies itself or returns a new object.</p><p>A good example might be matrix inversion functions: calling a function <code>Inverse</code> can imply that it calculates the inverse and returns it as a new matrix; calling a function <code>Invert</code> implies that the function actually modifies the matrix itself, rather than creating a new one.</p><p>Use of <code>const</code> suffixes on member functions can also help enforce this.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Invert</span><span class=p>();</span> <span class=c1>// Inverts the current matrix, modifying it directly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Matrix4</span> <span class=nf>Inverse</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span> <span class=c1>// Calculates and returns a new matrix, can&#39;t modify instance
</span></span></span></code></pre></div><p>Another possible way to signal this is with static and non-static functions. G-Engine currently does this with Transpose functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Transpose</span><span class=p>();</span> <span class=c1>// Transposes the current matrix, modifying it directly.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>Matrix4</span> <span class=nf>Transpose</span><span class=p>(</span><span class=k>const</span> <span class=n>Matrix4</span><span class=o>&amp;</span> <span class=n>matrix</span><span class=p>);</span> <span class=c1>// Calculates transpose and returns as a new matrix.
</span></span></span></code></pre></div><h2 id=matrix-io>Matrix I/O</h2><p>As with vectors, it can be helpful to output a Matrix to the log for debugging or data recording. You can overload <code>operator&lt;&lt;</code> as a convenient way to do this.</p><h2 id=pre-defined-matrices>Pre-Defined Matrices</h2><p>As with vectors, it can be helpful to provide static access to some pre-defined matrices. The main one that&rsquo;s helpful for our needs is the <code>Identity</code> matrix. Another potentially meaningful one is <code>Zero</code>.</p><h1 id=conclusion>Conclusion</h1><p>With functioning Vector and Matrix classes, we are getting closer to having the ability to position objects and our camera&rsquo;s point of view in a 3D virtual world.</p><p>Next time, we&rsquo;ll dive into quaternions, which are the final foundational math class we&rsquo;ll need before we can move on to fully representing coordinate systems and transforms for objects in our 3D world.</p><p>This post provides a high-level overview of matrices with a focus on what you need to know to write these classes for your own engine. If you want a more comprehensive and thorough explanation of this and many other math topics, I&rsquo;d suggest one of these resources:</p><ul><li><a href=/reading#lengyel-math>Foundations of Game Engine Development, Volume 1: Mathematics</a></li><li><a href=/reading#essential-math>Essential Mathematics for Games and Interactive Applications</a></li><li><a href=/reading#game-engine-architecture>Game Engine Architecture</a></li></ul><div class=blog-tags><a href=https://clarkkromenaker.com//tags/g-engine/>G-Engine</a>&nbsp;
<a href=https://clarkkromenaker.com//tags/c++/>C++</a>&nbsp;
<a href=https://clarkkromenaker.com//tags/math/>Math</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://clarkkromenaker.com/post/gengine-07-vectors/ data-toggle=tooltip data-placement=top title="G-Engine #7: Vectors">&larr; Previous Post</a></li><li class=next><a href=https://clarkkromenaker.com/post/gengine-09-quaternions/ data-toggle=tooltip data-placement=top title="G-Engine #9: Quaternions">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2024</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://clarkkromenaker.com/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>