<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>G-Engine #3: Game Loop - Clark Kromenaker</title>
<meta name=description content="In my last G-Engine post, I did some setup work and finally got a basic OS window appearing that could be moved around, minimized/maximized, and closed. Good start!
In this post, we&rsquo;ll do a bit more planning, and then we&rsquo;ll structure our code into a high-level class (GEngine) that&rsquo;ll be more conducive to building an engine than just shoving everything into the main function. We&rsquo;ll also implement our &ldquo;delta time&rdquo; calculations, which will be critical for updating the state of our game as we move forward."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/kromenak.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/kromenak.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/kromenak.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/kromenak.github.io\/post\/gengine-03-game-loop\/","name":"G engine #3 game loop"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"G-Engine #3: Game Loop","description":"In my last G-Engine post, I did some setup work and finally got a basic OS window appearing that could be moved around, minimized\/maximized, and closed. Good start!\nIn this post, we\u0026rsquo;ll do a bit more planning, and then we\u0026rsquo;ll structure our code into a high-level class (GEngine) that\u0026rsquo;ll be more conducive to building an engine than just shoving everything into the main function. We\u0026rsquo;ll also implement our \u0026ldquo;delta time\u0026rdquo; calculations, which will be critical for updating the state of our game as we move forward.\n","inLanguage":"en","wordCount":4327,"datePublished":"2018-11-19T00:00:00","dateModified":"2018-11-19T00:00:00","image":"https:\/\/kromenak.github.io\/img\/avatar-icon.png","keywords":["G-Engine, C\u002b\u002b"],"mainEntityOfPage":"https:\/\/kromenak.github.io\/post\/gengine-03-game-loop\/","publisher":{"@type":"Organization","name":"https:\/\/kromenak.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/kromenak.github.io\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="G-Engine #3: Game Loop"><meta property="og:description" content="In my last G-Engine post, I did some setup work and finally got a basic OS window appearing that could be moved around, minimized/maximized, and closed. Good start!
In this post, we&rsquo;ll do a bit more planning, and then we&rsquo;ll structure our code into a high-level class (GEngine) that&rsquo;ll be more conducive to building an engine than just shoving everything into the main function. We&rsquo;ll also implement our &ldquo;delta time&rdquo; calculations, which will be critical for updating the state of our game as we move forward."><meta property="og:image" content="https://kromenak.github.io/img/avatar-icon.png"><meta property="og:url" content="https://kromenak.github.io/post/gengine-03-game-loop/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="G-Engine #3: Game Loop"><meta name=twitter:description content="In my last G-Engine post, I did some setup work and finally got a basic OS window appearing that could be moved around, minimized/maximized, and closed. Good start!
In this post, we&rsquo;ll do a bit â€¦"><meta name=twitter:image content="https://kromenak.github.io/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://kromenak.github.io/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://kromenak.github.io/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://kromenak.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://kromenak.github.io/css/syntax.css><link rel=stylesheet href=https://kromenak.github.io/css/codeblock.css><link rel=stylesheet href=https://kromenak.github.io//css/portfolio.css><link rel=stylesheet href=https://kromenak.github.io//css/misc.css><link rel=stylesheet href=https://kromenak.github.io//css/overrides.css><script src=https://kromenak.github.io//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://kromenak.github.io/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://kromenak.github.io/><img class=avatar-img src=https://kromenak.github.io/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>G-Engine #3: Game Loop</h1><span class=post-meta><i class=fas></i>Posted on November 19, 2018</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>In my last G-Engine post, I did some setup work and finally got a basic OS window appearing that could be moved around, minimized/maximized, and closed. Good start!</p><p>In this post, we&rsquo;ll do a bit more planning, and then we&rsquo;ll structure our code into a high-level class (<code>GEngine</code>) that&rsquo;ll be more conducive to building an engine than just shoving everything into the <code>main</code> function. We&rsquo;ll also implement our &ldquo;delta time&rdquo; calculations, which will be critical for updating the state of our game as we move forward.</p><h1 id=a-bit-more-planning>A Bit More Planning</h1><p>With any coding project, you&rsquo;ve got to make a few decisions before moving forward with a flurry of coding. Not all these things <em>need</em> to be locked down before you begin, but I thought I&rsquo;d share a few additional considerations I took into account.</p><h2 id=coding-conventions>Coding Conventions</h2><p>I chose the following high-level coding conventions:</p><ul><li>Files and classes are named in UpperCamelCase (e.g. <code>GEngine</code> or <code>InputManager</code>), and the file name reflects the primary class in that file.</li><li>Headers use a <code>.h</code> extension, and source files use a <code>.cpp</code> extension (e.g. <code>GEngine.h</code> and <code>GEngine.cpp</code>).</li><li>Variables are named in lowerCamelCase (e.g. <code>screenWidth</code>, <code>currentPos</code>).</li><li>Class member variables have an <code>m</code> prefix (e.g. <code>mRenderer</code>, <code>mInputManager</code>). Other variants: global variables have a <code>g</code> prefix and static variables have a <code>s</code> prefix.</li></ul><h2 id=header-layout>Header Layout</h2><p>The layout of a header is in this order:</p><ul><li>Comment with description of class.</li><li><code>#pragma once</code>, to avoid multiple header includes.</li><li>Standard library includes (like <code>&lt;vector</code>>), alphabetically.</li><li>Project includes (like <code>"InputManager.h"</code>), alphabetically.</li><li>Forward declarations (like <code>class MyClass;</code>), alphabetically.</li><li>Any supporting structs or classes for the main class.</li><li>The main class.<ul><li>Public variables and methods (statics first)</li><li>Private variables and methods (statics first)</li></ul></li><li>Any &ldquo;inline&rdquo; function definitions that don&rsquo;t fit well into the main class body.</li></ul><p>I use <code>#pragma once</code> instead of standard include guards, since they are simpler and widely supported. But standard include guards are fine too, if you prefer.</p><p>The order of my includes is somewhat arbitrary, though based on some guidance I&rsquo;ve read around the internet. I think the most important thing here is to be consistent about it, so that each file isn&rsquo;t completely different.</p><p>I also choose to put my &ldquo;forward declarations&rdquo; at the top of the file, instead of inline at the point of first use. I think this is cleaner, and makes the forward declarations clearer and easier to modify.</p><p>Within a class, I put <code>public</code> methods and variables above private ones. The main reason for this is to emphasize the public interface of the class. C++ requires both the public and private parts of an interface to be in the header file - ideally, the private bits would all be in the <code>cpp</code> file, but we are limited by the language in this regard.</p><p>There is a reasonable question about whether you should order functions and variables by public/protected/private access type, or by logical similarity of the functions. I&rsquo;ve boldly decided on the former - actually, if a class is only supposed to have a single responsibility, then everything should be logically similar anyway (though this doesn&rsquo;t <em>always</em> pan out in practice). We&rsquo;ll see how it goes!</p><h2 id=implementation-layout>Implementation Layout</h2><p>The layout here is mostly similar to the header layout, with a few small differences:</p><ul><li>No <code>#pragma once</code> line.</li><li>The very first <code>#include</code> should be the header file. Otherwise, header orders are the same.</li><li>Ideally, functions appear in the <code>.cpp</code> file in the same order they appeared in the <code>.h</code> file.</li></ul><p>That&rsquo;s enough planning for now&mldr;let&rsquo;s move on to the good stuff!</p><h1 id=the-engine-class>The Engine Class</h1><p>At the end of the last post, we had all our code just sitting in our <code>main</code> function. That&rsquo;s OK for small programs, utilities, code snippets, or samples. It is, however, not how we want to be structuring our code for a complicated program like a game engine!</p><p>How shall we structure our code? Well, we want to move in an object-oriented direction. So, splitting our code into a few C++ classes is a good start. Ideally, each class will have a single, well defined responsibility.</p><p>For now, we don&rsquo;t have much code. We&rsquo;ll start by creating a single class as a starting point: <code>GEngine</code>.</p><p>Our <code>GEngine</code> class is our engine&rsquo;s &ldquo;point of entry&rdquo; class - it will be responsible for initializing, and then running, and then shutting down our entire engine.</p><p>Our <code>main()</code> function will create our <code>GEngine</code> instance, and then call three functions, in order:</p><ul><li><code>Initialize()</code></li><li><code>Run()</code></li><li><code>Shutdown()</code></li></ul><p>And that&rsquo;s pretty much it for <code>main()</code> - anything else of interest or consequence will happen in these three <code>GEngine</code> functions, or in functions called by these functions.</p><p><code>Initialize()</code> and <code>Shutdown()</code> are two sides of the same coin. One will be responsible for initializing all the engine&rsquo;s subsystems, and the other will be responsible for tearing it all down when the program is exiting.</p><p>Initialization tends to encompass a number of start up tasks for the application. For example, our window creation would happen during initialization. Other initialization tasks might include initializing the rendering system (OpenGL, DirectX, etc), preparing input devices, creating memory allocators, and verifying that assets are available for use.</p><p>It&rsquo;s possible for initialization to fail. Have you ever launched a game, only for it to crash immediately with an error message box? That&rsquo;s likely what we&rsquo;d do if the initialization steps failed! Initialization can fail for obvious reasons (the game&rsquo;s asset files are missing) or very esoteric reasons (couldn&rsquo;t initialize graphics due to a driver issue).</p><p>The shutdown process will usually do the opposite of what initialization did, and often in reverse order. Created an OpenGL context or a window during initialization? Destroy or release those resources here. Allocated a memory pool on engine startup? Delete it here.</p><p>If something in shutdown fails&mldr;well, the engine is already in the process of shutting down. You can probably keep going and hope the operating system will handle it for you. Sometimes, developers don&rsquo;t realize that an error occurs on shutdown, since the game is in the process of closing anyway. Displaying an OS error dialog or writing the error to the output or a log could be a good way to catch errors here. If running with the debugger connected, it&rsquo;s also pretty obvious.</p><p>That leaves the <code>Run()</code> function, which is where we will implement our &ldquo;game loop.&rdquo;</p><h1 id=the-game-loop>The Game Loop</h1><p>The info in this section is very similar to what we teach in ITP 380 at USC. Thanks to Professor Sanjay Madhav for presenting this information so clearly and cleanly in his original slides!</p><p>A C++ program begins when <code>main()</code> is called, and it ends when <code>main()</code> returns. If you create a very simple &ldquo;Hello World!&rdquo; C++ application, you&rsquo;ll find that the program quits almost immediately after starting, living long enough only to output &ldquo;Hello World!&rdquo; to your console.</p><p>To turn this program into something that doesn&rsquo;t just quit right away, we need to add a <strong>loop</strong> somewhere. This is a loop that runs repeatedly for the entire duration of our application. The loop <strong>stops</strong> our program from reaching the end of <code>main()</code>. We only break out of the loop when either the user signals they want to quit, or some unrecoverable error occurs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Our loop, which stops the program from closing.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Done!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above code snippet runs, and it <strong>never</strong> exits, and furthermore, you will need to force-quit this program! So, not a great program, but it is the first thing we need to move towards a game loop.</p><p>Everything that we do in our game will be contained within this loop. At a high-level, this loop will do three things, in this order:</p><ol><li>Process Input</li><li>Update the Simulation</li><li>Generate Outputs</li></ol><p>Each step is vital to having a game, and must occur in this order.</p><p>A game must process inputs to be interactive - otherwise, it&rsquo;s just a non-interactive simulation.</p><p>The simulation (aka &ldquo;state of the game world&rdquo;) must update regularly, and that update must be, in part, based upon the inputs from step 1. If not, we again have something that is not really interactive.</p><p>Outputs, such as graphics and sound, are necessary as a form of feedback for our senses. Without this data, we don&rsquo;t see that the simulation is updating, and we don&rsquo;t see our input&rsquo;s effects on the game world, and so&mldr;it&rsquo;s not a very fun game.</p><p>The order is important because each step relies on the previous. Our simulation needs inputs to update, and we need to know the latest simulation state to generate accurate outputs. Additionally, inputs rely on the generated outputs, since you, as a player, will make decisions about what inputs you should perform based on the output of the previous loop.</p><p>It&rsquo;s a circle of life. A feedback loop.</p><h1 id=implementing-the-game-loop>Implementing the Game Loop</h1><p>Our game loop, as well as initialization and shutdown, will be orchestrated by our <code>GEngine</code> class.</p><p>The header file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#pragma once
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;SDL2/SDL.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Engine</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Inits and shuts down the engine.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>Initialize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Shutdown</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Runs our game loop.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Run</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Is the engine running? While true, we loop.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>mRunning</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Our SDL window handle.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SDL_Window</span><span class=o>*</span> <span class=n>mWindow</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// The three phases of our game loop.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>ProcessInput</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Update</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>GenerateOutputs</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Based on this structure, we can split our basic window code
<a href=/post/gengine-02-setup/>from the last post</a> between these various functions. The implementation file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Engine.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Engine</span><span class=o>::</span><span class=n>Initialize</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Init SDL video subsystem.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>SDL_InitSubSystem</span><span class=p>(</span><span class=n>SDL_INIT_VIDEO</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create a window.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mWindow</span> <span class=o>=</span> <span class=n>SDL_CreateWindow</span><span class=p>(</span><span class=s>&#34;GK3&#34;</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>1024</span><span class=p>,</span> <span class=mi>768</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>window</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Initialized successfully.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Engine</span><span class=o>::</span><span class=n>Shutdown</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Destroy created window.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>mWindow</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>SDL_DestroyWindow</span><span class=p>(</span><span class=n>window</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// De-initialize SDL.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SDL_Quit</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Engine</span><span class=o>::</span><span class=n>Run</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We are running!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mRunning</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Loop until not running anymore.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>mRunning</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ProcessInput</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>Update</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>GenerateOutputs</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Engine</span><span class=o>::</span><span class=n>ProcessInput</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We&#39;ll poll for events here. Catch the quit event.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SDL_Event</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>SDL_PollEvent</span><span class=p>(</span><span class=o>&amp;</span><span class=n>event</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span><span class=p>(</span><span class=n>event</span><span class=p>.</span><span class=n>type</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>SDL_QUIT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>mRunning</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Engine</span><span class=o>::</span><span class=n>Update</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//TODO: Update the simulation.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Engine</span><span class=o>::</span><span class=n>GenerateOutputs</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//TODO: Generate the outputs.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>This effectively splits our code from the first post into a more structured class. Note that we now need to store our <code>SDL_Window*</code> as a class member variable, since it is created in <code>Initialize()</code> and then destroyed in <code>Shutdown()</code>.</p><p>The last step is to update <code>main()</code> to call these functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;GEngine.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the engine.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GEngine</span> <span class=n>engine</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If init succeeds, we can &#34;run&#34; the engine.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// If init fails, the program ends immediately (skip Run()).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>initSucceeded</span> <span class=o>=</span> <span class=n>engine</span><span class=p>.</span><span class=n>Initialize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>initSucceeded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>engine</span><span class=p>.</span><span class=n>Run</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Clean everything up.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>engine</span><span class=p>.</span><span class=n>Shutdown</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Program exits.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>One mildly interesting question: should we create the <code>GEngine</code> in our main function, which allocates it on the stack? Or should we create it as a global variable, which puts it in our executables &ldquo;data&rdquo; segments (and thus, allocates it in memory before the program starts running)?</p><p>In fact, either will work. There may be some benefit one way or the other - I found that using a global variable increases the executable size slightly, but it avoids allocating the engine on the stack. At this early stage, it&rsquo;s hard to say what&rsquo;s better. I&rsquo;ll err towards avoiding global variables for now. But on the flip side, perhaps I shouldn&rsquo;t waste stack space! We&rsquo;ll see.</p><h1 id=frames-and-delta-time>Frames and Delta Time</h1><p>The game loop that we&rsquo;ve defined with just run over and over and over until the game quits. Each time the game completes one loop, we call that a <strong>frame</strong>.</p><p>At the moment, our loop is extremely simple, so your computer is likely able to run this loop many, many times per second. However, as we start to add more code to be executed during this loop (such as input processing, world updates, and graphics rendering), it will take longer and longer for your computer to execute all those instructions and complete a single frame.</p><p>The number of times per second that your computer can complete this loop is referred to as the <strong>frames per second</strong> or <strong>FPS</strong> of your game.</p><p>The number of <strong>frames per second</strong> has an effect on the gameplay experience. If this number is too low, the game will appear choppy or unresponsive, since the game is not completing game loops quickly enough. If this number is too high, it&rsquo;s less problematic, but can still cause issues, like excessive power usage or battery drain (doing a lot of work per second = more power used).</p><p>There are common &ldquo;target&rdquo; values for FPS. Usually, the minimum desired value is 30 FPS, which equates to each frame taking 0.033 seconds. A common target is 60 FPS, where each frame takes 0.016 seconds. Some games even target 120 FPS, where each frame takes 0.0083 seconds!</p><p>A higher FPS means that you are completing more frames per second; thus, the duration of each frame gets smaller and smaller as your FPS increases. These two equations can be used to calculate FPS or seconds per frame:</p><pre tabindex=0><code>secondsPerFrame = 1 / framesPerSecond
framesPerSecond = 1 / secondsPerFrame
</code></pre><p>The amount of time it takes for a frame to complete is often called the <strong>frame delta time</strong> or, more simply, <strong>delta time</strong>. It is also sometimes called a <strong>time step</strong>. It is the change in time, usually in seconds, that has occurred from the start of the previous frame to the start of the current frame. Obviously, you only know this value after the frame has completed!</p><p>The <strong>delta time</strong> value is very important to us. It is one of our primary tools for updating our simulation each frame.</p><p>Let&rsquo;s say we have an object in our game that moves at a speed of <code>10 m/s</code>. Each frame, we need to change its position by some amount to give the appearance of motion. But by what amount? To calculate a position change from a velocity, we need to know how much time has passed since the last position change (the <strong>delta time</strong>). At 30 FPS, <code>10m/s * 0.033s = 0.33m</code> change in position. At 60 FPS, <code>10m/s * 0.016s = 0.16m</code> change in position. <em>The change in position applied depends on how long ago we last updated the position.</em></p><p>Some older games from the 80s or early 90s did not take delta time into account, and were instead built with a particular CPU speed in mind. As a result, such games are considered to be <strong>frame locked</strong>, which means that they only function correctly if they run at a particular FPS. Not good!</p><p>There are still scenarios today where it makes sense to either &ldquo;frame lock&rdquo; your game (e.g. this game ALWAYS runs at 30 FPS), or have a &ldquo;fixed update loop&rdquo; (e.g. this update loop runs every 0.03 seconds). Both these approaches are actually somewhat different from &ldquo;assume a frame lasts for X seconds,&rdquo; which is what older games sometimes did. You should make sure you don&rsquo;t make the same mistake!</p><p>For now, we are going to focus on calculating a basic <strong>&ldquo;variable time-step update loop&rdquo;</strong>. To do this, we just have to keep track of what time our previous frame started, look at our current time, and calculate the difference between the two. And we do that every frame.</p><h1 id=calculating-delta-time>Calculating Delta Time</h1><p>The calculation of delta time is not particularly complicated, BUT there are several potential pitfalls and choices to make!</p><p>First, here is our most basic calculation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>GEngine</span><span class=o>::</span><span class=n>Update</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Tracks the last ticks value each time we run this loop.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>uint32_t</span> <span class=n>lastTicks</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Get current ticks value, in milliseconds.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>currentTicks</span> <span class=o>=</span> <span class=n>SDL_GetTicks</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate change from current to last, and convert to seconds.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>deltaTicks</span> <span class=o>=</span> <span class=n>currentTicks</span> <span class=o>-</span> <span class=n>lastTicks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>deltaTime</span> <span class=o>=</span> <span class=n>deltaTicks</span> <span class=o>*</span> <span class=mf>0.001f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Save ticks value for next frame.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lastTicks</span> <span class=o>=</span> <span class=n>currentTicks</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I&rsquo;m making use of a <code>static</code> variable to hold &ldquo;lastTicks&rdquo;. This is doable because (1) the value persists between function calls, (2) the value is only used in this function, and (3) we only ever have one <code>GEngine</code> instance. A very specific case where a <code>static</code> function variable is useful! It could also be a member variable, however.</p><p><code>SDL_GetTicks</code> is an SDL function that returns the number of milliseconds since <code>SDL_Init</code> was called. It is basically a wrapper around the platform-specific code we&rsquo;d have to write to get this data from the operating system. The Windows code for this uses <code>QueryPerformanceCounter</code>, while the Mac/Linux code uses <code>clock_gettime</code>, <code>mach_absolute_time</code>, or <code>gettimeofday</code>, depending on what&rsquo;s available.</p><p>To calculate our delta time, we take the difference between our current and last values, convert to a float, and multiply by 0.001f (or divide by 1000.0f, if you prefer). This converts our milliseconds delta to a seconds delta.</p><h2 id=floating-point-approximation-concerns>Floating-Point Approximation Concerns</h2><p>We keep track of <code>currentTicks</code> and <code>lastTicks</code> as unsigned 32-bit integers and subtract them to get a precise (as possible) millisecond difference between the current frame and the previous frame. We then convert this to a floating-point value, in seconds, after calculating the difference.</p><p>I recommend keeping <code>currentTicks</code> and <code>lastTicks</code> as integers until <em>after</em> calculating the difference. This is due to floating-point approximation issues that will start to occur as these two values become large - and remember, <code>SDL_GetTicks</code> returns the number of milliseconds <strong>since the start of the program</strong>, so these values WILL get larger and larger over time!</p><p>To see this problem in action, consider this sample code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Get current ticks (milliseconds since program start).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint32_t</span> <span class=n>currentTicks</span> <span class=o>=</span> <span class=n>SDL_GetTicks</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Let&#39;s simulate REALLY LARGE tick values with this addition value.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint32_t</span> <span class=n>addition</span> <span class=o>=</span> <span class=mi>100000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Really large float current/last ticks.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>float</span> <span class=n>curTicksFloat</span> <span class=o>=</span> <span class=n>currentTicks</span> <span class=o>+</span> <span class=n>addition</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>lastTicksFloat</span> <span class=o>=</span> <span class=n>lastTicks</span> <span class=o>+</span> <span class=n>addition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Really large integer current/last ticks.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint32_t</span> <span class=n>curTicksInt</span> <span class=o>=</span> <span class=n>currentTicks</span> <span class=o>+</span> <span class=n>addition</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=n>lastTicksInt</span> <span class=o>=</span> <span class=n>lastTicks</span> <span class=o>+</span> <span class=n>addition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Calculate diffs (our delta time) in milliseconds.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>float</span> <span class=n>actual</span> <span class=o>=</span> <span class=n>currentTicks</span> <span class=o>-</span> <span class=n>lastTicks</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>floatVersion</span> <span class=o>=</span> <span class=n>curTicksFloat</span> <span class=o>-</span> <span class=n>lastTicksFloat</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>intVersion</span> <span class=o>=</span> <span class=n>curTicksInt</span> <span class=o>-</span> <span class=n>lastTicksInt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>SDL_Log</span><span class=p>(</span><span class=s>&#34;Actual: %f Float: %f, Int: %f&#34;</span><span class=p>,</span> <span class=n>actual</span><span class=p>,</span> <span class=n>floatVersion</span><span class=p>,</span> <span class=n>intVersion</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Save current ticks to use next loop.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>lastTicks</span> <span class=o>=</span> <span class=n>currentTicks</span><span class=p>;</span>
</span></span></code></pre></div><p>The <code>addition</code> value simulates the ticks values we&rsquo;d get after running the program for 100,000,000 milliseconds (about 27.7 hours). If our <code>addition</code> variable is smaller (less than about 100,000,000 milliseconds), then the various results do not differ - that&rsquo;s good!</p><p>But above 100,000,000 or so, we start to see some variation in the returned values. The &ldquo;float&rdquo; version strays further and further from the correct values. The in-game result would be objects moving faster or slower than they should, since the delta time value is becoming more and more incorrect.</p><p>27.7 hours seems like a really large number - who&rsquo;s going to play a game for that long? Is this a practical concern? On one hand, you could argue that it isn&rsquo;t a big deal. On the other hand, it&rsquo;s possible for people to leave their games idling for a pretty long time. With modern suspend/resume functionality, it&rsquo;s also possible for for a game to stay &ldquo;on&rdquo; for days and days and days.</p><p>As floating point numbers become larger, they start to lose decimal precision. The difference between our &ldquo;current&rdquo; and &ldquo;last&rdquo; values will usually only be a couple milliseconds, so we start get some serious approximation issues.</p><p>Somewhere between 200,000,000 milliseconds (~55.5 hours) and 300,000,000 milliseconds (~83 hours) we start to see some major discrepancies, to the point where some frames report as <code>0ms</code> (too small!) and some report as <code>32ms</code> (double!).</p><p>We can easily avoid this problem if we keep our ticks values as unsigned integers until after the difference has been calculated. Unsigned integers don&rsquo;t have such approximation concerns.</p><h2 id=how-long-will-this-work>How Long Will This Work?</h2><p>Given max values for unsigned 32-bit integers, we can continue to accumulate these values for ~49 days before they will &ldquo;roll over&rdquo; or &ldquo;wrap&rdquo; back to zero.</p><p>The result will be one frame where the delta time value is a very large, negative number! Our <code>lastTicks</code> will be something like 4,294,967,295. Our <code>currentTicks</code> will be something like 1000. The result is then 1000 - 4,294,967,295 = -4,294,966,295.</p><p>For this reason, it may be a good idea to <strong>clamp</strong> our delta time value to a minimum value of zero. If we do this, our delta time logic can run indefinitely, though there will be one frame after ~49 days that errantly reports a 0s delta time.</p><p>Another possibility would be to use an unsigned 64-bit integer to store these values. This value would almost certainly <em>never</em> roll over. The max value is 18,446,744,073,709,551,615. This value would roll over after an incredible 584,942,417 <strong>years</strong>. Nobody&rsquo;s playing your game that long! However, the ability to use such a value is dictated by the value type your OS (or SDL) returns.</p><h2 id=why-seconds>Why Seconds?</h2><p>You may wonder why we&rsquo;d bother to convert delta time to seconds anyway, if floating-point values have approximation issues.</p><p>In one sense, it is a convention that is used by many other engines. So, we do it too. But that alone isn&rsquo;t a great justification.</p><p>One reason is that we&rsquo;ll often be dealing with other values that are expressed in seconds. Velocities use units/s, accelerations use units/s/s. Animations are also often expressed in &ldquo;frames per second&rdquo;. Therefore, it is a convenient unit to be working in.</p><p>Our seconds value must be floating-point, since most frames will take only a fraction of a second to complete (16ms or 30ms if our performance is good). When doing calculations later, we may often need to deal with fractional amounts of movement, so having our delta time value already in a floating-point value is helpful for that, too.</p><h2 id=frame-limiting>Frame Limiting</h2><p>One problem with the above loop is that it can potentially run very, very quickly - at hundreds or thousands of FPS on some systems.</p><p>We want our game to run as quickly as possible, but at some point, it becomes a bit excessive! Especially when we start rendering, we&rsquo;ll be updating WAY faster than any human eye can perceive. It&rsquo;s kind of a waste, and it can have negative impacts on power usage.</p><p>To combat this, one thing we can do is to <strong>limit</strong> how quickly our loop runs. One way we could do this might be to &ldquo;sleep&rdquo; our current thread for a certain amount of time. But another way to do this is with a simple &ldquo;while&rdquo; loop (sometimes called a &ldquo;busy wait&rdquo;).</p><p>Here&rsquo;s our updated code, but now limited to running at 60FPS max (or 16ms per frame):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>GEngine</span><span class=o>::</span><span class=n>Update</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Tracks next &#34;GetTicks&#34; value that&#39;s acceptable to perform an update.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>int</span> <span class=n>nextTicks</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Tracks the last ticks value each time we run this loop.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>uint32_t</span> <span class=n>lastTicks</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Limit to ~60FPS. &#34;nextTicks&#34; is always +16 at start of frame.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// If we get here again and 16ms have not passed, we wait.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>SDL_GetTicks</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>nextTicks</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Get current ticks value. Save next ticks for +16ms.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>currentTicks</span> <span class=o>=</span> <span class=n>SDL_GetTicks</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>nextTicks</span> <span class=o>=</span> <span class=n>currentTicks</span> <span class=o>+</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate change from current to last, and convert to seconds.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>deltaTicks</span> <span class=o>=</span> <span class=n>currentTicks</span> <span class=o>-</span> <span class=n>lastTicks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>deltaTime</span> <span class=o>=</span> <span class=n>deltaTicks</span> <span class=o>*</span> <span class=mf>0.001f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Save ticks value for next frame.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lastTicks</span> <span class=o>=</span> <span class=n>currentTicks</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code implements a &ldquo;busy wait&rdquo; (empty while loop) until at least 16ms have passed, ensuring that the maximum FPS will be 60.</p><h2 id=delta-time-capping>Delta Time Capping</h2><p>On the flip side, we may want to ensure that our delta time is never too large.</p><p>One instance where delta time can grow quite large is during debugging, when paused at breakpoints. If you pause on a breakpoint for two minutes, and then hit &ldquo;continue,&rdquo; you will end up with a delta time value that is about two minutes long! This&rsquo;ll usually translate into some strange in-game results.</p><p>When not debugging, you could argue that there&rsquo;s not a good reason to cap the delta time value. In that case, you may want to exclude the cap logic from release builds.</p><p>Implementing this is pretty simple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>GEngine</span><span class=o>::</span><span class=n>Update</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Tracks next &#34;GetTicks&#34; value that&#39;s acceptable to perform an update.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>int</span> <span class=n>nextTicks</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Tracks the last ticks value each time we run this loop.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>uint32_t</span> <span class=n>lastTicks</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Limit to ~60FPS. &#34;nextTicks&#34; is always +16 at start of frame.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// If we get here again and 16ms have not passed, we wait.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>SDL_GetTicks</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>nextTicks</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Get current ticks value. Save next ticks for +16ms.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>currentTicks</span> <span class=o>=</span> <span class=n>SDL_GetTicks</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>nextTicks</span> <span class=o>=</span> <span class=n>currentTicks</span> <span class=o>+</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate change from current to last, and convert to seconds.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>deltaTicks</span> <span class=o>=</span> <span class=n>currentTicks</span> <span class=o>-</span> <span class=n>lastTicks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>deltaTime</span> <span class=o>=</span> <span class=n>deltaTicks</span> <span class=o>*</span> <span class=mf>0.001f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Save ticks value for next frame.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lastTicks</span> <span class=o>=</span> <span class=n>currentTicks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Ensure delta time is never negative.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>deltaTime</span> <span class=o>&lt;</span> <span class=mf>0.0f</span><span class=p>)</span> <span class=p>{</span> <span class=n>deltaTime</span> <span class=o>=</span> <span class=mf>0.0f</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Limit the time delta to 0.05 seconds (about 20FPS).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>deltaTime</span> <span class=o>&gt;</span> <span class=mf>0.05f</span><span class=p>)</span> <span class=p>{</span> <span class=n>deltaTime</span> <span class=o>=</span> <span class=mf>0.05f</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This is a simple &ldquo;if statement&rdquo; to ensure the delta time is never more than 0.05 seconds. Again, it&rsquo;s totally arguable that this should not be present in release builds, where an FPS below 10 or 5 can (unfortunately) be very real.</p><p>I also snuck in a &ldquo;negative delta time&rdquo; check. Again, this would only be possible (we hope) if the ticks value &ldquo;rolls over&rdquo; after ~49 days. These two statements could also be implemented with a <code>Clamp</code> function, if desired.</p><h1 id=conclusion>Conclusion</h1><p>In this post, we started to architect our game engine by creating our first class - exciting!</p><p>We also implemented our delta time calculations. Calculating the delta time value accurately is critical for the game to run correctly. It&rsquo;s also somewhat fraught with peril!</p><p>Our next step will be to flesh out our math library, which will provide critical classes to finally get something, anything, rendering to screen!</p><div class=blog-tags><a href=https://kromenak.github.io//tags/g-engine/>G-Engine</a>&nbsp;
<a href=https://kromenak.github.io//tags/c++/>C++</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://kromenak.github.io/post/gengine-02-setup/ data-toggle=tooltip data-placement=top title="G-Engine #2: Project Setup">&larr; Previous Post</a></li><li class=next><a href=https://kromenak.github.io/post/gengine-04-rendering/ data-toggle=tooltip data-placement=top title="G-Engine #4: Basic 3D Rendering">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2024</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://kromenak.github.io/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>