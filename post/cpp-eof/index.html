<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Reading to EOF - Clark Kromenaker</title>
<meta name=description content="Here&rsquo;s a simple programming task: read everything from a file into memory. To do this, you need to open the file, read the data, and stop reading when you reach the end of the file (abbreviated &ldquo;EOF&rdquo;).
But how do you KNOW you&rsquo;ve reached the end of a file? That&rsquo;s a simple question with a slightly complex/misleading answer."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/kromenak.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/kromenak.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/kromenak.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/kromenak.github.io\/post\/cpp-eof\/","name":"Reading to EOF"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"Reading to EOF","description":"Here\u0026rsquo;s a simple programming task: read everything from a file into memory. To do this, you need to open the file, read the data, and stop reading when you reach the end of the file (abbreviated \u0026ldquo;EOF\u0026rdquo;).\nBut how do you KNOW you\u0026rsquo;ve reached the end of a file? That\u0026rsquo;s a simple question with a slightly complex\/misleading answer.\n","inLanguage":"en","wordCount":901,"datePublished":"2023-04-15T00:00:00","dateModified":"2023-04-15T00:00:00","image":"https:\/\/kromenak.github.io\/img\/avatar-icon.png","keywords":["C\u002b\u002b"],"mainEntityOfPage":"https:\/\/kromenak.github.io\/post\/cpp-eof\/","publisher":{"@type":"Organization","name":"https:\/\/kromenak.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/kromenak.github.io\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="Reading to EOF"><meta property="og:description" content="Here&rsquo;s a simple programming task: read everything from a file into memory. To do this, you need to open the file, read the data, and stop reading when you reach the end of the file (abbreviated &ldquo;EOF&rdquo;).
But how do you KNOW you&rsquo;ve reached the end of a file? That&rsquo;s a simple question with a slightly complex/misleading answer."><meta property="og:image" content="https://kromenak.github.io/img/avatar-icon.png"><meta property="og:url" content="https://kromenak.github.io/post/cpp-eof/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="Reading to EOF"><meta name=twitter:description content="Here&rsquo;s a simple programming task: read everything from a file into memory. To do this, you need to open the file, read the data, and stop reading when you reach the end of the file (abbreviated â€¦"><meta name=twitter:image content="https://kromenak.github.io/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://kromenak.github.io/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://kromenak.github.io/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://kromenak.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://kromenak.github.io/css/syntax.css><link rel=stylesheet href=https://kromenak.github.io/css/codeblock.css><link rel=stylesheet href=https://kromenak.github.io//css/portfolio.css><link rel=stylesheet href=https://kromenak.github.io//css/misc.css><link rel=stylesheet href=https://kromenak.github.io//css/overrides.css><script src=https://kromenak.github.io//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://kromenak.github.io/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://kromenak.github.io/><img class=avatar-img src=https://kromenak.github.io/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Reading to EOF</h1><span class=post-meta><i class=fas></i>Posted on April 15, 2023</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>Here&rsquo;s a simple programming task: read everything from a file into memory. To do this, you need to open the file, read the data, and stop reading when you reach the end of the file (abbreviated &ldquo;EOF&rdquo;).</p><p>But how do you KNOW you&rsquo;ve reached the end of a file? That&rsquo;s a simple question with a slightly complex/misleading answer.</p><h1 id=the-obvious-approach>The Obvious Approach</h1><p>We need some way to know that we&rsquo;ve read all the data in a file. Reviewing the C++ docs, you might reasonably land on this approach:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span> <span class=n>stream</span><span class=p>(</span><span class=s>&#34;file.bytes&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>stream</span><span class=p>.</span><span class=n>is_open</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>stream</span><span class=p>.</span><span class=n>eof</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>byte</span> <span class=o>=</span> <span class=n>stream</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something with &#34;byte&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This <em>seems</em> totally reasonable, and if you state the above logic in plain English, it sounds correct. &ldquo;While we&rsquo;re not yet at the end of the file, retrieve the next byte from the file.&rdquo;</p><p>However, there&rsquo;s a problem: if you read every byte in the file, <code>eof()</code> still returns false! It is only when you try to read <em>one more</em> element that it starts to return true!</p><p>For example, say you have a 10 byte file that you read using the above code. After reading the 10th byte, <code>eof()</code> <em>still</em> returns false. It is only when you attempt to read the (non-existent) 11th byte that <code>eof()</code> starts to return true.</p><p>So, you end up executing the loop one more time than intended. If there&rsquo;s nothing to read, <code>get()</code> returns -1. So the loop executes one more time with that (garbage) value. Hope that doesn&rsquo;t cause any problems&mldr;</p><h1 id=is-this-always-a-concern>Is This Always a Concern?</h1><p>I&rsquo;ve encountered this &ldquo;while-not-eof&rdquo; pattern in student assignments, coding examples, and production code. It seems to work in a lot of cases - why is that?</p><p>One reason is that <code>std::getline</code> will often save you. If you&rsquo;re reading full lines, <code>std::getline</code> is nice enough to check this for you and return the correct result. So you wouldn&rsquo;t even know there was danger afoot.</p><p>You also probably wouldn&rsquo;t notice this problem if you just copy the file into a big buffer using <code>ifstream::read</code>. In this case, the buffer is usually known to be bigger than the file&rsquo;s contents (in which case the buffer contains all the file data as expected). Or you may know exactly how many bytes to read from the file (in which case you don&rsquo;t actually need to detect EOF).</p><p>However, if you need to read byte data from a file until you reach the end, this issue can byte you (heh).</p><h1 id=the-hacky-solution>The Hacky Solution</h1><p>A key thing to realize is that <code>eof()</code> is not actually doing what you want it to do. You want it to signal that you&rsquo;ve read all the data in the file. But it&rsquo;s actually signaling when you&rsquo;ve read TOO MUCH data.</p><p>In other words, it&rsquo;s an off-by-one problem. Instead of telling you when you&rsquo;ve read <em>(n)</em> bytes, it tells you when you&rsquo;ve read <em>(n+1)</em> bytes.</p><p>With that in mind, one option is to check <code>eof()</code> two times:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span> <span class=n>stream</span><span class=p>(</span><span class=s>&#34;file.bytes&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>stream</span><span class=p>.</span><span class=n>is_open</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>stream</span><span class=p>.</span><span class=n>eof</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>byte</span> <span class=o>=</span> <span class=n>stream</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>stream</span><span class=p>.</span><span class=n>eof</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// do something with &#34;byte&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This is a bit clunky, but it does stop from running the loop an extra time with garbage data.</p><h1 id=the-true-solution>The True Solution</h1><p>Ideally though, we&rsquo;d like just the one conditional check. Fortunately, there is a way to achieve this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>ifstream</span> <span class=n>stream</span><span class=p>(</span><span class=s>&#34;file.bytes&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>stream</span><span class=p>.</span><span class=n>is_open</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>byte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>stream</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>byte</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do something with &#34;byte&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This works well, though I&rsquo;d argue this API is a bit too clever & obtuse for its own good:</p><ol><li>The <code>get</code> function returns a reference to the stream it was called on. In other words, the stream returns a reference to itself when you call these functions.</li><li>The stream object overrides the boolean operator to return <code>true</code> if the stream has not encountered any error. Since we check this <em>after</em> calling <code>get</code>, it tells us whether our last call to <code>get</code> was successful or not.</li></ol><p>Streams store three flags to represent error states: <code>eofbit</code>, <code>failbit</code>, and <code>badbit</code>. If any one is set, it probably means the stream is no longer safe to read from.</p><p>The boolean operator override checks if either <code>failbit</code> or <code>badbit</code> are set. But we need to check <code>eofbit</code> don&rsquo;t we!?</p><p>Fortunately, attempting to read past the end of the file sets both <code>failbit</code> and <code>eofbit</code>, so the boolean operator override does work for an end-of-file check (as well as guarding against other theoretical error states too, which is nice).</p><h1 id=conclusion>Conclusion</h1><p>As mentioned above, this all boils down to an off-by-one misunderstanding. Whereas a lot of APIs operate under the idiom &ldquo;check if this thing is OK and then use it,&rdquo; streams use the idiom &ldquo;use it, but then check if anything went wrong.&rdquo;</p><p>This behavior seems perplexing - why would they design the API like this?
<a href=https://stackoverflow.com/a/4533102 target=_blank>A post on Stack Overflow</a> makes a good point:</p><blockquote><p>While this [behavior] seems confusing for files, which typically know their size, EOF is not known until a read is attempted on some devices, such as pipes and network sockets.</p></blockquote><p>So, in a way, this behavior is the result of the standard library needing to accommodate a very generalized abstraction. Streams allow reading/writing data, but the actual underlying data source/destination can vary wildly. The abstraction can have benefits (read from any source using one class) as well as drawbacks (needing to think about how pipes or network sockets work when you&rsquo;re just trying to read a file).</p><div class=blog-tags><a href=https://kromenak.github.io//tags/c++/>C++</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://kromenak.github.io/post/cpp-cstrings/ data-toggle=tooltip data-placement=top title="C-Strings in C++">&larr; Previous Post</a></li><li class=next><a href=https://kromenak.github.io/post/web-building-and-hosting/ data-toggle=tooltip data-placement=top title="Building a Simple & Affordable Website">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2024</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://kromenak.github.io/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>