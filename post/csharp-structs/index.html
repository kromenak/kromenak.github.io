<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Saving Memory with C# Structs - Clark Kromenaker</title>
<meta name=description content="In C++, there&rsquo;s little difference between class and struct: a class defaults to &ldquo;private&rdquo; access and a struct defaults to &ldquo;public&rdquo; access. There are no other technical differences between the two, though structs are often used for small and simple data types.
C# mimics the syntax of C++ to some degree and also provides class and struct. However, in this case, the technical difference is quite large! In this post, I&rsquo;ll briefly explain that difference and highlight a scenario where using a struct saved a lot of memory on a project I worked on."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/clarkkromenaker.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/clarkkromenaker.com\/post\/csharp-structs\/","name":"Saving memory with c# structs"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"Saving Memory with C# Structs","description":"In C\u002b\u002b, there\u0026rsquo;s little difference between class and struct: a class defaults to \u0026ldquo;private\u0026rdquo; access and a struct defaults to \u0026ldquo;public\u0026rdquo; access. There are no other technical differences between the two, though structs are often used for small and simple data types.\nC# mimics the syntax of C\u002b\u002b to some degree and also provides class and struct. However, in this case, the technical difference is quite large! In this post, I\u0026rsquo;ll briefly explain that difference and highlight a scenario where using a struct saved a lot of memory on a project I worked on.\n","inLanguage":"en","wordCount":2130,"datePublished":"2019-06-01T00:00:00","dateModified":"2019-06-01T00:00:00","image":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","keywords":["C-Sharp, Unity"],"mainEntityOfPage":"https:\/\/clarkkromenaker.com\/post\/csharp-structs\/","publisher":{"@type":"Organization","name":"https:\/\/clarkkromenaker.com\/","logo":{"@type":"ImageObject","url":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="Saving Memory with C# Structs"><meta property="og:description" content="In C++, there&rsquo;s little difference between class and struct: a class defaults to &ldquo;private&rdquo; access and a struct defaults to &ldquo;public&rdquo; access. There are no other technical differences between the two, though structs are often used for small and simple data types.
C# mimics the syntax of C++ to some degree and also provides class and struct. However, in this case, the technical difference is quite large! In this post, I&rsquo;ll briefly explain that difference and highlight a scenario where using a struct saved a lot of memory on a project I worked on."><meta property="og:image" content="https://clarkkromenaker.com/img/avatar-icon.png"><meta property="og:url" content="https://clarkkromenaker.com/post/csharp-structs/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="Saving Memory with C# Structs"><meta name=twitter:description content="In C++, there&rsquo;s little difference between class and struct: a class defaults to &ldquo;private&rdquo; access and a struct defaults to &ldquo;public&rdquo; access. There are no other technical â€¦"><meta name=twitter:image content="https://clarkkromenaker.com/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://clarkkromenaker.com/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://clarkkromenaker.com/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://clarkkromenaker.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://clarkkromenaker.com/css/syntax.css><link rel=stylesheet href=https://clarkkromenaker.com/css/codeblock.css><link rel=stylesheet href=https://clarkkromenaker.com//css/portfolio.css><link rel=stylesheet href=https://clarkkromenaker.com//css/misc.css><link rel=stylesheet href=https://clarkkromenaker.com//css/overrides.css><script src=https://clarkkromenaker.com//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://clarkkromenaker.com/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://clarkkromenaker.com/><img class=avatar-img src=https://clarkkromenaker.com/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Saving Memory with C# Structs</h1><span class=post-meta><i class=fas></i>Posted on June 1, 2019</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>In C++, there&rsquo;s little difference between <code>class</code> and <code>struct</code>: a <code>class</code> defaults to &ldquo;private&rdquo; access and a <code>struct</code> defaults to &ldquo;public&rdquo; access. There are no other <em>technical</em> differences between the two, though structs are often used for small and simple data types.</p><p>C# mimics the syntax of C++ to some degree and also provides <code>class</code> and <code>struct</code>. However, in this case, the technical difference is quite large! In this post, I&rsquo;ll briefly explain that difference and highlight a scenario where using a <code>struct</code> saved a lot of memory on a project I worked on.</p><h1 id=types-of-memory>Types of Memory</h1><p>Any time you create an object in code, the object takes up some amount of memory. The memory for the object must be allocated from some source of unused (or &ldquo;free&rdquo;) memory. There are two possible sources for memory at runtime: the stack and the heap. Let&rsquo;s briefly examine the difference.</p><h2 id=stack>Stack</h2><p>The stack is a contiguous area of memory that is allocated in a very simple and uniform fashion. Memory is allocated from the &ldquo;bottom&rdquo; of the stack (lower memory address) to the &ldquo;top&rdquo; of the stack (higher memory address). We can only deallocate the most recently allocated memory. If we wanted to deallocate the memory at the bottom of the stack, we&rsquo;d first have to deallocate all the memory that had been allocated above it.</p><p>What memory is or isn&rsquo;t allocated on the stack is tracked with a simple memory pointer. When memory is allocated from the stack, the pointer is moved up by the appropriate amount. When memory is deallocated, the pointer moves back down. This makes allocation and deallocation on the stack extremely fast. When memory is deallocated, it isn&rsquo;t cleared - the pointer simply moves to a lower memory address and the deallocated memory will be overwritten the next time it is needed.</p><p>If you think about how a C++ or C# program works, it starts with a <code>main</code> function that calls other functions. Those functions call other functions, and so on. Eventually, each function returns to its caller. This structure works well for stack allocations.</p><p>When function A is called, local variables for function A exist on the stack. When function B is called, local variables for function B are allocated on the top of the stack. When function B returns to function A, function B&rsquo;s data is simply abandoned and we &ldquo;pop&rdquo; back to function A&rsquo;s data on the stack. A common mistake is to maintain a reference to B&rsquo;s memory after &ldquo;popping&rdquo; back to function A. The memory may still be valid for awhile&mldr;but it can be overwritten at any time that stack segment is reallocated!</p><p>Stack allocation is very efficient and works well for &ldquo;function-local&rdquo; data. If a piece of data will only ever be used in a single function, it can be declared locally in the function (and thus, allocated on the stack). Because of the way the stack works, it never becomes fragmented.</p><h2 id=heap>Heap</h2><p>The stack works in a very simple and uniform way because it puts restrictions on how you can use that memory and how long objects stored in that memory will remain valid. Sometimes, those restrictions are unacceptable, and you need some other place to store data. That&rsquo;s where the heap comes in.</p><p>The heap is memory for arbitrary dynamic allocations. Unlike the stack, this is meant for allocating objects that will exist beyond the lifetime of a single function. Memory is allocated and deallocated from the heap in a potentially disorganized way, leading to the possibility of <em>fragmentation</em>. When memory is fragmented, allocations can fail if there&rsquo;s no contiguous chunk that&rsquo;s big enough for the allocation. For example, say total available memory is 1MB, but a small 32KB chunk is allocated right in the middle of this block; an allocation of 600KB would fail because not enough <strong>contiguous</strong> memory is free!</p><p>Whereas the stack essentially cleans up after itself, objects allocated on the heap need to be cleaned up when they are no longer needed. C++ leaves it to the programmer to handle this, but C# keeps track of this for you and runs a &ldquo;garbage collector&rdquo; on occasion to clean up allocated memory that&rsquo;s no longer being used.</p><h1 id=reference-types-and-value-types>Reference Types and Value Types</h1><p>A <code>class</code> in C# is referred to as a <em>reference type</em>. This means that all class instances are allocated on the heap, and any variable of that type is a pointer to the object on the heap.</p><p>C# tries to do away with pointers for the sake of simplicity, but it actually uses pointers extensively - they&rsquo;re just hidden. Ironically, the desire to avoid pointers leaves us with a system where the vast majority of our variables act as pointers &ldquo;under-the-hood&rdquo;! Any variable that is a <code>class</code> type is really a pointer. This is why you must do null checks for most C# variables!</p><p>In addition to the object itself taking up memory, some additional memory overhead exists for <code>class</code> objects. Any variable for the object is really a pointer, so that pointer takes up 8 bytes in a 64-bit program. Furthermore, some data (16 bytes in a 64-bit program) is stored per-object for internal C# purposes (such as garbage collection).</p><p>A <code>struct</code> in C# is referred to as a <em>value type</em>. Variables of this type are not pointers to objects - they ARE the objects! If you create a <code>struct</code> as a function-local variable, its memory will be allocated on the stack. If the <code>struct</code> instance is a class member variable, its memory will be allocated contiguously as part of the class instance&rsquo;s memory on the heap.</p><p>Structs in C# act a lot like a value type (or &ldquo;non-pointer&rdquo;) in C++. When you perform an assignment operation, a copy is made. When you pass to a function, unless you pass by reference, a copy is made. Because assignment and passing to functions creates a copy, modifying the copy does not modify the original object. Struct variables do not need to be null checked. Interestingly, because C# wants to avoid dealing with pointers, it isn&rsquo;t possible to have a &ldquo;pointer-to&rdquo; a struct instance (beyond passing by reference to functions), which can be limiting in some cases.</p><h1 id=the-ambiguity-of-the-new-keyword>The Ambiguity of the &ldquo;New&rdquo; Keyword</h1><p>In C++, the <code>new</code> keyword is a dead giveaway that you are allocating memory from the heap. Value types are allocated without the <code>new</code> keyword.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>CppExample</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MyClass</span><span class=o>*</span> <span class=n>classPtr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MyClass</span><span class=p>();</span> <span class=c1>// allocated on the heap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MyClass</span> <span class=n>classValue</span><span class=p>;</span> <span class=c1>// allocated on the stack
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>This distinction is less clear in C#. In C#, both <code>struct</code> and <code>class</code> instances are created using the <code>new</code> keyword. So, the keyword really gives no indication as to whether we are allocating on the stack or heap. The only way to know is to understand whether you are dealing with a <code>struct</code> or <code>class</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>void</span> <span class=n>CSharpExample</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span> <span class=n>foo</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>();</span> <span class=c1>// assuming Foo is a class, allocated on the heap</span>
</span></span><span class=line><span class=cl>    <span class=n>Bar</span> <span class=n>bar</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Bar</span><span class=p>();</span> <span class=c1>// assuming Bar is a struct, allocated on the stack</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>There are a couple issues here. First, we only know whether our object is allocated on the heap or stack if we know whether it is a <code>struct</code> or <code>class</code>. In the above example, it&rsquo;s not clear at all, unless you go look at the declaration of Foo and Bar. Second, C# removes your ability to choose heap or stack, which can be limiting: a simplification that also reduces flexibility.</p><p>In C#, classes are always allocated on the heap. Structs are allocated on the stack, if a local function variable, or on the heap as part of a class if a class member.</p><h1 id=the-power-of-structs>The Power of Structs</h1><p>So, what&rsquo;s the point? Well, understanding this behavior in C# can improve the efficiency of your code. Let&rsquo;s look at a real world example where this made a huge difference.</p><p>For some time, Unity did not support serialization of <code>struct</code>, so all serializable types had to be classes. In that vein, for Skullgirls Mobile, we needed a small serializable class that is used for the game&rsquo;s internal scripting language:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[System.Serializable]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>VarOrNum</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>float</span> <span class=n>number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>byte</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>byte</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This class is used A LOT throughout the engine. When the game is running, there are usually about 2,000,000 instances in memory. They are uniquely referenced from other objects about 666,666 times.</p><p>Profiling this code sometime later, I noticed that we had unwittingly implemented a giant waste of memory - 15MB worth actually! And this memory could be easily reclaimed by making one small change:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[System.Serializable]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>struct</span> <span class=nc>VarOrNum</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>float</span> <span class=n>number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>byte</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>byte</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The ONLY difference here is changing <code>class</code> to <code>struct</code>, or making this a <em>value type</em> instead of a <em>reference type</em>. Why does this save so much memory???</p><p>First, we need to realize that our 2,000,000 instances are all reference types when we use <code>class</code>, and we happen to know that each one is referenced a single time (aka one pointer per object). Our game is 64-bit, so the size of a pointer is 8 bytes. So, the amount of memory used just by pointers to SlotOrNum instances was about 15.26MB (8 * 2,000,000).</p><p>Second, how big do you think this class is? It consists of a float and two bytes, which adds up to 6 bytes. With padding for memory alignment, the size is 8 bytes. However, as
<a href=https://blogs.msdn.microsoft.com/seteplia/2017/05/26/managed-object-internals-part-1-layout/ target=_blank>described here</a>, each class instance in C# has management data associated with it; in a 64-bit application, this adds up to 16 bytes of additional overhead per object instance! So, the size of an instance is actually 16 + 8 = 24 bytes.</p><p>The amount of per-instance memory overhead is somewhat staggering at scale. The 16 byte header info plus the 8 byte pointer means that each instance has 24 bytes of overhead. Furthermore, you may notice that the variables I&rsquo;m saving (float, byte, byte) can actually fit inside the 8 bytes of space being allocated for the pointer!</p><p>By switching to a <code>struct</code> we get two benefits that massively improve memory usage:</p><ol><li>The 16 bytes of overhead that was tacked on to the object instance will no longer be allocated.</li><li>Instead of using 8 bytes for the pointer to the object instance in heap memory, the struct data is now just contiguously stored in memory - in other words, the float+byte+byte now occupy the memory that would have previously been used for an 8 byte pointer.</li></ol><p>Also, since the struct version is allocated contiguously within class objects, there is one less &ldquo;pointer dereference&rdquo; when using these objects, which could improve memory access patterns and CPU caching. Following a pointer can lead to a cache miss, so the fewer &ldquo;pointer hops&rdquo;, the better.</p><h1 id=structs-everywhere>Structs EVERYWHERE!?</h1><p>Given these kinds of savings, are there any times we don&rsquo;t want to use structs? Well, unfortunately, structs have various limitations that make that ideal untenable.</p><p>C# value types are, by default, copied when you pass them as arguments or return them from functions. You can make use of the <code>ref</code> keyword to pass a value type by reference. There&rsquo;s no way to return a reference to a value type (which is great - that&rsquo;s a source of errors in C++). (UPDATE: newer versions of C# do allow returning by reference, though the syntax is a bit unwieldy.)</p><p>Because of the copy creation, unless you use extreme care, you probably don&rsquo;t want to use <code>struct</code> for large objects that are passed around a lot without <code>ref</code> or returned from functions. Copying very large amounts of data can slow down your program.</p><p>The copy behavior can also be a massive source of errors - it&rsquo;s easy to accidentally make a copy of an object (especially if you are trying to refactor old code to convert a C# class to a struct). Accidental copies usually lead to bugs because you modify the copy and don&rsquo;t realize that the original object is no longer being modified.</p><p>Also, unlike C++, C# has no way to store a reference or pointer to a value type. As a result, if you want two variables that point to the same struct&mldr;you can&rsquo;t do it! The only thing you can do is store two variables that each have their own memory and contain the exact same values. This might be OK for smaller objects. But it can start to get complicated to think about, especially when the two variables should conceptually refer to one object. In these cases, a <code>class</code> may be better.</p><h1 id=conclusion>Conclusion</h1><p>If you&rsquo;re coming from a C++ background, the choice of <code>struct</code> vs. <code>class</code> may be something you gloss over. But in C#, this seemingly simple choice can sometimes cost you a lot of memory, so choose wisely!</p><div class=blog-tags><a href=https://clarkkromenaker.com//tags/c-sharp/>C-Sharp</a>&nbsp;
<a href=https://clarkkromenaker.com//tags/unity/>Unity</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://clarkkromenaker.com/post/gengine-04-rendering/ data-toggle=tooltip data-placement=top title="G-Engine #4: Basic 3D Rendering">&larr; Previous Post</a></li><li class=next><a href=https://clarkkromenaker.com/post/gengine-05-asset-types/ data-toggle=tooltip data-placement=top title="G-Engine #5: GK3 Assets Overview">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2024</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://clarkkromenaker.com/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>