<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>G-Engine #7: Vectors - Clark Kromenaker</title>
<meta name=description content="We have added a basic math library to the 3D engine, but we&rsquo;re still missing several fundamental mathematical building blocks to move forward and build full-fledged 3D environments. In particular, I want to implement Vectors, Matrices, and Quaternions. This post will cover Vectors, which enable the engine to represent important spacial concepts such as &ldquo;position&rdquo; and &ldquo;direction&rdquo;."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/kromenak.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/kromenak.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/kromenak.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/kromenak.github.io\/post\/gengine-07-vectors\/","name":"G engine #7 vectors"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"G-Engine #7: Vectors","description":"We have added a basic math library to the 3D engine, but we\u0026rsquo;re still missing several fundamental mathematical building blocks to move forward and build full-fledged 3D environments. In particular, I want to implement Vectors, Matrices, and Quaternions. This post will cover Vectors, which enable the engine to represent important spacial concepts such as \u0026ldquo;position\u0026rdquo; and \u0026ldquo;direction\u0026rdquo;.\n","inLanguage":"en","wordCount":4291,"datePublished":"2020-03-14T00:00:00","dateModified":"2020-03-14T00:00:00","image":"https:\/\/kromenak.github.io\/img\/avatar-icon.png","keywords":["G-Engine, C\u002b\u002b, Math"],"mainEntityOfPage":"https:\/\/kromenak.github.io\/post\/gengine-07-vectors\/","publisher":{"@type":"Organization","name":"https:\/\/kromenak.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/kromenak.github.io\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="G-Engine #7: Vectors"><meta property="og:description" content="We have added a basic math library to the 3D engine, but we&rsquo;re still missing several fundamental mathematical building blocks to move forward and build full-fledged 3D environments. In particular, I want to implement Vectors, Matrices, and Quaternions. This post will cover Vectors, which enable the engine to represent important spacial concepts such as &ldquo;position&rdquo; and &ldquo;direction&rdquo;."><meta property="og:image" content="https://kromenak.github.io/img/avatar-icon.png"><meta property="og:url" content="https://kromenak.github.io/post/gengine-07-vectors/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="G-Engine #7: Vectors"><meta name=twitter:description content="We have added a basic math library to the 3D engine, but we&rsquo;re still missing several fundamental mathematical building blocks to move forward and build full-fledged 3D environments. In …"><meta name=twitter:image content="https://kromenak.github.io/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://kromenak.github.io/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://kromenak.github.io/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://kromenak.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://kromenak.github.io/css/syntax.css><link rel=stylesheet href=https://kromenak.github.io/css/codeblock.css><link rel=stylesheet href=https://kromenak.github.io//css/portfolio.css><link rel=stylesheet href=https://kromenak.github.io//css/misc.css><link rel=stylesheet href=https://kromenak.github.io//css/overrides.css><script src=https://kromenak.github.io//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://kromenak.github.io/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://kromenak.github.io/><img class=avatar-img src=https://kromenak.github.io/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>G-Engine #7: Vectors</h1><span class=post-meta><i class=fas></i>Posted on March 14, 2020</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>We have added a basic math library to the 3D engine, but we&rsquo;re still missing several fundamental mathematical building blocks to move forward and build full-fledged 3D environments. In particular, I want to implement Vectors, Matrices, and Quaternions. This post will cover <strong>Vectors</strong>, which enable the engine to represent important spacial concepts such as &ldquo;position&rdquo; and &ldquo;direction&rdquo;.</p><p>Before we talk about coding vectors, we need to understand what vectors are and what they can do. This section provides a &ldquo;crash course&rdquo; in vectors and vector operations. If you&rsquo;re already familiar with vectors and just want to read about coding them, skip down to
<a href=#writing-a-vector-class>Writing a Vector Class</a>.</p><h1 id=coordinate-systems>Coordinate Systems</h1><p>Let&rsquo;s start by stating something obvious: in video games (and the real world), objects have different positions! When you play Pac-Man, the ghosts and Pac-Man each have different positions in the maze. When you&rsquo;re driving in the real world, your car has a different position compared to other cars and stationary objects around you.</p><p>The positions of objects are important for both rendering and gameplay reasons. As you might expect, an object&rsquo;s position affects where it renders on screen. And gameplay events are often tied to position - if Pac-Man&rsquo;s position is too near to a ghost&rsquo;s position, Pac-Man will die (unless he has eaten power pellet).</p><p>In video games, we represent object positions relative to a <strong>coordinate system</strong>. A coordinate system is defined by its <strong>origin</strong> and its <strong>axes</strong>. In 2D, there are horizontal and vertical axes, which we refer to as the x-axis and y-axis respectively. In 3D, we have an additional &ldquo;depth&rdquo; axis (often called z-axis).</p><p><img src=/img/gengine/vectors/coord_systems.png#center alt="2D and 3D Coordinate Systems"></p><p>In 2D, the x-axis is always horizontal and the y-axis is always vertical. In 3D, different engines use different conventions! For example, some engines use z-axis for depth, others use y-axis for depth. We&rsquo;ll discuss this more in a future post.</p><p>We can define the positions of objects relative to a coordinate system&rsquo;s origin using <strong>cartesian coordinates</strong>.</p><p>For example, an object that is 2 units from the origin on the x-axis, -4 units from the origin on the y-axis, and 10 units from the origin on the z-axis can be said to have the position <code>(2, -4, 10)</code>.</p><p>The origin of a coordinate system is always at <code>(0, 0)</code> in 2D or <code>(0, 0, 0)</code> in 3D. This might seem obvious, but it&rsquo;s worth pointing out!</p><p>We can also define offsets between objects using cartesian coordinates. For example, if one object is positioned at <code>(3, 4, 2)</code> and another object is at <code>(2, 5, 5)</code>, we can calculate that the offset from the first to second object is <code>(-1, 1, 3)</code>.</p><p>Given an offset between two objects, you can also calculate the distance between them - we&rsquo;ll discuss that in a bit. Obviously, if two objects have the same position, the offset between the them will be <code>(0, 0, 0)</code> and they are occupying the same point in 3D space!</p><h1 id=vectors>Vectors</h1><p>We&rsquo;ve established that we can define the positions of objects and the offsets between objects in a 3D coordinate system with 3 numbers (for the x-axis, y-axis, and z-axis). A game engine could potentially store these numbers as three <code>float</code> variables.</p><p>However, a <strong>vector</strong> is a convenient way to group those numbers together in a meaningful way and treat them as one consolidated object. Vectors also define a variety of operations that make them easier and more convenient to use than separate float values.</p><p>At its core, a vector is just a collection of numbers. A 2D vector has 2 numbers, a 3D vector had 3 numbers, a 4D vector has 4 numbers, and so on. We could write very simple 2D & 3D vector structs in C++ like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Vector2</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>y</span><span class=p>;</span>    
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Vector3</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Vectors convey displacement along coordinate system axes. A 2D vector with the values <code>(2, 4)</code> conveys a displacement of 2 units along the x-axis and 4 units along the y-axis. A 2D vector <code>(-10, 6)</code> conveys displacement of -10 units along the x-axis and 6 units along the y-axis. The two numbers are often called the vector&rsquo;s <strong>x-component</strong> and <strong>y-component</strong>.</p><p>For 3D, we simply add an additional component to the vector. A 3D vector <code>(5, 2, -4)</code> conveys a displacement of 5 units on the x-axis, 2 units on the y-axis and -4 units on the z-axis. As you might guess, that additional value is the <strong>z-component</strong> of the vector.</p><p>We can represent vectors graphically by drawing them in a coordinate system. To graphically represent the vector <code>(4, 2)</code>, pick any arbitrary point to start at, then locate the point that is 4 units to the right (along the x-axis) and 2 units up (along the y-axis). Draw a line between those two points.</p><p>To differentiate between <code>(4, 2)</code> and <code>(-4, -2)</code>, we draw an arrow at one end of the line to represent the direction of the vector. We call the end with the arrow the <strong>head</strong> and the other end the <strong>tail</strong>.</p><p><img src=/img/gengine/vectors/two_vectors.png#center alt="Two Vectors"></p><p>A vector&rsquo;s components convey <strong>direction</strong> and <strong>magnitude</strong>. Changing a vector&rsquo;s components will change the vector&rsquo;s magnitude, direction, or both.</p><p>For example, the vectors <code>(-1, 0)</code> and <code>(1, 0)</code> point in exactly opposite directions but have the same magnitude. Similarly, <code>(1, 0)</code> and <code>(8, 0)</code> point in the same direction (both down the positive x-axis), but the latter is eight times longer - it has a larger magnitude.</p><p>When using vector variables in mathematical equations, the variables representing vectors are usually <strong>bolded</strong> to differentiate them from non-vectors (also called scalars). For example, <strong>b</strong>=<em>s</em><strong>a</strong> shows a vector <strong>a</strong> multiplied by a scalar <em>s</em>, resulting in the vector <strong>b</strong>.</p><h1 id=vectors-as-points>Vectors as Points</h1><p>If two vectors have equal components, then those vectors are equal to one another. A vector&rsquo;s components do not constrain the <em>position</em> of the vector in any way&mldr;so we can move vectors to different locations in a coordinate system and they are all equal.</p><p><img src=/img/gengine/vectors/equal_vectors.png#center alt="Equal Vectors">
<em>All the vectors in this image are equal to one another, despite being positioned at different spots visually.</em></p><p>Vectors convey displacements along axes, but we <strong>CAN</strong> use vectors to represent points in a coordinate system! To do so, we must assume that the vector represents a displacement from the coordinate system&rsquo;s origin.</p><p>For example, the point <code>(2, 3)</code> is 2 units along the x-axis and 3 units along the y-axis. The point&rsquo;s displacement from the origin is also <code>(2, 3)</code>.</p><p><img src=/img/gengine/vectors/vector_point.png#center alt="Using a Vector to Represent a Point">
<em>The point (2, 3) can be represented by the vector (2, 3), if we assume the tail of the vector is at the origin.</em></p><p>A &ldquo;point&rdquo; and a &ldquo;vector&rdquo; are technically different things, but in a game engine, it&rsquo;s common to use vectors to represent points.</p><p>It is important to keep track of which vectors represent points and which don&rsquo;t. Some mathematical operations won&rsquo;t make sense if the vectors used don&rsquo;t represent the right things. Clear variable naming is helpful!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Vector3</span> <span class=n>shipPos</span><span class=p>;</span> <span class=c1>// represents the position of the ship (i.e. a point)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Vector3</span> <span class=n>shipDir</span><span class=p>;</span> <span class=c1>// represents the direction the ship is facing (i.e. a vector)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Vector3</span> <span class=n>shipToEnemy</span><span class=p>;</span> <span class=c1>// represents a displacement from the ship to the enemy (i.e. a vector)
</span></span></span></code></pre></div><h1 id=why-vectors>Why Vectors?</h1><p>You don&rsquo;t <em>need</em> vectors to make a successful 2D or 3D video game, but they are a powerful tool in your toolbox.</p><p>Most video games attempt to build a virtual world of some kind, and the various objects that make up that world are in different positions and have different distances between them. The spatial relationships between objects in the world can be important for building interesting gameplay.</p><p>For example, consider a stealth game. Guards should raise an alarm if the player is within a certain distance AND the guard is facing the player. If a weapon is fired, the player should only take damage if their position was in the line of fire. A melee attack is only effective if the player is very near to the guard.</p><p>Vectors provide a convenient and consistent way to represent the following basic concepts in a video game world:</p><ul><li>The <strong>displacement</strong> (or <strong>offset</strong>) between two objects.</li><li>The <strong>direction</strong> an object is facing.</li><li>The <strong>position</strong> (or <strong>point</strong>) of an object in the world.</li></ul><p>Vectors are also useful for conveying any other axis-relative data, such as velocities, accelerations, or forces in physics simulations. Without vectors, you&rsquo;d have to implement ad-hoc solutions anytime you needed the above sorts of behaviors.</p><h1 id=vector-operations>Vector Operations</h1><p>Vectors are pretty handy just to group axis-related data into a single structure, but the real power of vectors is in the mathematical operations you can perform with them. Here, we&rsquo;ll review the most important ones for 3D games.</p><h2 id=vector-length>Vector Length</h2><p>The length (or magnitude) of a vector is calculated using the Pythagorean Theorem: given a right-triangle, the squared length of the hypotenuse is equal to the the squared lengths of the other sides summed: C<sup>2</sup> = A<sup>2</sup> + B<sup>2</sup></p><p>You can think of a vector as forming the hypotenuse of a right-triangle. The x-component corresponds to the adjacent side while the y-component corresponds to the opposite side.</p><p><img src=/img/gengine/vectors/vector_length_calc.png#center alt="Vector Length Calculation">
<em>The components of a vector form the sides of a right triangle.</em></p><p>Given this, we can calculate the length of <strong>v</strong> as:</p><pre tabindex=0><code>length = sqrt(v.x * v.x + v.y * v.y)
</code></pre><p>The Pythagorean Theorem also works for calculating the length of 3D vectors - just add Z to the equation!</p><pre tabindex=0><code>length = sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
</code></pre><p>The notation used to convey vector length is <strong>||a||</strong>. If we have vector <strong>a</strong> with values <code>(3, 4)</code>, we&rsquo;d say that <strong>||a||</strong> is equal to <code>5</code>.</p><pre tabindex=0><code>||a|| = sqrt(3 * 3 + 4 * 4) = sqrt(9 + 16) = sqrt(25) = 5
</code></pre><p>A vector&rsquo;s length can be modified by multiplying the vector by a scalar value. For example, multiplying by 2 doubles the length of the vector. Multiplying by 0.25 makes a vector a quarter its original size. Multiplying by a negative number <em>also</em> flips the direction of the vector!</p><pre tabindex=0><code>(2, 4) * -10 = (2 * -10, 4 * -10) = (-20, -40)
</code></pre><p>A vector with a length of <code>1</code> is called a <strong>unit vector</strong> and is said to have &ldquo;unit&rdquo; length. Unit vectors are important for certain algorithms. Any vector can be converted to unit length by dividing the vector by its own length, a process is called <strong>normalization</strong>:</p><pre tabindex=0><code>a_unit = a / ||a||
</code></pre><h3 id=displacement-vs-direction>Displacement vs Direction</h3><p>In some cases, the difference between <strong>displacement</strong> and <strong>direction</strong> can be important.</p><p>A &ldquo;direction&rdquo; is just a displacement that has been normalized. Because the length of the vector is <code>1</code>, multiplying by a scalar will result in a vector that gets its direction from the original vector and its magnitude from the scalar value.</p><p>Multiplying a direction vector by a scalar gives you a displacement vector. Dividing a displacement vector by its own length (normalization) gives you a direction vector.</p><p>Let&rsquo;s say I have a position vector <code>A</code> and a direction vector <code>F</code>. I want to calculate the point 10 units from <code>A</code> in the direction of <code>F</code>. I can do this:</p><pre tabindex=0><code>A + (10 * F)
</code></pre><p>Since <code>F</code> is normalized (pure direction vector), we multiply it by 10 to get a vector in the direction of <code>F</code> with a length of 10 (a displacement vector). We then add that vector to <code>A</code> to get a point 10 units from <code>A</code> in the direction of <code>F</code> (a position vector).</p><p>Easy, right? However, consider what would happen if the direction vector <code>F</code> were not normalized! The result of <code>10 * F</code> would not be the right length! And so the math would be wrong.</p><p>As a rule of thumb, any time you want to represent a direction (perhaps the direction that an object is facing or the normal of a surface), you should probably be using a unit-length vector for that purpose to avoid any unexpected side-effects.</p><h2 id=vector-addition>Vector Addition</h2><p>If you have two or more vectors, you can add them together to obtain a new vector representing the combination of those vectors. Mathematically, we simply add together the corresponding components of the two vectors.</p><pre tabindex=0><code>(2, 4) + (3, -5) = (5, -1)
</code></pre><p>You can visualize this as laying vectors end-to-end and then drawing a vector from the tail of the first vector to the head of the last vector.</p><p><img src=/img/gengine/vectors/vector_addition.png#center alt="Vector Addition">
<em>Vector addition is commutative, so we can add in any order and get the same final result. A+B == B+A</em></p><p>Vector addition is often useful to combine multiple displacement vectors OR to apply a displacement to a position. For example, if the player&rsquo;s position is <code>(5, 2, 0)</code> and we want to move them by a displacement of <code>(1, 0, 0)</code> for the current frame, the updated position would be:</p><pre tabindex=0><code>(5, 2, 0) + (1, 0, 0) = (6, 2, 0)
</code></pre><h2 id=vector-subtraction>Vector Subtraction</h2><p>To subtract one vector from another, simply subtract the corresponding components.</p><pre tabindex=0><code>(2, 4) - (3, -5) = (-1, 9)
</code></pre><p>Vector subtraction can be viewed as adding a negated vector. The following two statements are equivalent:</p><pre tabindex=0><code>(3, 4) - (2, 2) = (1, 2)
(3, 4) + (-2, -2) = (1, 2)
</code></pre><p>You can visualize vector subtraction by putting the two vectors with their tails at the same spot. The result of vector subtraction will go from the head of the second vector to the head of the first vector.</p><p><img src=/img/gengine/vectors/vector_subtraction.png#center alt="Vector Subtraction">
<em>As with normal subtraction, vector subtraction is not commutative. The direction of the result depends on the order of the subtraction. A-B != B-A</em></p><p>A common use of vector subtraction is finding the displacement between two points. This can be used to determine distance or direction between points. For example, given a player at <code>(4, 5)</code> and an enemy at <code>(8, 12)</code>, we can calculate:</p><pre tabindex=0><code>EnemyToPlayer = PlayerPos - EnemyPos = (8, 12) - (4, 5) = (4, 7)
PlayerToEnemy = EnemyPos - PlayerPos = (4, 5) - (8, 12) = (-4, -7)
</code></pre><p>The vectors are exactly opposite of one another. To move from point A to point B requires a vector <strong>a</strong>; to move from B to A requires <strong>-a</strong>.</p><h2 id=vector-multiplication>Vector Multiplication</h2><p>There are two ways to multiply a vector by another vector - one is called the <strong>Dot Product</strong> and the other is called the <strong>Cross Product</strong>. Both take two vectors as inputs, but the outputs (and meanings of the outputs) are very different.</p><h3 id=dot-product>Dot Product</h3><p>The result of the dot product is a <em>scalar</em> value that can be interpreted in several ways to derive meaningful information about the input vectors. Since the result is a scalar value, this operation is also sometimes called the <strong>Scalar Product</strong>.</p><p>To calculate the dot product, simply multiply the corresponding components of the two vectors and then add everything together:</p><pre tabindex=0><code>A • B = (3, 4) • (8, 10) = (3 * 8) + (4 * 10) = 24 + 40 = 64
</code></pre><p>The operator for the dot product is <code>•</code> (a dot).</p><p>The dot product has three common uses: determining how &ldquo;similar&rdquo; two vectors are to one another, calculating the angle between two vectors, and vector decomposition.</p><h4 id=similar-vectors>Similar Vectors</h4><p>The dot product can tell us how &ldquo;similar&rdquo; two vectors are to one another:</p><ul><li>A result of <code>0</code> indicates that the vectors are <em>perpendicular</em> to one another.</li><li>A result greater than <code>0</code> indicates that the angle between the two vectors is acute (i.e. the vectors are facing roughly the same direction).</li><li>A result less than <code>0</code> indicates that the angle between the two vectors is obtuse (i.e. the vectors are facing roughly in opposite directions).</li></ul><p><img src=/img/gengine/vectors/dot_product_similar.png#center alt="Dot Product Similarities"></p><p>If the input vectors are both unit-length, the dot product <em>also</em> tells us this:</p><ul><li>For unit vectors, the dot product result will always be in the range -1 to 1.</li><li>If the result is <code>1</code>, the two vectors are parallel and pointing in the same direction.</li><li>If the result is <code>-1</code>, the two vectors are parallel and pointing in opposite directions.</li></ul><p><img src=/img/gengine/vectors/dot_product_similar_unit.png#center alt="Dot Product Unit Similarities"></p><p>One scenario where this is useful is for determining whether two objects are &ldquo;facing&rdquo; one another in a game. We can use the vectors representing the two objects&rsquo; facing directions, take the dot product, and determine if they are facing or not.</p><h4 id=angle-between-vectors>Angle Between Vectors</h4><p>In conjunction with the arc-cosine function, the dot product can be used to calculate the angle between two vectors:</p><pre tabindex=0><code>θ = acos(a • b / ||a|| * ||b||)
</code></pre><p>This equation divides by the lengths of <strong>a</strong> and <strong>b</strong> to ensure the vectors are unit length. If you already know the vectors are unit length, the equation can simplify:</p><pre tabindex=0><code>θ = acos(a • b)
</code></pre><p>The resulting angle will always be in the range of 0 to π radians (or 0 to 180 degrees). This is because the result of the dot product between unit vectors is always in the range -1 to 1.</p><p>Often, you can check the dot product between unit vectors to determine whether the vectors are or aren&rsquo;t facing one another. But it is sometimes helpful to know the exact angle in radians or degrees - you can use arc-cos to achieve that.</p><h4 id=vector-decomposition>Vector Decomposition</h4><p>If vector addition allows us to combine two or more vectors into one vector, vector <strong>decomposition</strong> allows us to split a single vector into multiple vectors. The dot product plays a key role in this operation.</p><p>Say we&rsquo;ve got a vector <strong>a</strong> and a unit-vector <strong>b</strong>. Though not obvious, the dot product when one vector is unit length gives us the magnitude of <strong>a</strong> in the direction of <strong>b</strong>.</p><p><img src=/img/gengine/vectors/scalar_projection.png#center alt="Scalar Projection">
<em>This operation isolates the portion of the magnitude of <strong>a</strong> that&rsquo;s in the direction of <strong>b</strong></em>.</p><p>This value is called the <strong>scalar projection</strong> of <strong>a</strong> onto <strong>b</strong>. Once known, you can multiply it by <strong>b</strong> to get the <strong>projection</strong> of <strong>a</strong> onto <strong>b</strong>.</p><p><img src=/img/gengine/vectors/vector_projection.png#center alt="Vector Projection"></p><p>From there, you can subtract the projection from the original vector <strong>a</strong> to get the <strong>rejection</strong> of <strong>a</strong> from <strong>b</strong>.</p><p><img src=/img/gengine/vectors/vector_rejection.png#center alt="Vector Projection"></p><p>The result of this process is to take a vector and <em>decomposed</em> it into two smaller vectors - the opposite of vector addition. If you add the projection and the rejection together, you get the original vector back!</p><h3 id=cross-product>Cross Product</h3><p>The result of the cross product is a vector. For that reason, it is also sometimes called the <strong>Vector Product</strong>. The operator for the cross product is <code>✕</code> (a cross).</p><p>The cross product only works in 3D, whereas most other vector operations work in ANY dimension. The math is a bit harder to remember than other vector operations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// c = a ✕ b
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>c</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>b</span><span class=p>.</span><span class=n>z</span> <span class=o>-</span> <span class=n>a</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>b</span><span class=p>.</span><span class=n>y</span>
</span></span><span class=line><span class=cl><span class=n>c</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span> <span class=o>-</span> <span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>b</span><span class=p>.</span><span class=n>z</span>
</span></span><span class=line><span class=cl><span class=n>c</span><span class=p>.</span><span class=n>z</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>b</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>a</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span>
</span></span></code></pre></div><p>There is a
<a href=https://en.wikipedia.org/wiki/Cross_product#Mnemonic target=_blank>handy mnemonic</a> if you need to memorize it!</p><p>The result of the cross product is a vector perpendicular to the two input vectors. There are <strong>two</strong> possible perpendicular vectors! The order in which you perform the cross product determines which of the two will be the result!</p><p><img src=/img/gengine/vectors/cross_product.png#center alt="Cross Product">
<em>Assuming a right-handed coordinate system, the cross products axb and bxa.</em></p><p>We&rsquo;ll discuss the difference between right-handed and left-handed 3D coordinate systems later on. But the results in the image would be exactly opposite if we were using a left-handed coordinate system.</p><p>The cross product will be useful in a variety of situations where we need to know a vector that is perpendicular to two other vectors.</p><h1 id=writing-vector-classes>Writing Vector Classes</h1><p>Whew, that&rsquo;s a lot of info! Hopefully you now have a basic understanding of what vectors are, why they&rsquo;re useful, the data they contain, and the operations we can perform on them. To use them in our game engine, we need to create some classes representing vectors and their operations.</p><p>A vector class ideally needs to support the following:</p><ul><li>Assignment and equality checks</li><li>Get and set components</li><li>Addition and subtraction</li><li>Scalar multiplication</li><li>Length</li><li>Normalization</li><li>Dot product</li><li>Cross product</li></ul><p>A 3D game engine will usually need to support these operations for 2D, 3D, and 4D vectors. The inclusion of 4D vectors may be puzzling, but we&rsquo;ll discuss that more in the future! A 4D vector simply has an additional component, often called &ldquo;w&rdquo;.</p><p>The vector classes used by G-Engine can be found here:</p><ul><li>Vector2
<a href=https://github.com/kromenak/gengine/blob/master/Source/Vector2.h target=_blank>header</a> and
<a href=https://github.com/kromenak/gengine/blob/master/Source/Vector2.cpp target=_blank>source</a></li><li>Vector3
<a href=https://github.com/kromenak/gengine/blob/master/Source/Vector3.h target=_blank>header</a> and
<a href=https://github.com/kromenak/gengine/blob/master/Source/Vector3.cpp target=_blank>source</a></li><li>Vector4
<a href=https://github.com/kromenak/gengine/blob/master/Source/Vector4.h target=_blank>header</a> and
<a href=https://github.com/kromenak/gengine/blob/master/Source/Vector4.cpp target=_blank>source</a></li></ul><p>Next, I&rsquo;ll highlight some considerations to make when writing these classes.</p><h2 id=naming>Naming</h2><p>It&rsquo;s fairly common to call vector classes something like <code>Vector2</code>, <code>Vector3</code>, and <code>Vector4</code>. The names <code>Vector2D</code>, <code>Vector3D</code>, or <code>Vector4D</code> are also common. Of course, you could name them however you&rsquo;d like!</p><h2 id=data-layout>Data Layout</h2><p>Let&rsquo;s say you have an array of <code>float</code> where every three elements represent the x/y/z components of a point in 3D space. You may want to reinterpret that memory as an array of <code>Vector3</code> without allocating new memory.</p><p>Likewise, you may want to do the opposite: treat a <code>Vector3</code> as an array of three <code>float</code>.</p><p>To achieve this, it&rsquo;s important that a Vector class ONLY stores the relevant component data, stores it in the correct order, and DOES NOT store any additional data.</p><p>The only data members in the class should be <code>x</code> and <code>y</code> for a 2D vector; <code>x</code>, <code>y</code>, and <code>z</code> for a 3D vector; and <code>x</code>, <code>y</code>, <code>z</code>, and <code>w </code>for a 4D vector. In a 4D vector, the <code>w</code> component should go last.</p><h2 id=dont-inherit>Don&rsquo;t Inherit</h2><p>It may be tempting to inherit <code>Vector4</code> from <code>Vector3</code>, and inherit <code>Vector3</code> from <code>Vector2</code>. Resist the temptation!</p><p>From a purely pedantic perspective, inheritance should be used for &ldquo;is-a&rdquo; relationships. A <code>Vector4</code> is not a <code>Vector3</code>.</p><p>If you do choose to inherit, you&rsquo;ll find that the only thing you achieve is not having to repeat the <code>x</code> or <code>y</code> components in the new class. All operations defined in <code>Vector2</code> needs to be overridden or redefined for <code>Vector3</code>. And introducing virtual function calls to our Vector class adds overhead - we want our vector classes to be lightning fast low-level math functionality.</p><h2 id=public-data-members>Public Data Members</h2><p>If you&rsquo;re big on data encapsulation and writing shy classes (like me), you&rsquo;d think that the x/y/z components of a vector should not be public data.</p><p>However, you do need to be able to get and set component values, so you&rsquo;ll end up writing getters and setters anyway. The data will <em>effectively</em> be public. Furthermore, using getters and setters makes some vector math harder to read:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Which do you prefer?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v1</span><span class=p>.</span><span class=n>x</span> <span class=o>+=</span> <span class=n>v2</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>someVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>v1</span><span class=p>.</span><span class=n>SetX</span><span class=p>(</span><span class=n>v1</span><span class=p>.</span><span class=n>GetX</span><span class=p>()</span> <span class=o>+</span> <span class=n>v2</span><span class=p>.</span><span class=n>GetX</span><span class=p>()</span> <span class=o>*</span> <span class=n>someVal</span><span class=p>);</span>
</span></span></code></pre></div><p>You may notice that I don&rsquo;t have public components in my Vector classes - I regret making that choice. I would recommend public access to vector components. I&rsquo;ll probably change this in the future.</p><h2 id=squared-length>Squared Length</h2><p>In addition to a <code>Length</code> function, provide a <code>LengthSq</code> function. There are many cases where the squared length of a vector will work as well as regular length, and it&rsquo;s a cheaper operation to perform.</p><p>For example, we could say <code>if(v.GetLengthSq() &lt; 9)</code> rather than <code>if(v.GetLength() &lt; 3)</code>.</p><h2 id=constants>Constants</h2><p>It&rsquo;s pretty common to provide a number of handy constants. These include: the zero vector, a vector where each component is one, and a unit vector pointing down each axis. For example, you might call these <code>Zero</code>, <code>One</code>, <code>UnitX</code>, <code>UnitY</code>, <code>UnitZ</code>.</p><h2 id=conversions>Conversions</h2><p>Implicit conversions between <code>Vector2</code> and <code>Vector3</code> and <code>Vector4</code> are usually desirable. To do this, define constructors that take as arguments the other types of vectors.</p><p>To convert from a larger vector to a smaller one, simply discard the extra components. To convert from a smaller vector to a larger one, assume the added components have a default value of zero.</p><h2 id=operator-overrides>Operator Overrides</h2><p>When you perform vector math on paper, you generally use a number of common mathematical operators to represent concepts like vector addition, subtraction, and scalar multiplication or division.</p><pre tabindex=0><code>a += ((b + c) - (v - u)) * 5; // some fairly complex vector math
</code></pre><p>We&rsquo;d like to write our code in a similar way, if we can. As a result, operator overrides for vector addition, subtraction, scalar multiplication, and scalar division are recommended.</p><p>Operations like dot product and cross product do have nice mathematical notation, but C++ doesn&rsquo;t support overrides for those types of operators. As a result, you&rsquo;ll have to simply create functions called <code>Dot</code> and <code>Cross</code>. These are usually <code>static</code> functions.</p><h2 id=careful-naming-to-signal-usage>Careful Naming to Signal Usage</h2><p>If you call <code>vector.Normalize()</code>, does it normalize the vector OR does it return a normalized vector, leaving the original vector untouched?</p><p>In many of the math classes we will discuss, there are certain functions like this where you need to be careful that the public API is clear, easy to use, and not prone to error.</p><p>Subtle naming differences can imply usage:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>v</span><span class=p>.</span><span class=n>Normalize</span><span class=p>();</span> <span class=c1>// normalizes v
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Vector3</span> <span class=n>n</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>Normalized</span><span class=p>();</span> <span class=c1>// returns a normalized vector, v is unchanged
</span></span></span></code></pre></div><p>Subtle naming differences are also easy to miss, so maybe making it more obvious is a good idea:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>v</span><span class=p>.</span><span class=n>Normalize</span><span class=p>();</span> <span class=c1>// normalizes v
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v</span><span class=p>.</span><span class=n>GetNormalized</span><span class=p>();</span> <span class=c1>// returns a normalized vector, v is unchanged
</span></span></span></code></pre></div><h2 id=vector-io>Vector I/O</h2><p>When running your game, you probably want to be able to print out Vectors to the log for debugging or data recording purposes. Assuming you use C++&rsquo;s I/O stream to output to the console, you will likely want to define <code>operator&lt;&lt;</code> for your Vector classes:</p><pre tabindex=0><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector3&amp; v)
{
    os &lt;&lt; std::setprecision(9) &lt;&lt; &#34;(&#34; &lt;&lt; v.GetX() &lt;&lt; &#34;, &#34; &lt;&lt; v.GetY() &lt;&lt; &#34;, &#34; &lt;&lt; v.GetZ() &lt;&lt; &#34;)&#34;;
    return os;
}
</code></pre><h1 id=conclusion>Conclusion</h1><p>In this post, I&rsquo;ve tried to provide a crash course in vectors and vector math, but if this all seems extremely confusing and needs further explanation, there are a ton of helpful resources online and in book form to become a vector math ace. I&rsquo;d recommend the following:</p><ul><li><a href=https://www.mathsisfun.com/algebra/vectors.html target=_blank>Vector Intro</a></li><li><a href=https://en.wikipedia.org/wiki/Euclidean_vector target=_blank>Wikipedia Page</a></li><li><a href=https://www.khanacademy.org/math/linear-algebra/vectors-and-spaces target=_blank>Khan Academy</a></li><li><a href=/reading#lengyel-math>Foundations of Game Engine Development, Volume 1: Mathematics</a></li><li><a href=/reading>Essential Mathematics for Games and Interactive Applications</a></li><li><a href=/reading>Game Engine Architecture</a></li></ul><div class=blog-tags><a href=https://kromenak.github.io//tags/g-engine/>G-Engine</a>&nbsp;
<a href=https://kromenak.github.io//tags/c++/>C++</a>&nbsp;
<a href=https://kromenak.github.io//tags/math/>Math</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://kromenak.github.io/post/gengine-06-math/ data-toggle=tooltip data-placement=top title="G-Engine #6: Math Library">&larr; Previous Post</a></li><li class=next><a href=https://kromenak.github.io/post/gengine-08-matrices/ data-toggle=tooltip data-placement=top title="G-Engine #8: Matrices">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2024</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://kromenak.github.io/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>