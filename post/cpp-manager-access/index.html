<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Accessing Managers in C++ - Clark Kromenaker</title>
<meta name=description content="Every game or game engine has at least a few managers under the hood. A manager is a collection of functions and data whose purpose is to &ldquo;manage&rdquo; something. You may send HTTP requests through an HttpManager. You may track the player&rsquo;s inventory with an InventoryManager. You may play audio through an AudioManager. And so on.
How you access a manager is a seemingly mundane decision that can be surprisingly complex and paralyzing. Do you pass the manager as a function parameter? Use a global variable? Make a bunch of static functions or a namespace? Devise more elaborate mechanisms? Each option has pros and cons, and personal preference comes into play as well. Changing your mind later can incur significant refactoring overhead.
I&rsquo;ve been coding games for about a decade now, so I&rsquo;ve developed some opinions and ideas on this subject. I don&rsquo;t think there&rsquo;s a &ldquo;best&rdquo; or &ldquo;right&rdquo; way to do this, but there are a few ways to consider that might be useful in varying contexts.
Below, I&rsquo;ll review several access options along with some pros/cons of each."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/clarkkromenaker.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/clarkkromenaker.com\/post\/cpp-manager-access\/","name":"Accessing managers in c"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"Accessing Managers in C\u002b\u002b","description":"Every game or game engine has at least a few managers under the hood. A manager is a collection of functions and data whose purpose is to \u0026ldquo;manage\u0026rdquo; something. You may send HTTP requests through an HttpManager. You may track the player\u0026rsquo;s inventory with an InventoryManager. You may play audio through an AudioManager. And so on.\nHow you access a manager is a seemingly mundane decision that can be surprisingly complex and paralyzing. Do you pass the manager as a function parameter? Use a global variable? Make a bunch of static functions or a namespace? Devise more elaborate mechanisms? Each option has pros and cons, and personal preference comes into play as well. Changing your mind later can incur significant refactoring overhead.\nI\u0026rsquo;ve been coding games for about a decade now, so I\u0026rsquo;ve developed some opinions and ideas on this subject. I don\u0026rsquo;t think there\u0026rsquo;s a \u0026ldquo;best\u0026rdquo; or \u0026ldquo;right\u0026rdquo; way to do this, but there are a few ways to consider that might be useful in varying contexts.\nBelow, I\u0026rsquo;ll review several access options along with some pros\/cons of each.\n","inLanguage":"en","wordCount":2892,"datePublished":"2021-10-30T00:00:00","dateModified":"2021-10-30T00:00:00","image":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","keywords":["C\u002b\u002b"],"mainEntityOfPage":"https:\/\/clarkkromenaker.com\/post\/cpp-manager-access\/","publisher":{"@type":"Organization","name":"https:\/\/clarkkromenaker.com\/","logo":{"@type":"ImageObject","url":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="Accessing Managers in C++"><meta property="og:description" content="Every game or game engine has at least a few managers under the hood. A manager is a collection of functions and data whose purpose is to &ldquo;manage&rdquo; something. You may send HTTP requests through an HttpManager. You may track the player&rsquo;s inventory with an InventoryManager. You may play audio through an AudioManager. And so on.
How you access a manager is a seemingly mundane decision that can be surprisingly complex and paralyzing. Do you pass the manager as a function parameter? Use a global variable? Make a bunch of static functions or a namespace? Devise more elaborate mechanisms? Each option has pros and cons, and personal preference comes into play as well. Changing your mind later can incur significant refactoring overhead.
I&rsquo;ve been coding games for about a decade now, so I&rsquo;ve developed some opinions and ideas on this subject. I don&rsquo;t think there&rsquo;s a &ldquo;best&rdquo; or &ldquo;right&rdquo; way to do this, but there are a few ways to consider that might be useful in varying contexts.
Below, I&rsquo;ll review several access options along with some pros/cons of each."><meta property="og:image" content="https://clarkkromenaker.com/img/avatar-icon.png"><meta property="og:url" content="https://clarkkromenaker.com/post/cpp-manager-access/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="Accessing Managers in C++"><meta name=twitter:description content="Every game or game engine has at least a few managers under the hood. A manager is a collection of functions and data whose purpose is to &ldquo;manage&rdquo; something. You may send HTTP requests â€¦"><meta name=twitter:image content="https://clarkkromenaker.com/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://clarkkromenaker.com/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://clarkkromenaker.com/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://clarkkromenaker.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://clarkkromenaker.com/css/syntax.css><link rel=stylesheet href=https://clarkkromenaker.com/css/codeblock.css><link rel=stylesheet href=https://clarkkromenaker.com//css/portfolio.css><link rel=stylesheet href=https://clarkkromenaker.com//css/misc.css><link rel=stylesheet href=https://clarkkromenaker.com//css/overrides.css><script src=https://clarkkromenaker.com//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://clarkkromenaker.com/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://clarkkromenaker.com/><img class=avatar-img src=https://clarkkromenaker.com/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Accessing Managers in C++</h1><span class=post-meta><i class=fas></i>Posted on October 30, 2021</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>Every game or game engine has at least a few managers under the hood. A manager is a collection of functions and data whose purpose is to &ldquo;manage&rdquo; something. You may send HTTP requests through an <code>HttpManager</code>. You may track the player&rsquo;s inventory with an <code>InventoryManager</code>. You may play audio through an <code>AudioManager</code>. And so on.</p><p>How you access a manager is a seemingly mundane decision that can be surprisingly complex and paralyzing. Do you pass the manager as a function parameter? Use a global variable? Make a bunch of static functions or a namespace? Devise more elaborate mechanisms? Each option has pros and cons, and personal preference comes into play as well. Changing your mind later can incur significant refactoring overhead.</p><p>I&rsquo;ve been coding games for about a decade now, so I&rsquo;ve developed some opinions and ideas on this subject. I don&rsquo;t think there&rsquo;s a &ldquo;best&rdquo; or &ldquo;right&rdquo; way to do this, but there are a few ways to consider that might be useful in varying contexts.</p><p>Below, I&rsquo;ll review several access options along with some pros/cons of each.</p><h1 id=singletons>Singletons</h1><p>The idea behind the singleton is pretty straightforward: a class contains a static function called <code>Instance()</code>. The first time you call this function, it creates and stores the class instance in a static variable. Subsequent calls to <code>Instance()</code> return the previously created instance. You can even make the constructor private, thereby ensuring that the only way to access OR create an instance of the class is by calling <code>Instance()</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Manager</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Manager</span><span class=o>&amp;</span> <span class=n>Instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=n>Manager</span> <span class=n>manager</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>manager</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PerformAction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Manager</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Then, elsewhere in your code, you can access Manager functions easily:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Manager</span><span class=o>::</span><span class=n>Instance</span><span class=p>().</span><span class=n>PerformAction</span><span class=p>();</span>
</span></span></code></pre></div><p>In this example, I&rsquo;m using a &ldquo;static local variable&rdquo; to store the created instance. Memory for such variables is allocated globally (when the program starts), but the instance is not constructed until that line of code is executed. Subsequent calls to <code>Instance()</code> just return the existing manager, skipping construction of a new instance.</p><p>The singleton approach faciliates &ldquo;lazy initialization,&rdquo; which can be either a blessing or a curse. Since the object is only constructed the first time <code>Instance()</code> is called, it may be possible to delay or entirely avoid constructing the object, thereby making the program launch faster. On the flipside, if you accidentally trigger construction in the middle of gameplay, it can cause a noticeable framerate drop.</p><p>A variation of the singleton pattern just provides global access while disallowing multiple instances:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Manager.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Manager</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Manager</span><span class=o>&amp;</span> <span class=n>Instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=n>instance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Manager</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>instance</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>instance</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Manager</span><span class=o>*</span> <span class=n>instance</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Manager.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Manager</span><span class=o>*</span> <span class=n>Manager</span><span class=o>::</span><span class=n>instance</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><p>In this case, you must be sure that you&rsquo;ve manually constructed the class instance before you call <code>Instance()</code>. Attempting to construct a second instance will also trigger an assert, so don&rsquo;t do that! I use this variation in
<a href=https://github.com/kromenak/gengine target=_blank>my engine project</a> in at least one spot. This variation is also useful when normal singletons are not possible - such as Unity engine Monobehavior subclasses.</p><h1 id=static-variablesfunctions>Static Variables/Functions</h1><p>If our intention is to only have one instance, a simple option is to implement the manager purely as static variables and functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Manager.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Manager</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>void</span> <span class=n>PerformAction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>sMyInt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Manager.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>Manager</span><span class=o>::</span><span class=n>sMyInt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Manager</span><span class=o>::</span><span class=n>PerformAction</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>sMyInt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Because the functions and data are static, they are associated with the Manager namespace, but not any specific instance of the Manager class. You can then access this elsewhere in your code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Manager</span><span class=o>::</span><span class=n>PerformAction</span><span class=p>();</span>
</span></span></code></pre></div><p>Despite the C++ syntax, we are essentially just creating functions/variables that are within a &ldquo;Manager&rdquo; namespace. However, we are still able to use C++ access modifiers - in this example, the static variable <code>myInt</code> is not accessible to outside parties.</p><p>One limitation of this approach is that there&rsquo;s no possibility for inheritance. Also, if you think you might need multiple instances of the object in the future, it&rsquo;s harder to refactor this into a normal C++ class. Finally, there is no way to define a static constructor/destructor - use separate Init/Shutdown functions if such logic is needed.</p><p>One interesting thing about this approach is that it begs the question as to whether a separate manager class is needed <em>at all</em>. For example, let&rsquo;s say you have these two classes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>EventManager</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Event</span> <span class=n>CreateEvent</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Event</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>mName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>You could combine the two and have management functions exist ON the object class itself:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Event</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Event</span> <span class=n>CreateEvent</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>mName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>If your manager functions are not very complex, this can be a good approach. But I like to keep management functions separate if there are too many of them, or they are very complicated.</p><h1 id=namespaces>Namespaces</h1><p>Taking the previous approach a little further, you can forego a class entirely and just use a namespace, which makes the syntax a bit simpler:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Manager.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span> <span class=n>Manager</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PerformAction</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Manager.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>namespace</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>myInt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// could also be a &#34;static&#34; variable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Manager</span><span class=o>::</span><span class=n>PerformAction</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>myInt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>You can then access this manager elsewhere like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Manager</span><span class=o>::</span><span class=n>PerformAction</span><span class=p>();</span>
</span></span></code></pre></div><p>This approach is nearly identical to the previous &ldquo;static&rdquo; approach, just with different syntax. I actually find this approach more readable and straightforward.</p><p>This approach also hides private functions and data inside the cpp class, so it is no longer part of the header file at all. This can be helpful for encapsulation and avoiding adding includes to the header file. An &ldquo;anonymous namespace&rdquo; is used here to make variables &ldquo;file local&rdquo; - the <code>static</code> keyword could also be used instead.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>myInt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// identical result to an anonymous namespace
</span></span></span></code></pre></div><p>This approach has the same limitations as the &ldquo;static&rdquo; approach (no inheritance, no multiple instances, no constructor/destructor).</p><p>I generally favor this approach for &ldquo;utility&rdquo; type classes where the functions are very self-contained (outside of maybe calling standard library functions). For example, GEngine has a
<a href=https://github.com/kromenak/gengine/blob/master/Source/Util/StringUtil.h target=_blank>StringUtil</a> implemented as a namespace with various useful string manipulation functions.</p><h1 id=global-variables>Global Variables</h1><p>You can find plenty of advice online telling you to avoid global variables. And it&rsquo;s true that your program can quickly devolve into a tangled mess if you get too cozy with the globals.</p><p>But here&rsquo;s the thing: sometimes global variables are OK. Use them cautiously and sparingly - they can be effective.</p><p>In this approach, we create a header file for the class which is also responsible for declaring (but not defining) a global variable:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Manager.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Manager</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>PerformAction</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>Manager</span> <span class=n>gManager</span><span class=p>;</span>
</span></span></code></pre></div><p>In C++, you can <em>declare</em> static and global variables in a header file, but you must also <em>define</em> the variables in a cpp file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Manager.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Manager</span> <span class=n>gManager</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Manager</span><span class=o>::</span><span class=n>PerformAction</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Code goes here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>You can then access the manager elsewhere:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>gManager</span><span class=p>.</span><span class=n>PerformAction</span><span class=p>();</span>
</span></span></code></pre></div><p>There is something simple and powerful about directly grabbing the handle to the manager and doing what you&rsquo;ve got to do - no functions to call, no lookups to perform, no multiple levels of pointer indirection. A project I recently worked on has been using this approach successfully for a decade.</p><p>If this makes you feel icky, consider that most alternatives can still be viewed as global variables to some degree. For example, aren&rsquo;t singletons just a global variable that you hide inside a static function?</p><h1 id=single-global-instance>Single Global Instance</h1><p>Let&rsquo;s say we have 10 or 20 manager classes and we&rsquo;re feeling a bit squeamish about making them all singletons or global variables. Perhaps we don&rsquo;t like how decentralized that&rsquo;d be, and we want to keep things in a single organized place (it&rsquo;s nice to know at a glance what manager classes exist in your game). Or perhaps we just don&rsquo;t like singletons and global variables!</p><p>One way to get the benefit of global access without spreading it to every class is to choose a single class that will act as the &ldquo;single global instance&rdquo; in the program. A &ldquo;manager of managers&rdquo; if you will:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Managers</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>CharacterManager</span> <span class=n>characterManager</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LevelManager</span> <span class=n>levelManager</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>HttpManager</span> <span class=n>httpManager</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>EventManager</span> <span class=n>eventManager</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// And so on.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>This class can implement one of the global access methods outlined earlier. As a result, we have just one class that has direct global access mechanisms, but all the contained classes can also be reached fairly easily.</p><p>We can then access managers elsewhere like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Managers</span><span class=o>::</span><span class=n>Instance</span><span class=p>().</span><span class=n>characterManager</span><span class=p>.</span><span class=n>PerformAction</span><span class=p>();</span>
</span></span></code></pre></div><p>If you think that function call is unwieldy and ugly, I agree! One way to alleviate this is by using static class variables that are named effectively:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Managers.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Managers</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>CharacterManager</span> <span class=n>Characters</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Elsewhere - ahh, much better.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Managers</span><span class=o>::</span><span class=n>Characters</span><span class=p>.</span><span class=n>PerformAction</span><span class=p>();</span>
</span></span></code></pre></div><p>This shortens the function call significantly and conveys only the important information (we are getting a manager, for characters, and performing this particular action).</p><h1 id=service-locator>Service Locator</h1><p>The key feature of the service locator is that instead of accessing a manager variable directly, we obtain it using a templated &ldquo;getter&rdquo; function. The getter function locates the manager in a map/dictionary structure and returns it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Managers.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Managers</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=k>static</span> <span class=kt>void</span> <span class=n>Set</span><span class=p>(</span><span class=n>T</span><span class=o>*</span> <span class=n>instance</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=k>static</span> <span class=n>T</span><span class=o>*</span> <span class=n>Get</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &#34;ClassType&#34; is a hashable unique identifier for a class.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>ClassType</span><span class=p>,</span> <span class=kt>void</span><span class=o>*&gt;</span> <span class=n>sTypeToInstancePointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>During initialization, you must populate the dictionary:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Managers</span><span class=o>::</span><span class=n>Set</span><span class=o>&lt;</span><span class=n>MyManager</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>MyManager</span><span class=p>());</span>
</span></span></code></pre></div><p>You can then obtain a manager elsewhere in your code like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Managers</span><span class=o>::</span><span class=n>Get</span><span class=o>&lt;</span><span class=n>MyManager</span><span class=o>&gt;</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>PerformAction</span><span class=p>();</span>
</span></span></code></pre></div><p>An implementation of this approach can be
<a href=/files/Services.h>found here</a>.</p><p>The defining characteristic of the service locator is that it&rsquo;s rather dynamic and generalized. Instead of defining a set number of managers at compile-time, you can specify any number of managers via <code>Set()</code> and obtain them later via <code>Get()</code>.</p><p>This approach really shines when you use interfaces. For example, if you have an <code>IRenderer</code> interface that is implemented by different concrete classes for different platforms (RendererD3D, RenderOGL, RendererPS4, etc), you can do something like this to easily swap between them at runtime:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In game init code:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#if defined(ON_WINDOWS)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>Managers</span><span class=o>::</span><span class=n>Set</span><span class=o>&lt;</span><span class=n>IRenderer</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>RendererD3D</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>Managers</span><span class=o>::</span><span class=n>Set</span><span class=o>&lt;</span><span class=n>IRenderer</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>RendererOGL</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Later on in rendering code, not having to worry about platform-specific stuff:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Managers</span><span class=o>::</span><span class=n>Get</span><span class=o>&lt;</span><span class=n>IRenderer</span><span class=o>&gt;</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>Draw</span><span class=p>();</span>
</span></span></code></pre></div><p>There are downsides to this approach. It&rsquo;s obviously more complicated to implement and use than other methods. It has more likelihood to fail at runtime (what if Get returns a nullptr?). Storing class instances in a map requires some sort of RTTI. And performance is undoubtedly worse just because getting an instance incurs a map lookup and pointer indirection.</p><p>In the past, I thought this approach was just the absolute best because it wasn&rsquo;t much code to write, it was flexible/extendable, and it let you swap implementations using interfaces. Nowadays, I think it has its place, but it feels a bit over-engineered and probably overkill for a lot of scenarios.</p><h1 id=making-a-choice>Making a Choice</h1><p>All these options solve the problem&mldr;so how do you choose?</p><h2 id=global-access>Global Access</h2><p>The methods discussed above boil down to accessing a globally available namespace or variable. Conventional wisdom says global access is a Bad Thing(TM): it increases complexity, it increases coupling between systems, and it makes refactoring more difficult.</p><p>The alternative is local access. The most local option is to pass manager references into functions as parameters. The next-most-local option is to store manager references as class member variables. In theory, it&rsquo;s nice to think about a program that uses no global access; but in practice, this can become tedious.</p><p>Rather than <em>never</em> using globals, I think it&rsquo;s more helpful to be cautious and use it sparingly. Don&rsquo;t use it for every little variable in your program, but don&rsquo;t be afraid to use it on occasion and after serious consideration. If ALL global access is bad, you&rsquo;ll find yourself using increasingly complex alternatives that hide, but probably don&rsquo;t truly resolve, global access.</p><h2 id=allocation-construction-and-initialization>Allocation, Construction, and Initialization</h2><p>These options have various allocation and construction characteristics:</p><ul><li><strong>Allocation</strong>: where and when is the memory allocated for the object?</li><li><strong>Construction</strong>: when is the object constructed?</li></ul><p>Global and static variables (including static local variables) are allocated as the program starts, before <code>main()</code> executes. This can be beneficial: they don&rsquo;t eat up limited stack space, and they don&rsquo;t need to be allocated dynamically.</p><p>Global and static class variables are also constructed when the program starts, but with one massive problem:
<a href=https://pabloariasal.github.io/2020/01/02/static-variable-initialization/#the-red-zone---static-initialization-order-fiasco target=_blank>the order of construction is undefined</a>! This means that if there are dependencies between your global/static constructors, you are likely to run into trouble.</p><p>One common workaround is to separate <em>construction</em> from <em>initialization</em>. This means constructors do nothing except perhaps set default values for member variables. There is a separate function <code>Init()</code> that performs initialization, and this function is called during program startup in the correct ordering based on dependencies:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Engine</span><span class=o>::</span><span class=n>Init</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// MusicManager depends on AudioManager, and so must be initialized after.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>gAudioManager</span><span class=p>.</span><span class=n>Init</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>gMusicManager</span><span class=p>.</span><span class=n>Init</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Destruction order is also undefined, so it is useful to also define custom <code>Shutdown()</code> functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Engine</span><span class=o>::</span><span class=n>Shutdown</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Usually, shutdown in opposite order of init.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>gMusicManager</span><span class=p>.</span><span class=n>Shutdown</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>gAudioManager</span><span class=p>.</span><span class=n>Shutdown</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note that static <em>local</em> variables do not suffer from this undefined construction order problem - they are constructed when the containing function is executed and their line of code is reached.</p><h2 id=headers>Headers</h2><p>When I teach C++, students are often bewildered at how complex header management can be. When I&rsquo;m explaining the ins and outs, I am also self-aware at how ridiculous it seems. But it is what it is, so it&rsquo;s useful to understand it and think about it.</p><p>Compilation time can be directly tied to how you include header files. Making a small tweak in a header that is included in hundreds of .cpp files can trigger a very long recompile. On the other hand, if the header is only included in one or two .cpp files, the recompile might be very short.</p><p>Additionally, if you include one header in your .cpp file, but <em>that</em> header includes a hundred other headers, your seemingly simple .cpp file is suddenly thousands of lines long once all the includes are considered. This also increases compile times.</p><p>In general, I advise only including headers that are immediately relevant to the current file. If you use <code>std::vector</code>, include <code>&lt;vector></code>. If you need to call a function in your audio manager, include <code>AudioManager.h</code>.</p><p>Of the above approaches, the &ldquo;Single Global Instance&rdquo; and &ldquo;Service Locator&rdquo; patterns can pose a problem here. Let&rsquo;s say you have your global &ldquo;manager of managers&rdquo; class that itself has a dozen managers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Managers.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;AudioManager.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;CharacterManager.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Several dozen other includes here.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Managers</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>AudioManager</span> <span class=n>Audio</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>CharacterManager</span> <span class=n>Characters</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Several dozen other managers here.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>You want to play a sound effect, so you need to access <code>Managers::Audio</code>. So you include <code>Managers.h</code>. But now you&rsquo;ve inadvertently also included ALL those other headers! This is nearly invisible, but over time, you suddenly have every .cpp file including virtually every header.</p><h2 id=the-best-way>The Best Way?</h2><p>As hinted earlier, I wouldn&rsquo;t be so bold as to proclaim any method &ldquo;the best.&rdquo; However, here are a few thoughts and parting advice.</p><h3 id=global-variables-are-simple-and-effective>Global Variables are Simple and Effective&mldr;</h3><p>It is clearly quite easy to access the manager. Use a global variable with a unique name to avoid naming clashes. Include the header for the manager, and you&rsquo;ve got access to it.</p><p>Such global variables are allocated on program start. Use the Init/Shutdown approach to explicitly define initialization and shutdown orders; this is clearer for understanding how the game works anyway.</p><p>The manager is globally accessible, you are still able to use inheritance, and you aren&rsquo;t limited to only creating a single instance. If you later need a local or secondary instance of the manager, you can easily do so.</p><p>You also don&rsquo;t really have the header problem described above. The header for each manager also declares the manager&rsquo;s access point. If you need to play an audio file, you just include <code>AudioManager.h</code>. The class dependencies are quite clear by looking at the headers.</p><p>If this choice seems obvious, I must emphasize that my introduction to coding was filled with &ldquo;globals are evil&rdquo; tips. Maybe they still are and I&rsquo;ve just been swayed to the dark side. For certain hyper-complex projects, globals may be extremely problematic. Maybe I&rsquo;ll look back on this post in the future and think &ldquo;wow I was dumb.&rdquo; But for now, they are simple and elegant and do the job well.</p><h3 id=unless-you-want-elegant-game-reinitialization>&mldr;Unless You Want Elegant Game Reinitialization!</h3><p>One spot where globals can be problematic is when you need to reinitialize the engine, or a part of the engine, at runtime.</p><p>Take implementing save games for example: when a save is loaded, it can be most elegant and straightforward to simply destruct the current game instance and create a new game instance. If all the classes (including managers) pertaining to game state are inside a single object, you can just delete that object and recreate it.</p><p>If you do use globals, there are a few ways to work around this, if you need to recreate certain global instances under certain circumstances:</p><ol><li><p>There&rsquo;s nothing saying you can overwrite globals with a new instance, such as <code>gMyGlobal = MyGlobal();</code>. Just be careful that the global is able to safely destruct itself and reconstruct itself correctly.</p></li><li><p>Move globals that are relevant for reinitialization at runtime to use the &ldquo;Single Global Instance&rdquo; approach. This then allows you to shutdown and reinit the single global instance instead of many globals.</p></li></ol><div class=blog-tags><a href=https://clarkkromenaker.com//tags/c++/>C++</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://clarkkromenaker.com/post/library-dynamic-loading-mac/ data-toggle=tooltip data-placement=top title="Loading Dynamic Libraries on Mac">&larr; Previous Post</a></li><li class=next><a href=https://clarkkromenaker.com/post/cpp-cstrings/ data-toggle=tooltip data-placement=top title="C-Strings in C++">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2025</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://clarkkromenaker.com/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>