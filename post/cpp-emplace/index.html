<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Insert, Push, and Emplace - Clark Kromenaker</title>
<meta name=description content="Standard C++ containers (or collections) are essential tools. Some, like vector, queue, deque, and stack are list-like: elements are accessed by position. Others, such as map or set, are more associative in nature: elements are accessed by a key.
To add an object to a vector, you can call insert or push_back. Stacks and queues both allow you to add elements using push. Map allows insertions with insert or using the [ ] operator.
In C++11 and beyond, all these containers have new functions that seem to behave similarly to the above methods: emplace, emplace_back, and emplace_front.
Which begs the question: what&rsquo;s the difference between these different methods of adding items to collections?"><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/clarkkromenaker.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/clarkkromenaker.com\/post\/cpp-emplace\/","name":"Insert, push, and emplace"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"Insert, Push, and Emplace","description":"Standard C\u002b\u002b containers (or collections) are essential tools. Some, like vector, queue, deque, and stack are list-like: elements are accessed by position. Others, such as map or set, are more associative in nature: elements are accessed by a key.\nTo add an object to a vector, you can call insert or push_back. Stacks and queues both allow you to add elements using push. Map allows insertions with insert or using the [ ] operator.\nIn C\u002b\u002b11 and beyond, all these containers have new functions that seem to behave similarly to the above methods: emplace, emplace_back, and emplace_front.\nWhich begs the question: what\u0026rsquo;s the difference between these different methods of adding items to collections?\n","inLanguage":"en","wordCount":1389,"datePublished":"2018-10-14T00:00:00","dateModified":"2018-10-14T00:00:00","image":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","keywords":["C\u002b\u002b"],"mainEntityOfPage":"https:\/\/clarkkromenaker.com\/post\/cpp-emplace\/","publisher":{"@type":"Organization","name":"https:\/\/clarkkromenaker.com\/","logo":{"@type":"ImageObject","url":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="Insert, Push, and Emplace"><meta property="og:description" content="Standard C++ containers (or collections) are essential tools. Some, like vector, queue, deque, and stack are list-like: elements are accessed by position. Others, such as map or set, are more associative in nature: elements are accessed by a key.
To add an object to a vector, you can call insert or push_back. Stacks and queues both allow you to add elements using push. Map allows insertions with insert or using the [ ] operator.
In C++11 and beyond, all these containers have new functions that seem to behave similarly to the above methods: emplace, emplace_back, and emplace_front.
Which begs the question: what&rsquo;s the difference between these different methods of adding items to collections?"><meta property="og:image" content="https://clarkkromenaker.com/img/avatar-icon.png"><meta property="og:url" content="https://clarkkromenaker.com/post/cpp-emplace/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="Insert, Push, and Emplace"><meta name=twitter:description content="Standard C++ containers (or collections) are essential tools. Some, like vector, queue, deque, and stack are list-like: elements are accessed by position. Others, such as map or set, are more â€¦"><meta name=twitter:image content="https://clarkkromenaker.com/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://clarkkromenaker.com/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://clarkkromenaker.com/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://clarkkromenaker.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://clarkkromenaker.com/css/syntax.css><link rel=stylesheet href=https://clarkkromenaker.com/css/codeblock.css><link rel=stylesheet href=https://clarkkromenaker.com//css/portfolio.css><link rel=stylesheet href=https://clarkkromenaker.com//css/misc.css><link rel=stylesheet href=https://clarkkromenaker.com//css/overrides.css><script src=https://clarkkromenaker.com//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://clarkkromenaker.com/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://clarkkromenaker.com/><img class=avatar-img src=https://clarkkromenaker.com/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Insert, Push, and Emplace</h1><span class=post-meta><i class=fas></i>Posted on October 14, 2018</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>Standard C++ containers (or collections) are essential tools. Some, like vector, queue, deque, and stack are list-like: elements are accessed by position. Others, such as map or set, are more associative in nature: elements are accessed by a key.</p><p>To add an object to a vector, you can call <strong>insert</strong> or <strong>push_back</strong>. Stacks and queues both allow you to add elements using <strong>push</strong>. Map allows insertions with <strong>insert</strong> or using the <strong>[ ] operator</strong>.</p><p>In C++11 and beyond, all these containers have new functions that seem to behave similarly to the above methods: <strong>emplace</strong>, <strong>emplace_back</strong>, and <strong>emplace_front</strong>.</p><p>Which begs the question: what&rsquo;s the difference between these different methods of adding items to collections?</p><h1 id=the-terminology>The Terminology</h1><p>The definitions for &ldquo;push&rdquo; and &ldquo;emplace&rdquo; are fairly ambiguous, but they do have fairly consistent meanings we can derive. &ldquo;Insert&rdquo; already has a pretty clear meaning, but we&rsquo;ll discuss it for completeness.</p><h2 id=push>Push</h2><p>&ldquo;Pushing&rdquo; in programming usually means &ldquo;to add to&rdquo; or &ldquo;to append to&rdquo;.</p><p>Containers like queue and stack only allow adding elements at one spot (either at the end of the queue or top of the stack), so they only have a single <strong>push</strong> method. Deque (double-ended queue) allows adding elements onto either end, so it has <strong>push_front</strong> and <strong>push_back</strong>. Vector can only efficiently add elements to the end, so <strong>push_back</strong> is provided.</p><p>In all those cases, &ldquo;push&rdquo; means to either add an item to the front or back of a list of existing items.</p><h2 id=insert>Insert</h2><p>You&rsquo;ll notice that any time you can add an item in the middle of a list, the term is instead &ldquo;insert&rdquo;. This is the case for vector, which allows adding items at any index, and map/unordered_map, which structurally don&rsquo;t really have concepts of &ldquo;front&rdquo; or &ldquo;back&rdquo;.</p><p>&ldquo;Insert&rdquo; means to add an item in the middle of a list of items, or to add an item to a collection that is not really list-like.</p><h2 id=emplace>Emplace</h2><p>The definition of emplace is &ldquo;to put into place.&rdquo; Within the context of C++ containers, the definition seems to be &ldquo;to construct in place&rdquo;.</p><p>Reviewing the C++ containers, you&rsquo;ll notice a pattern emerge:</p><ul><li>Any container with <strong>insert</strong> will have an <strong>emplace</strong> as well.</li><li>Any container with <strong>push_front</strong> will have an <strong>emplace_front</strong> as well.</li><li>Any container with <strong>push_back</strong> will have an <strong>emplace_back</strong> as well.</li></ul><p>I believe the difference meant to be conveyed between &ldquo;push/insert&rdquo; and &ldquo;emplace&rdquo; is the difference between &ldquo;moving an object to a location&rdquo; and &ldquo;constructing an object at a location.&rdquo;</p><p>Let&rsquo;s dig deeper into the distinction between those two ideas with a real-world analogy!</p><h1 id=copy-move-or-construct>Copy, Move, or Construct</h1><p>Imagine a scenario where you are contracted to build a roller coaster at a theme park. There are three strategies you might choose from:</p><ol><li>Construct the roller coaster at a testing facility. Once happy with the roller coaster, build an exact copy of it at the theme park.</li><li>Construct the roller coaster at a testing facility. Once happy with the roller coaster, move it from the testing facility to the theme park.</li><li>Construct the roller coaster at the theme park.</li></ol><p>Any real-life company would certainly go out of business if they chose options 1 or 2. Building an exact copy is a waste of time and resources. Moving doesn&rsquo;t duplicate the coaster, but the transportation aspect could be costly. In reality, once a design was decided upon, you&rsquo;d just construct the coaster at the desired final location.</p><h2 id=what-about-c-again>What About C++ Again?</h2><p>In C++, options 1 or 2 are commonly used. When you set two objects equal to one another, the values from one object are either copied to the other, or moved in some circumstances. You could imagine, when this applies to very large objects, that it could be quite expensive.</p><p>For example, let&rsquo;s say you create an object and push it onto the end of a vector:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MyObj</span> <span class=nf>obj</span><span class=p>(</span><span class=s>&#34;test&#34;</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>   <span class=c1>// Construct object on stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>myVector</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>  <span class=c1>// Push onto back of vector.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The object is constructed on the stack as a local variable. When you push the object onto the vector, one of two things will happen:</p><ol><li>A new instance of <code>MyObj</code> is allocated at the end of the vector and the data from <code>obj</code> is <em>copied</em> to the new instance.</li><li>A new instance of <code>MyObj</code> is allocated at the end of the vector and the data from <code>obj</code> is <em>moved</em> to the new instance.</li></ol><h2 id=copying-vs-moving>Copying vs. Moving</h2><p>Before C++11, the language syntax only supported copying: the concept of a <strong>copy constructor</strong> was used for this. When you assigned one object to another, the copy constructor was used. When you <strong>copy</strong> an object, both the original object and its copy are usable.</p><p>In C++11, &ldquo;moving&rdquo; data was introduced, along with the <strong>move constructor</strong>. When you <strong>move</strong> an object, the moved-to instance is usable, but the moved-from instance is no longer usable. Moving is generally said to be more efficient, but it leaves the moved-from instance in an &ldquo;unspecified&rdquo; state.</p><p>Imagine an object that contains a lot of data. Creating a copy could be quite costly because memory has to be allocated to hold a copy of the data, and then the data itself must be copied from one memory location to another. When you <em>move</em>, however, a new instance of the object is still created, but that new instance just &ldquo;takes over&rdquo; control of the data the old instance used. The old instance isn&rsquo;t usable anymore, since it gave all its data to the new instance.</p><p>How is it decided whether to copy or move? You want to copy an object if you intend to continue using the copied-from object as a distinct, separate entity. You can move an object if the moved-from object will no longer be used. Sometimes, the compiler knows this without you telling it; other times, you have to tell the compiler explicitly (using <code>std::move</code>).</p><h1 id=back-to-emplacing>Back to Emplacing&mldr;</h1><p>So, &ldquo;insert&rdquo; and &ldquo;push&rdquo; both take an existing object and either copy it into the container or move it into the container. However, as with our roller coaster example: why copy or move when you can just build it at the final spot in the first place?</p><p>This is <strong>the key</strong> to emplacement: rather than copying or moving a <em>pre-existing</em> object into a container, we will instead provide the appropriate constructor arguments to allow the container to allocate and construct the object in the container&rsquo;s memory directly.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MyObj</span> <span class=nf>obj</span><span class=p>(</span><span class=s>&#34;test&#34;</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>myVector</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span> <span class=c1>// Copy or move construct.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>myVector</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=s>&#34;test&#34;</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span> <span class=c1>// Pass constructor arguments directly.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>myVector</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span> <span class=c1>// This also works - why?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Emplacement allows us to allocate a piece of memory and construct our object directly at that location in memory. We can avoid any temporary object creation or unnecessary copy/move operations.</p><p>Note that last line: <code>emplace_back(obj)</code>. Why does that work? The reason is: we <em>are</em> providing valid constructor arguments! But in that case, we are just invoking the copy constructor. As a result, the performance benefits of emplacement are somewhat defeated - you probably get the same performance as <code>push_back</code>.</p><p>There will be times where you already have an instance of an object, and so &ldquo;push&rdquo; or &ldquo;insert&rdquo; are fine options. Emplace is most useful when you have to construct a new object instance <em>just</em> so you can pass it to the container. Instead, you can let the container construct the object for you, and already in the container&rsquo;s memory as a bonus.</p><h1 id=issues-with-emplacement>Issues with Emplacement</h1><p>It&rsquo;s worth noting that any performance gains from using &ldquo;emplace&rdquo; over &ldquo;push&rdquo; will likely be minimal unless the container is holding very large objects. Emplacing vs. pushing <code>int</code> should not be something you are concerned about. Only when larger objects lead to performance concerns is it worth thinking about.</p><p>Some have also pointed out that emplacement can cause readability issues. Take the following code snippet:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>cities</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=s>&#34;Los Angeles&#34;</span><span class=p>,</span> <span class=s>&#34;California&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>What kind of object is the &ldquo;cities&rdquo; collection holding? It&rsquo;s a bit unclear. The name of the vector itself provides a clue that it might contain objects of type <code>City</code>&mldr;but a less helpfully named variable would make it even harder to parse. And I guess the <code>City</code> class has a constructor that takes <code>(string name, string state)</code>? You hope so!</p><p>Arguably, the readability is better with something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>::</span><span class=n>Bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>City</span> <span class=nf>losAngeles</span><span class=p>(</span><span class=s>&#34;Los Angeles&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>losAngeles</span><span class=p>.</span><span class=n>SetState</span><span class=p>(</span><span class=s>&#34;California&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>cities</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>losAngeles</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>But that&rsquo;s for you to judge!</p><div class=blog-tags><a href=https://clarkkromenaker.com//tags/c++/>C++</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://clarkkromenaker.com/post/unity-monobehaviour-usage/ data-toggle=tooltip data-placement=top title="When to Inherit from MonoBehaviour">&larr; Previous Post</a></li><li class=next><a href=https://clarkkromenaker.com/post/gengine-01-introduction/ data-toggle=tooltip data-placement=top title="G-Engine #1: Introduction">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2024</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://clarkkromenaker.com/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>