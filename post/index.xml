<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Clark Kromenaker</title><link>https://clarkkromenaker.com/post/</link><description>Recent content in Posts on Clark Kromenaker</description><generator>Hugo</generator><language>en-us</language><managingEditor>kromenak@gmail.com (Clark Kromenaker)</managingEditor><webMaster>kromenak@gmail.com (Clark Kromenaker)</webMaster><lastBuildDate>Sun, 05 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://clarkkromenaker.com/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Optimizing Texture Loads in G-Engine</title><link>https://clarkkromenaker.com/post/gfx-texture-loading/</link><pubDate>Sun, 05 Oct 2025 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gfx-texture-loading/</guid><description>&lt;p>The texture loading code for 
&lt;a href="https://github.com/kromenak/gengine" target="_blank">G-Engine&lt;/a> was written early in development, when I was eager to see some on-screen graphics to demonstrate tangible progress on the project. And then that code stayed relatively untouched for years. However, a 
&lt;a href="https://github.com/kromenak/gengine/issues/27" target="_blank">recent GitHub issue&lt;/a> highlighted a bottleneck - installing a mod containing very large textures caused scene load times to skyrocket!&lt;/p>
&lt;p>In this post, I&amp;rsquo;ll explain how this problem was investigated and fixed. It may be a helpful read if you want to learn more about loading image data to be used by a graphics API such as OpenGL, or if you want to see how naive texture loading code can be improved.&lt;/p></description></item><item><title>Loading Shared Libraries on Linux</title><link>https://clarkkromenaker.com/post/library-dynamic-loading-linux/</link><pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/library-dynamic-loading-linux/</guid><description>&lt;p>About three years ago, I wrote 
&lt;a href="https://clarkkromenaker.com/post/library-dynamic-loading-mac">a post&lt;/a> about wrangling dynamic libraries for Mac applications. I recently faced the same challenge on Linux, so I figured I&amp;rsquo;d write a follow up.&lt;/p>
&lt;p>If you&amp;rsquo;re new to dealing with dynamic libraries, I&amp;rsquo;d recommend reviewing the previous post first - it covers some fundamentals that I won&amp;rsquo;t rehash here. Linux and Mac handle dynamic libraries in similar ways - but as you might guess, the tools used and some details vary.&lt;/p></description></item><item><title>Building a Simple &amp; Affordable Website</title><link>https://clarkkromenaker.com/post/web-building-and-hosting/</link><pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/web-building-and-hosting/</guid><description>&lt;p>Website development is not exactly my forte. Though I&amp;rsquo;ve dabbled over the years, I spend most of my time in C++, C#, and Java. Despite this, it&amp;rsquo;s fun and helpful to run a blog and portfolio site (the very one you&amp;rsquo;re reading), so I need to know a little bit about websites!&lt;/p>
&lt;p>Over the years, I&amp;rsquo;ve tried a few different approaches to building and hosting this website before landing on what you see before you. This site is simple, easy to maintain, fast to load, secure, and (importantly) inexpensive to host.&lt;/p>
&lt;p>In this post, I&amp;rsquo;ll explain the approaches I&amp;rsquo;ve tried in the past and how this site is currently built.&lt;/p></description></item><item><title>Reading to EOF</title><link>https://clarkkromenaker.com/post/cpp-eof/</link><pubDate>Sat, 15 Apr 2023 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/cpp-eof/</guid><description>&lt;p>Here&amp;rsquo;s a simple programming task: read everything from a file into memory. To do this, you need to open the file, read the data, and stop reading when you reach the end of the file (abbreviated &amp;ldquo;EOF&amp;rdquo;).&lt;/p>
&lt;p>But how do you KNOW you&amp;rsquo;ve reached the end of a file? That&amp;rsquo;s a simple question with a slightly complex/misleading answer.&lt;/p></description></item><item><title>C-Strings in C++</title><link>https://clarkkromenaker.com/post/cpp-cstrings/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/cpp-cstrings/</guid><description>&lt;p>Strings in C are simply arrays of &lt;code>char&lt;/code> values - or in other words, a contiguous block of memory containing &lt;code>chars&lt;/code>. C++ inherits that representation, but also provides a safer and easier-to-use option called &lt;code>std::string&lt;/code>. In C++, the old C-style strings are often called &lt;strong>C-Strings&lt;/strong>.&lt;/p>
&lt;p>Most C++ gurus would advise you to avoid C-Strings and just use &lt;code>std::string&lt;/code>. And it is true that &lt;code>std::string&lt;/code> is safer and easier to use than C-Strings. Whereas &lt;code>std::string&lt;/code> manages memory for you and has a ton of built-in functionality, C-Strings are essentially just blocks of &lt;code>char&lt;/code> memory that you must manipulate with error-prone and inconsistent functions.&lt;/p>
&lt;p>However, avoiding C-Strings entirely is difficult - sometimes you inherit code that&amp;rsquo;s using them, sometimes SDKs or libraries require you to use them, sometimes they are the most efficient option.&lt;/p>
&lt;p>C-Strings can be confusing to work with. There are a variety of functions used to manipulate C-Strings, but some are deprecated or insecure, some are only available in certain compilers, and some have intricate ins and outs for using them properly.&lt;/p>
&lt;p>So, my goal with this post is to catalogue some common operations you&amp;rsquo;d want to perform on C-Strings and identify the best options available, what to avoid, and what pitfalls exist.&lt;/p></description></item><item><title>Accessing Managers in C++</title><link>https://clarkkromenaker.com/post/cpp-manager-access/</link><pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/cpp-manager-access/</guid><description>&lt;p>Every game or game engine has at least a few managers under the hood. A manager is a collection of functions and data whose purpose is to &amp;ldquo;manage&amp;rdquo; something. You may send HTTP requests through an &lt;code>HttpManager&lt;/code>. You may track the player&amp;rsquo;s inventory with an &lt;code>InventoryManager&lt;/code>. You may play audio through an &lt;code>AudioManager&lt;/code>. And so on.&lt;/p>
&lt;p>How you access a manager is a seemingly mundane decision that can be surprisingly complex and paralyzing. Do you pass the manager as a function parameter? Use a global variable? Make a bunch of static functions or a namespace? Devise more elaborate mechanisms? Each option has pros and cons, and personal preference comes into play as well. Changing your mind later can incur significant refactoring overhead.&lt;/p>
&lt;p>I&amp;rsquo;ve been coding games for about a decade now, so I&amp;rsquo;ve developed some opinions and ideas on this subject. I don&amp;rsquo;t think there&amp;rsquo;s a &amp;ldquo;best&amp;rdquo; or &amp;ldquo;right&amp;rdquo; way to do this, but there are a few ways to consider that might be useful in varying contexts.&lt;/p>
&lt;p>Below, I&amp;rsquo;ll review several access options along with some pros/cons of each.&lt;/p></description></item><item><title>Loading Dynamic Libraries on Mac</title><link>https://clarkkromenaker.com/post/library-dynamic-loading-mac/</link><pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/library-dynamic-loading-mac/</guid><description>&lt;p>G-Engine uses various third-party libraries: ffmpeg for video playback, fmod for audio playback, zlib for decompression, etc. In all these cases, the library is included as a &amp;ldquo;dynamic library&amp;rdquo; (as opposed to a &amp;ldquo;static library&amp;rdquo;).&lt;/p>
&lt;p>On Windows, when an executable needs a dynamic library, it searches for it in a few predefined locations, such as &amp;ldquo;the same directory as the executable&amp;rdquo;. On Mac and Linux, however, the situation is different and requires some consideration and explanation.&lt;/p>
&lt;p>I was recently learning how macOS loads dynamic libraries, and it is not as intuitive or well documented as you might hope. This post attempts to lay things out in a clear and easy to digest way.&lt;/p></description></item><item><title>G-Engine #9: Quaternions</title><link>https://clarkkromenaker.com/post/gengine-09-quaternions/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-09-quaternions/</guid><description>&lt;p>Way back in 
&lt;a href="https://clarkkromenaker.com/post/gengine-04-rendering">G-Engine #4&lt;/a>, we rendered a triangle, and there was much rejoicing. Since then, the posts in this series have primarily focused on implementing mathematical constructs in code. This point is the final math pre-requisite before we can move on to more interesting things.&lt;/p>
&lt;p>Think of a game engine as its own little universe: at first, there is nothing - the void. Concepts such as time, position, and orientation don&amp;rsquo;t exist yet. Suddenly, the game loop and delta time introduces the concept of time. With vectors, we can convey positions, directions, and distances. Slowly, our universe takes shape and we can convey important concepts in code.&lt;/p>
&lt;p>But what about rotations? Vectors can store position, direction, and scale data, but they are not effective structures for 3D rotations. We need some other option to convey rotations in code.&lt;/p>
&lt;p>One structure that is very effective for 3D rotations is the &lt;strong>Quaternion&lt;/strong>. Much-maligned for their apparent complexity, Quaternions allow us to efficiently store and use 3D rotation data. In this post, we&amp;rsquo;ll explore why we use quaternions, what they are, how to perform common operations with them, and finally I&amp;rsquo;ll provide some tips for writing your own &lt;code>Quaternion&lt;/code> class.&lt;/p></description></item><item><title>G-Engine #8: Matrices</title><link>https://clarkkromenaker.com/post/gengine-08-matrices/</link><pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-08-matrices/</guid><description>&lt;p>Matrices are vital tools for 3D rendering. Graphics libraries expect you to use matrices to represent positions, rotations, and scales of 3D objects. Furthermore, matrices provide a convenient/effective mechanism for representing hierarchies of 3D objects and coordinate systems.&lt;/p>
&lt;p>This post will briefly explain what matrices are, explain commonly used operations for 3D game development, and provide tips for writing matrix classes for your game engine.&lt;/p></description></item><item><title>G-Engine #7: Vectors</title><link>https://clarkkromenaker.com/post/gengine-07-vectors/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-07-vectors/</guid><description>&lt;p>We have added a basic math library to the 3D engine, but we&amp;rsquo;re still missing several fundamental mathematical building blocks to move forward and build full-fledged 3D environments. In particular, I want to implement Vectors, Matrices, and Quaternions. This post will cover &lt;strong>Vectors&lt;/strong>, which enable the engine to represent important spacial concepts such as &amp;ldquo;position&amp;rdquo; and &amp;ldquo;direction&amp;rdquo;.&lt;/p></description></item><item><title>G-Engine #6: Math Library</title><link>https://clarkkromenaker.com/post/gengine-06-math/</link><pubDate>Wed, 27 Nov 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-06-math/</guid><description>&lt;p>After my post about 
&lt;a href="https://clarkkromenaker.com/post/gengine-04-rendering">rendering basics&lt;/a>, I had a fairly underwhelming final result: a single triangle being rendered in 3D. But it&amp;rsquo;s progress! My next goals are to do two seemingly simple things: move the virtual &amp;ldquo;camera&amp;rdquo; around my 3D environment to view the triangle from different perspectives, and move the triangle itself to different locations in 3D space.&lt;/p>
&lt;p>If we were just writing some graphics library sample code, achieving those two goals would not be too tricky: we could just use some OpenGL convenience methods and objects that provide the math needed. However, if our goal is to build a full game engine, it is better to create our own mathematical constructs that lay the groundwork for 3D world features we&amp;rsquo;ll want in the future, such as translation/rotation/scaling of objects, and parenting.&lt;/p>
&lt;p>One of the first things I need to address is my lack of math library. This post will explore a basic useful math library for a 3D game engine. Future posts will build upon this math library core to add support for 3D vector math, matrices, quaternions, and more!&lt;/p></description></item><item><title>G-Engine #5: GK3 Assets Overview</title><link>https://clarkkromenaker.com/post/gengine-05-asset-types/</link><pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-05-asset-types/</guid><description>&lt;p>Previous posts in this series have focused on the technical aspects of getting the G-Engine up and running. For this post, I&amp;rsquo;m going to take a short break from writing engine code to instead analyze how GK3 is built. It&amp;rsquo;ll be important to understand this as I move forward and try to recreate it.&lt;/p>
&lt;p>As a data-driven game, GK3 makes heavy use of various custom data and file formats. I&amp;rsquo;ll refer to each piece of data as an &lt;strong>asset&lt;/strong>.&lt;/p>
&lt;p>A key challenge in this project is understanding what the different asset types are, how they relate to one another, how to parse and load them into memory, and how to make use of them at runtime in a meaningful way. The developers would have documented all this, but much of that is unavailable to me - time for some detective work!&lt;/p>
&lt;p>This post focuses on those first two questions: what are the different asset types, and how do they relate to one another? We&amp;rsquo;ll take a look at the various assets, what they do, and the web of relationships between them.&lt;/p></description></item><item><title>Saving Memory with C# Structs</title><link>https://clarkkromenaker.com/post/csharp-structs/</link><pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/csharp-structs/</guid><description>&lt;p>In C++, there&amp;rsquo;s little difference between &lt;code>class&lt;/code> and &lt;code>struct&lt;/code>: a &lt;code>class&lt;/code> defaults to &amp;ldquo;private&amp;rdquo; access and a &lt;code>struct&lt;/code> defaults to &amp;ldquo;public&amp;rdquo; access. There are no other &lt;em>technical&lt;/em> differences between the two, though structs are often used for small and simple data types.&lt;/p>
&lt;p>C# mimics the syntax of C++ to some degree and also provides &lt;code>class&lt;/code> and &lt;code>struct&lt;/code>. However, in this case, the technical difference is quite large! In this post, I&amp;rsquo;ll briefly explain that difference and highlight a scenario where using a &lt;code>struct&lt;/code> saved a lot of memory on a project I worked on.&lt;/p></description></item><item><title>G-Engine #4: Basic 3D Rendering</title><link>https://clarkkromenaker.com/post/gengine-04-rendering/</link><pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-04-rendering/</guid><description>&lt;p>In the last G-Engine post, we got the game loop and frame &amp;ldquo;delta time&amp;rdquo; calculations working. We&amp;rsquo;ve now got a blank, empty game window - yay? Despite the unimpressive result, we&amp;rsquo;ve got a beating heart under the hood: an update loop being called at roughly 60 frames per second.&lt;/p>
&lt;p>Empty windows are no fun, so my next goal is to get something - anything - rendering in the game window. Graphics are a vital and exciting part of any game, and rendering provides us vital visual feedback as we move on to implementing and debugging 3D object placement, cameras, rotations, and data loading for 3D meshes and animations.&lt;/p>
&lt;p>This post will focus on rendering a single triangle on screen. Though the result is simple, we&amp;rsquo;ll cover a lot of ground towards building a 3D rendering system that will be extended and enhanced as we move forward.&lt;/p></description></item><item><title>G-Engine #3: Game Loop</title><link>https://clarkkromenaker.com/post/gengine-03-game-loop/</link><pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-03-game-loop/</guid><description>&lt;p>In my last G-Engine post, I did some setup work and finally got a basic OS window appearing that could be moved around, minimized/maximized, and closed. Good start!&lt;/p>
&lt;p>In this post, we&amp;rsquo;ll do a bit more planning, and then we&amp;rsquo;ll structure our code into a high-level class (&lt;code>GEngine&lt;/code>) that&amp;rsquo;ll be more conducive to building an engine than just shoving everything into the &lt;code>main&lt;/code> function. We&amp;rsquo;ll also implement our &amp;ldquo;delta time&amp;rdquo; calculations, which will be critical for updating the state of our game as we move forward.&lt;/p></description></item><item><title>G-Engine #2: Project Setup</title><link>https://clarkkromenaker.com/post/gengine-02-setup/</link><pubDate>Sat, 27 Oct 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-02-setup/</guid><description>&lt;p>The previous post introduced the G-Engine project. So here we are, ready to build a 3D game engine! This post walks through some early decisions, starting from absolutely nothing to having just an empty application window that can be moved around and closed.&lt;/p>
&lt;p>This is not the most exciting end result, but there are plenty of important decisions to be made before we dig into actually writing game engine code.&lt;/p></description></item><item><title>G-Engine #1: Introduction</title><link>https://clarkkromenaker.com/post/gengine-01-introduction/</link><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/gengine-01-introduction/</guid><description>&lt;p>I&amp;rsquo;ve always wanted to write a game engine. But building a game engine without a game can be difficult to do! The needs of the game drive the engine&amp;rsquo;s features. Plus, without art assets, how do you show off the engine&amp;rsquo;s features?&lt;/p>
&lt;p>To get around this problem, I thought it&amp;rsquo;d be cool to build a game engine that&amp;rsquo;s capable of running a game that I played and thoroughly enjoyed when I was in my teens: &lt;em>Gabriel Knight 3: Blood of the Sacred, Blood of the Damned&lt;/em>. In late 2017, I took the dive and started working on it!&lt;/p>
&lt;p>This post (and those following it) document my progress. In this introductory post, I&amp;rsquo;ll explain what &lt;em>Gabriel Knight&lt;/em> is, why I&amp;rsquo;m excited about it, and what I hope to accomplish.&lt;/p></description></item><item><title>Insert, Push, and Emplace</title><link>https://clarkkromenaker.com/post/cpp-emplace/</link><pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/cpp-emplace/</guid><description>&lt;p>Standard C++ containers (or collections) are essential tools. Some, like vector, queue, deque, and stack are list-like: elements are accessed by position. Others, such as map or set, are more associative in nature: elements are accessed by a key.&lt;/p>
&lt;p>To add an object to a vector, you can call &lt;strong>insert&lt;/strong> or &lt;strong>push_back&lt;/strong>. Stacks and queues both allow you to add elements using &lt;strong>push&lt;/strong>. Map allows insertions with &lt;strong>insert&lt;/strong> or using the &lt;strong>[ ] operator&lt;/strong>.&lt;/p>
&lt;p>In C++11 and beyond, all these containers have new functions that seem to behave similarly to the above methods: &lt;strong>emplace&lt;/strong>, &lt;strong>emplace_back&lt;/strong>, and &lt;strong>emplace_front&lt;/strong>.&lt;/p>
&lt;p>Which begs the question: what&amp;rsquo;s the difference between these different methods of adding items to collections?&lt;/p></description></item><item><title>When to Inherit from MonoBehaviour</title><link>https://clarkkromenaker.com/post/unity-monobehaviour-usage/</link><pubDate>Thu, 14 Mar 2013 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/unity-monobehaviour-usage/</guid><description>&lt;p>When you create a new C# class in Unity, it automatically inherits from the &lt;code>MonoBehaviour&lt;/code> class, which is Unity&amp;rsquo;s base class for components. In Unity, you tend to create a lot of components, but it&amp;rsquo;s important to keep in mind that you don&amp;rsquo;t &lt;em>have to&lt;/em>.&lt;/p>
&lt;p>When I was new to Unity, I thought everything should inherit from &lt;code>MonoBehaviour&lt;/code> - that&amp;rsquo;s just how you work in Unity! Some of my students have also had this misconception. In fact, there are often scenarios where it makes more sense to not inherit at all, or to inherit from another base class. This post explains situations where it makes sense to use MonoBehaviour, and some cases where you&amp;rsquo;d be better off without it.&lt;/p></description></item><item><title>Encapsulate Unity Inspector Variables</title><link>https://clarkkromenaker.com/post/unity-inspector-variables/</link><pubDate>Sat, 18 Aug 2012 00:00:00 +0000</pubDate><author>kromenak@gmail.com (Clark Kromenaker)</author><guid>https://clarkkromenaker.com/post/unity-inspector-variables/</guid><description>&lt;p>When writing a Unity component, it&amp;rsquo;s likely that you&amp;rsquo;ll want to expose some variables in the Unity Editor&amp;rsquo;s Inspector, so that either you or a designer can modify those values without having to recompile the script. However, the default method of exposing variables in the inspector can break class encapsulation in an undesirable way. This post explores ways to expose variables in the Inspector without sacrificing your class&amp;rsquo;s encapsulation.&lt;/p></description></item></channel></rss>