<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>G-Engine #4: Basic 3D Rendering - Clark Kromenaker</title>
<meta name=description content="In the last G-Engine post, we got the game loop and frame &ldquo;delta time&rdquo; calculations working. We&rsquo;ve now got a blank, empty game window - yay? Despite the unimpressive result, we&rsquo;ve got a beating heart under the hood: an update loop being called at roughly 60 frames per second.
Empty windows are no fun, so my next goal is to get something - anything - rendering in the game window. Graphics are a vital and exciting part of any game, and rendering provides us vital visual feedback as we move on to implementing and debugging 3D object placement, cameras, rotations, and data loading for 3D meshes and animations.
This post will focus on rendering a single triangle on screen. Though the result is simple, we&rsquo;ll cover a lot of ground towards building a 3D rendering system that will be extended and enhanced as we move forward."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/clarkkromenaker.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/clarkkromenaker.com\/post\/gengine-04-rendering\/","name":"G engine #4 basic 3 d rendering"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"G-Engine #4: Basic 3D Rendering","description":"In the last G-Engine post, we got the game loop and frame \u0026ldquo;delta time\u0026rdquo; calculations working. We\u0026rsquo;ve now got a blank, empty game window - yay? Despite the unimpressive result, we\u0026rsquo;ve got a beating heart under the hood: an update loop being called at roughly 60 frames per second.\nEmpty windows are no fun, so my next goal is to get something - anything - rendering in the game window. Graphics are a vital and exciting part of any game, and rendering provides us vital visual feedback as we move on to implementing and debugging 3D object placement, cameras, rotations, and data loading for 3D meshes and animations.\nThis post will focus on rendering a single triangle on screen. Though the result is simple, we\u0026rsquo;ll cover a lot of ground towards building a 3D rendering system that will be extended and enhanced as we move forward.\n","inLanguage":"en","wordCount":6404,"datePublished":"2019-03-03T00:00:00","dateModified":"2019-03-03T00:00:00","image":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","keywords":["G-Engine, C\u002b\u002b, OpenGL"],"mainEntityOfPage":"https:\/\/clarkkromenaker.com\/post\/gengine-04-rendering\/","publisher":{"@type":"Organization","name":"https:\/\/clarkkromenaker.com\/","logo":{"@type":"ImageObject","url":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="G-Engine #4: Basic 3D Rendering"><meta property="og:description" content="In the last G-Engine post, we got the game loop and frame &ldquo;delta time&rdquo; calculations working. We&rsquo;ve now got a blank, empty game window - yay? Despite the unimpressive result, we&rsquo;ve got a beating heart under the hood: an update loop being called at roughly 60 frames per second.
Empty windows are no fun, so my next goal is to get something - anything - rendering in the game window. Graphics are a vital and exciting part of any game, and rendering provides us vital visual feedback as we move on to implementing and debugging 3D object placement, cameras, rotations, and data loading for 3D meshes and animations.
This post will focus on rendering a single triangle on screen. Though the result is simple, we&rsquo;ll cover a lot of ground towards building a 3D rendering system that will be extended and enhanced as we move forward."><meta property="og:image" content="https://clarkkromenaker.com/img/avatar-icon.png"><meta property="og:url" content="https://clarkkromenaker.com/post/gengine-04-rendering/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="G-Engine #4: Basic 3D Rendering"><meta name=twitter:description content="In the last G-Engine post, we got the game loop and frame &ldquo;delta time&rdquo; calculations working. We&rsquo;ve now got a blank, empty game window - yay? Despite the unimpressive result, â€¦"><meta name=twitter:image content="https://clarkkromenaker.com/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://clarkkromenaker.com/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://clarkkromenaker.com/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://clarkkromenaker.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://clarkkromenaker.com/css/syntax.css><link rel=stylesheet href=https://clarkkromenaker.com/css/codeblock.css><link rel=stylesheet href=https://clarkkromenaker.com//css/portfolio.css><link rel=stylesheet href=https://clarkkromenaker.com//css/misc.css><link rel=stylesheet href=https://clarkkromenaker.com//css/overrides.css><script src=https://clarkkromenaker.com//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://clarkkromenaker.com/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://clarkkromenaker.com/><img class=avatar-img src=https://clarkkromenaker.com/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>G-Engine #4: Basic 3D Rendering</h1><span class=post-meta><i class=fas></i>Posted on March 3, 2019</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>In the last G-Engine post, we got the game loop and frame &ldquo;delta time&rdquo; calculations working. We&rsquo;ve now got a blank, empty game window - yay? Despite the unimpressive result, we&rsquo;ve got a beating heart under the hood: an update loop being called at roughly 60 frames per second.</p><p>Empty windows are no fun, so my next goal is to get something - anything - rendering in the game window. Graphics are a vital and exciting part of any game, and rendering provides us vital visual feedback as we move on to implementing and debugging 3D object placement, cameras, rotations, and data loading for 3D meshes and animations.</p><p>This post will focus on rendering a single triangle on screen. Though the result is simple, we&rsquo;ll cover a lot of ground towards building a 3D rendering system that will be extended and enhanced as we move forward.</p><h1 id=what-is-rendering>What is Rendering?</h1><p><strong>Rendering</strong> or <strong>drawing</strong> is the act of filling the contents of your computer screen with colors to create images. By displaying many static images in quick succession, we can give the impression of vibrant, animated, living 3D worlds.</p><p>We use a 2D array of color data, called a <strong>color buffer</strong>, to tell the computer screen what colors to display. Applications write to the color buffer, and the monitor displays the contents of the color buffer. Each element in the color buffer is called a <strong>pixel</strong>, and each pixel in the color buffer is made up of red, green, and blue values.</p><p>Games usually render once per frame. But it is also possible (and fairly common) to simulate multiple frames and only render the last one. We won&rsquo;t discuss that here, though.</p><p>A <strong>renderer</strong> is the part of a game or other software that is responsible for rendering every object to screen. Generally, a renderer will iterate over a list of &ldquo;renderable&rdquo; objects and render each one in turn. Rendering occurs by sending &ldquo;draw commands&rdquo; to an underlying <strong>graphics library</strong>, such as OpenGL or DirectX.</p><p>The renderer must tackle several challenges. It may need to deal with rendering both opaque and translucent/transparent objects. Determining the correct order to render multiple objects is also more complicated than it may seem. Performing rendering calculations quickly enough to maintain a 30FPS or even 60FPS frame rate can also be difficult.</p><p>A &ldquo;2D renderer&rdquo; focuses only on rendering 2D objects, like image files (sometimes called <strong>textures</strong>). 2D rendering is relatively simple: we just copy a rectangular region of colors from a texture to a desired rectangular region of the color buffer. Since both the texture and the color buffer consist of pixels, it&rsquo;s simply a matter of copying the pixel data from the source to the destination.</p><h2 id=rendering-in-3d>Rendering in 3D</h2><p>A &ldquo;3D renderer&rdquo; renders <strong>3D objects</strong>, which may also be referred to at various times as <strong>models</strong>, <strong>meshes</strong>, <strong>3D geometry</strong>, or <strong>3D shapes</strong>. The building block for 3D objects is a <strong>vertex</strong>. A vertex can have several <strong>attributes</strong>, such as position, color, or texture coordinates. For our current needs, <strong>position</strong> is most important. In 3D space, a vertex&rsquo;s position is defined using a 3D Cartesian coordinate (x, y, z).</p><p>To render anything meaningful, a 3D object usually needs at least three vertices, which make a single triangle. You can think of a 3D object as a collection of triangles, where each triangle consists of three vertices.</p><p>For example, here&rsquo;s a visualization of a 3D cube object. It consists of 6 faces, where each face consists of two triangles. Each triangle is defined by three vertices (highlighted as red dots). Each vertex has a position in (X, Y, Z) coordinates.</p><p><img src=/img/gengine/3d_object.png#center alt="3D object made up of triangles/vertices"></p><p>It&rsquo;s worth mentioning that 3D objects can be built in other ways (e.g.
<a href=https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline target=_blank>NURBS</a>). You also occasionally see quads (4-sided polygons) being used instead of triangles (3-sided polygons). But for game development, the use of vertices and triangles is extremely common, and it is simplest to start there.</p><p>To render a simple 3D object on screen, we need to know two things:</p><ol><li>What is the &ldquo;shape&rdquo; of the object? This is defined by the positions of the vertices that make up the triangles of the object.</li><li>How do we &ldquo;fill in&rdquo; the surface of the object? This is defined by a <strong>shader program</strong>, which we&rsquo;ll discuss later in this post.</li></ol><p>Another way to think about it is first determining what pixels in the color buffer correspond to the 3D object (based on its shape and position relative to the camera), and then next determining what color each of those pixels should be.</p><h1 id=the-plan>The Plan</h1><p>We will implement a 3D renderer in <strong>OpenGL</strong>. Long term, we&rsquo;d like to support many graphics APIs (such as Direct3D), but for now, we&rsquo;ll focus on just the one. OpenGL has pretty good cross-platform support. SDL also supports OpenGL out of the box, which is convenient.</p><p>We&rsquo;ll also be making use of a library called
<a href=http://glew.sourceforge.net/ target=_blank>GLEW</a>. While not strictly required, GLEW provides access to some OpenGL functions that would otherwise be complicated to access. If we didn&rsquo;t use GLEW, we&rsquo;d have to write boilerplate code to access simple OpenGL functions. GLEW provides us with a header file that exposes such functions.</p><p>This post will walk through the initialization of an SDL application using OpenGL (including the integration of the GLEW library). We then want to render a simple triangle in 3D space, so we&rsquo;ll discuss how to define the vertex data that defines the shape of the object. We&rsquo;ll then explain how you can use a simple <strong>shader program</strong> to &ldquo;fill in&rdquo; the surface of the object with a solid color. And, finally, we&rsquo;ll render the dang thing!</p><p>To summarize, we will need to perform the following steps to render a simple triangle:</p><ol><li>Integrate GLEW</li><li>Initialize OpenGL and GLEW</li><li>Define vertex data</li><li>Load vertex data into OpenGL</li><li>Write vertex and fragment shaders</li><li>Load, compile, and link the vertex and fragment shaders</li><li>Activate the shader program</li><li>Send vertex data to be drawn</li></ol><p>That&rsquo;s actually quite a lot to cover! Let&rsquo;s get to it.</p><h1 id=integrate-glew>Integrate GLEW</h1><p>First, we need to get get our hands on the GLEW library. You can download GLEW as a pre-built library for Windows
<a href=http://glew.sourceforge.net/ target=_blank>here</a>. If you aren&rsquo;t on Windows, you have two options:</p><ol><li>Download the source code and build from source, using the instructions on GitHub.</li><li>Retrieve a pre-built library from a package manager. For example, on Mac, you can get the library with
<a href=https://brew.sh/ target=_blank>Homebrew</a> using <code>brew install glew</code>.</li></ol><p>Once we have the files, we put the library and include files in the <code>Libraries</code> folder:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>Root/
</span></span><span class=line><span class=cl>  Libraries/
</span></span><span class=line><span class=cl>    GLEW/
</span></span><span class=line><span class=cl>        include/
</span></span><span class=line><span class=cl>            GL/
</span></span><span class=line><span class=cl>                glew.h
</span></span><span class=line><span class=cl>                glxew.h
</span></span><span class=line><span class=cl>                wglew.h
</span></span><span class=line><span class=cl>        lib/
</span></span><span class=line><span class=cl>            mac/
</span></span><span class=line><span class=cl>                libGLEW.dylib
</span></span><span class=line><span class=cl>            win/
</span></span></code></pre></div><p>Finally, modify the project to include GLEW in the compile and linking process:</p><ol><li>Add <code>Libraries/GLEW/include</code> to header search paths.</li><li>Add <code>Libraries/GLEW/lib</code> to library search paths.</li><li>Add <code>-lGLEW</code> as a linker flag.</li></ol><p>After this, the game should still compile and run without a problem.</p><h1 id=sidetrack-the-renderer-class>Sidetrack: The Renderer Class</h1><p>Our rendering code and data can become quite complicated, so it&rsquo;s a good idea for us to introduce a new class, <code>Renderer</code>, rather than continue to pile this code into the <code>GEngine</code> class.</p><p>To start, our <code>Renderer</code> class looks something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Renderer.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Renderer</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>Initialize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Shutdown</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Render</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Present</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle for the window.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SDL_Window</span><span class=o>*</span> <span class=n>mWindow</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Context for rendering in OpenGL.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SDL_GLContext</span> <span class=n>mContext</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>GEngine</code> simply contains a renderer object:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In GEngine.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Renderer</span> <span class=n>mRenderer</span><span class=p>;</span>
</span></span></code></pre></div><p>As with <code>GEngine</code>, this class will need to be initialized and shutdown. We simply add calls to <code>Renderer::Initialize()</code> and <code>Renderer::Shutdown()</code> to the respective functions in <code>GEngine</code>.</p><p>Some of the logic that was previously in <code>GEngine::Initialize()</code> can also be moved to <code>Renderer::Initialize()</code>. For example, our calls to <code>SDL_InitSubSystem</code> and <code>SDL_CreateWindow</code> make more sense to be managed by the <code>Renderer</code>.</p><p>Ok, back on track - let&rsquo;s look at how we initialize OpenGL!</p><h1 id=initializing-opengl-and-glew>Initializing OpenGL and GLEW</h1><p>In our last post, we initialized the SDL video subsystem and created a basic SDL window. We still want to do this when using OpenGL, but we just need to augment those calls with a couple additional lines and some different arguments:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Renderer</span><span class=o>::</span><span class=n>Initialize</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Init video subsystem.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>SDL_InitSubSystem</span><span class=p>(</span><span class=n>SDL_INIT_VIDEO</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Tell SDL we want to use OpenGL 3.3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// These attributes must be set before creating the window.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SDL_GL_SetAttribute</span><span class=p>(</span><span class=n>SDL_GL_CONTEXT_PROFILE_MASK</span><span class=p>,</span> <span class=n>SDL_GL_CONTEXT_PROFILE_CORE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_GL_SetAttribute</span><span class=p>(</span><span class=n>SDL_GL_CONTEXT_MAJOR_VERSION</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_GL_SetAttribute</span><span class=p>(</span><span class=n>SDL_GL_CONTEXT_MINOR_VERSION</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Use double buffering.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SDL_GL_SetAttribute</span><span class=p>(</span><span class=n>SDL_GL_DOUBLEBUFFER</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Require hardware acceleration.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SDL_GL_SetAttribute</span><span class=p>(</span><span class=n>SDL_GL_ACCELERATED_VISUAL</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// We request from OpenGL at least 8-bits per channel for the color buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SDL_GL_SetAttribute</span><span class=p>(</span><span class=n>SDL_GL_RED_SIZE</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_GL_SetAttribute</span><span class=p>(</span><span class=n>SDL_GL_GREEN_SIZE</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_GL_SetAttribute</span><span class=p>(</span><span class=n>SDL_GL_BLUE_SIZE</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_GL_SetAttribute</span><span class=p>(</span><span class=n>SDL_GL_ALPHA_SIZE</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create a window.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mWindow</span> <span class=o>=</span> <span class=n>SDL_CreateWindow</span><span class=p>(</span><span class=s>&#34;GK3&#34;</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>1024</span><span class=p>,</span> <span class=mi>768</span><span class=p>,</span> <span class=n>SDL_WINDOW_OPENGL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>mWindow</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create OpenGL context.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mContext</span> <span class=o>=</span> <span class=n>SDL_GL_CreateContext</span><span class=p>(</span><span class=n>mWindow</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>mContext</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize GLEW.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>glewExperimental</span> <span class=o>=</span> <span class=n>GL_TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>glewInit</span><span class=p>()</span> <span class=o>!=</span> <span class=n>GLEW_OK</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Init succeeded!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As we&rsquo;ve done before, we first call <code>SDL_InitSubSystem</code>, and we don&rsquo;t continue if it fails. The remaining code requires deeper explanation; let&rsquo;s walk through it one step at a time.</p><h2 id=opengl-attributes>OpenGL Attributes</h2><p>Next, we <em>must</em> specify the OpenGL profile, major version, and minor version. OpenGL window creation will fail if these are not specified.</p><p>For a profile, we can choose Core, Compatibility, or ES. I don&rsquo;t see any reason to use Compatibility (which enables deprecated functionality). ES, as in OpenGL ES, provides a subset of OpenGL functionality, which is primarily used on mobile devices. I chose to use Core, since we are primarily interested in desktop platforms at the moment.</p><p>The next question is what major/minor version to use? This is a trade-off between desired OpenGL features and hardware support. 3.3 was the last version released to target hardware that supports Direct3D 10+, whereas OpenGL 4 targets hardware that supports Direct3D 11+. 3.3 was released in 2010, so we&rsquo;re at a point now where its hardware support is probably quite good. The game we&rsquo;re targeting, GK3, is also not the most graphically advanced game, having been released in 1999. So, let&rsquo;s just use OpenGL 3.3 for now!</p><p>I enabled double buffering, which we can use later in conjunction with VSYNC to avoid screen tearing. I also specify that I want to use hardware acceleration.</p><p>Finally, I request 8-bits per channel in the color buffer. I&rsquo;m basically asking for 32-bit RGBA color.</p><h2 id=window-and-context>Window and Context</h2><p>After setting all these attributes, we can finally create our window. This is the same code we had in the previous post, with one important difference: the flag <code>SDL_WINDOW_OPENGL</code> is now passed as the last argument!</p><p>Once we have a valid window, we need to create an OpenGL context with <code>SDL_GL_CreateContext</code>. Without creating a context, rendering will not work, and your program will likely crash. An application can conceivably create multiple contexts, but there usually isn&rsquo;t a compelling reason to do so. Certainly for this game engine, there is no need.</p><p>We need to save both the window and context as class member variables so that we can properly destroy them when the game is shutting down.</p><h2 id=glew-init>GLEW Init</h2><p>There are a surprising number of OpenGL functions that we&rsquo;ll need to use that aren&rsquo;t available via default OpenGL header files. We will be using GLEW to access those functions with relative ease.</p><p>After integrating the library into our project, we need to initialize it. If we attempt to call various GLEW-provided functions without initializing, we&rsquo;ll likely crash our program.</p><p>Note that you must <code>#include &lt;GL/glew.h></code> to access GLEW and GL functions.</p><p>The <code>glewExperimental</code> variable is a bit mystifying/misleading. By setting this to true, we aren&rsquo;t enabling some cutting edge or unstable part of GLEW. This is simply a flag that should ensure that GLEW properly loads the various required extensions, even if running on experimental or pre-release drivers. In practice, even basic functions sometimes fail without this turned on (at least on macOS) - so, we turn it on!</p><p>And with that, we&rsquo;re pretty well initialized!</p><h1 id=defining-vertex-data>Defining Vertex Data</h1><p>As mentioned earlier, a 3D object consists of a collection of vertices, and each vertex has a position in 3D space. A 3D position has three components (x, y, z). Games tend to represent these values using floating-point values (<code>float</code>).</p><p>For example, consider a very simple piece of 3D geometry we might want to render: a triangle. A triangle consists of three vertices.</p><p>To render a triangle, we will need to pass the vertex data to OpenGL, along with instructions for how to interpret those vertices. One common way to interpret the vertex data is &ldquo;every three vertices is one triangle.&rdquo; Since each vertex has three floating-point values, we could also phrase this as &ldquo;every nine floating-point values is one triangle&rdquo;.</p><p>As a result, we can define our simple triangle vertices in code like this, where every three floats represent one vertex position of our triangle:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>float</span> <span class=n>triangle_vertices</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mf>0.0f</span><span class=p>,</span>  <span class=mf>0.5f</span><span class=p>,</span>  <span class=mf>0.0f</span><span class=p>,</span>     <span class=c1>// top
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=mf>0.5f</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.5f</span><span class=p>,</span>  <span class=mf>0.0f</span><span class=p>,</span>     <span class=c1>// right
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>-</span><span class=mf>0.5f</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.5f</span><span class=p>,</span>  <span class=mf>0.0f</span>     <span class=c1>// left
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>This is a triangle centered around the <strong>origin</strong> of a 3D coordinate system where +y is up and +x is right.</p><p>It&rsquo;s uncommon to define vertex data directly in code like this, except for very simple debug shapes, such as this triangle. More frequently, you will read this vertex data from a file on disk, whether it is a common file format like FBX or OBJ, a simple text file where each line has one vertex on it, or GK3&rsquo;s proprietary binary 3D mesh format!</p><h1 id=loading-vertex-data-for-opengl>Loading Vertex Data for OpenGL</h1><p>Unfortunately, we can&rsquo;t just pass our float array of vertex data directly to OpenGL.</p><p>OpenGL requires that you create a <strong>Vertex Buffer Object</strong> (VBO) and copy the vertex data into that buffer. We must also define a <strong>Vertex Array Object</strong> (VAO) that tells OpenGL how to interpret the data in the buffer.</p><p>We will encapsulate these operations in a new class called <code>VertexArray</code>. An instance of this class represents a piece of renderable 3D geometry for the underlying graphics library.</p><p>Here&rsquo;s the header for this class:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// VertexArray.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#pragma once
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;GL/glew.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>VertexArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>VertexArray</span><span class=p>(</span><span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>vertPositions</span><span class=p>,</span> <span class=kt>int</span> <span class=n>vertPositionsCount</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>VertexArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Draw</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Handles to VBO and VAO.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GLuint</span> <span class=n>mVBO</span> <span class=o>=</span> <span class=n>GL_NONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>GLuint</span> <span class=n>mVAO</span> <span class=o>=</span> <span class=n>GL_NONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mVertexCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=creating-a-vertex-buffer-object>Creating a Vertex Buffer Object</h2><p>OpenGL can only render using data that is in video RAM (usually on the graphics card), whereas our float array exists in &ldquo;regular&rdquo; RAM. Creating a VBO and copying our vertex data into it effectively copies the vertex data to video RAM, where OpenGL is perfectly happy to use it for rendering.</p><p>Creating a VBO isn&rsquo;t too tricky, though it isn&rsquo;t exactly intuitive:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>VertexArray</span><span class=o>::</span><span class=n>VertexArray</span><span class=p>(</span><span class=k>const</span> <span class=kt>float</span><span class=o>*</span> <span class=n>vertPositions</span><span class=p>,</span> <span class=kt>int</span> <span class=n>vertPositionsCount</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Each vertex position is 3 elements, so divide by 3 to get vertex count.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mVertexCount</span> <span class=o>=</span> <span class=n>vertPositionsCount</span> <span class=o>/</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Generate a buffer and bind it for use.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>glGenBuffers</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mVBO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>glBindBuffer</span><span class=p>(</span><span class=n>GL_ARRAY_BUFFER</span><span class=p>,</span> <span class=n>mVBO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Allocate buffer of a certain size and copy vertex data into it.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Arguments are TARGET, SIZE, DATA, USAGE
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>glBufferData</span><span class=p>(</span><span class=n>GL_ARRAY_BUFFER</span><span class=p>,</span> <span class=n>vertPositionsCount</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>float</span><span class=p>),</span> <span class=n>triangle_vertices</span><span class=p>,</span> <span class=n>GL_STATIC_DRAW</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The variable <code>mVBO</code> is a &ldquo;handle&rdquo; to a buffer object. It isn&rsquo;t the buffer itself, and it isn&rsquo;t a pointer to the buffer - it is simply an unsigned integer that identifies the buffer in the graphics system. When we call <code>glGenBuffers</code>, we are only allocating a small, lightweight handle.</p><p>We then need to bind the buffer using <code>glBindBuffer</code>. Many commands in OpenGL operate on whatever happens to be the bound buffer. Therefore, it&rsquo;s important to bind the desired buffer before calling certain commands.</p><p>Our call to <code>glBufferData</code> does the heavy-lifting of allocated a buffer of the appropriate size, copying our vertex data into it, and associating it with the bound VBO handle. For the size (in bytes), we use <code>vertPositionsCount * sizeof(float)</code> because our triangle is 9 floats, and each float is 4 bytes. Floats are almost universally 4 bytes, but it is best to use <code>sizeof</code> so we don&rsquo;t have to assume!</p><p>The final &ldquo;usage&rdquo; argument we don&rsquo;t need to worry about at this time. The two options are <code>GL_STATIC_DRAW</code> and <code>GL_DYNAMIC_DRAW</code>. The purpose is to provide a hint to the graphics system about how frequently the contents of the VBO will change. &ldquo;Static&rdquo; indicates that it won&rsquo;t change at all, while &ldquo;Dynamic&rdquo; means it may change frequently. If we planned to update our buffer frequently (perhaps if we were animating vertex data), we may choose to mark the buffer as &ldquo;dynamic,&rdquo; which could improve performance. For our simply triangle, &ldquo;static&rdquo; will do just fine.</p><h2 id=creating-a-vertex-array-object>Creating a Vertex Array Object</h2><p>If we can use a VBO to load our vertex data into video memory for OpenGL, then why in the world do we need <em>another</em> object called a VAO? While a VBO provides the vertex data, we haven&rsquo;t yet specified HOW to interpret that data.</p><p>OpenGL needs to know a few things about the vertex data we are providing:</p><ol><li>How many vertex attributes are we providing? For our simple example, we are providing just the vertex positions, but it is also possible to provide other attributes like vertex colors, vertex normals, texture mapping coordinates, etc.</li><li>What byte offsets within the VBO does each vertex attribute&rsquo;s data reside at?</li><li>How many components exist for each vertex for this attribute? For position data, this is usually 3 (for X, Y, and Z), but for something like color, it could be 4 (for red, green, blue, and alpha values).</li><li>What is the type of the data? We often specify positions as floats, but we have the option to use different data types like bytes, shorts, and ints.</li><li>Is the vertex data tightly packed in the VBO, or are different types of data interleaved? We might provide all vertex positions at once, and then all vertex colors at once. Or, we might provide all the data for a single vertex at once, followed by the next, etc.</li></ol><p>This might seem like a lot of options to process - here are a few different examples of how data <em>could be</em> laid out in a VBO:</p><ul><li>Vertex positions consist of 3 <code>float</code> values that are tightly packed into memory one after the other starting at byte offset 0.</li><li>Vertex positions consist of 3 <code>float</code> values that are tightly packed into memory one after the other starting at byte offset 0. Vertex colors consist of 4 <code>byte</code> values that are tightly packed into memory one after the other starting at byte offset 36.</li><li>Vertex positions consist of 3 <code>float</code> values starting at byte offset 0, with each position having an offset of 4 bytes between. Vertex colors consist of 4 <code>byte</code> values starting at byte offset 12 with each color having an offset of 12 bytes between.</li></ul><p>To help visualize the idea of interleaving data, consider an example where we have vertex data for a triangle, with each vertex having position and color attributes. There are two ways we could lay out this data in our VBO:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Option 1 (packed data)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span><span class=n>V1Pos</span><span class=p>][</span><span class=n>V2Pos</span><span class=p>][</span><span class=n>V3Pos</span><span class=p>][</span><span class=n>V1Color</span><span class=p>][</span><span class=n>V2Color</span><span class=p>][</span><span class=n>V3Color</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Option 2 (interleaved data)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span><span class=n>V1Pos</span><span class=p>][</span><span class=n>V1Color</span><span class=p>][</span><span class=n>V2Pos</span><span class=p>][</span><span class=n>V2Color</span><span class=p>][</span><span class=n>V3Pos</span><span class=p>][</span><span class=n>V3Color</span><span class=p>]</span>
</span></span></code></pre></div><p>The key point is this: OpenGL doesn&rsquo;t make assumptions about the layout of the data in the VBO. There are many different ways to layout the data in the VBO, and there are different scenarios where one way could make more sense than another. So, we use a VAO to tell OpenGL how we have the data laid out.</p><p>For our simple triangle example, we can create our VAO like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>VertexArray</span><span class=o>::</span><span class=n>VertexArray</span><span class=p>(</span><span class=k>const</span> <span class=n>GLfloat</span><span class=o>*</span> <span class=n>vertPositions</span><span class=p>,</span> <span class=kt>int</span> <span class=n>vertPositionsCount</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// VBO creation code omitted...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Generate and bind our VAO.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>glGenVertexArrays</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mVAO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>glBindVertexArray</span><span class=p>(</span><span class=n>mVAO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Enable vertex attribute 0 (vertex position data).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>glEnableVertexAttribArray</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure VBO is bound, so the VAO knows what buffer to use in conjunction with the VAO.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>glBindBuffer</span><span class=p>(</span><span class=n>GL_ARRAY_BUFFER</span><span class=p>,</span> <span class=n>mVBO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Vertex attribute 0 (position data) has 3 components per vertex (x, y, z) and each is a float.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// We don&#39;t want this data normalized (GL_FALSE), and the data is tightly packed (0).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// There is no byte offset required (NULL).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>glVertexAttribPointer</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>GL_FLOAT</span><span class=p>,</span> <span class=n>GL_FALSE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As with our VBO, we allocate a small, lightweight handle object <code>mVAO</code> using the <code>glGenVertexArrays</code> function. We immediately bind the VAO using <code>glBindVertexArray</code>, since we&rsquo;re about to run VAO commands with our VAO as the target.</p><p>For rendering, we can enable several possible vertex attributes: position, color, UV texture mapping coordinates, normals, tangents, etc. By default, all our disabled. We use <code>glEnableVertexAttribArray</code> to enable at least index 0, which we&rsquo;ll use for our vertex position data. There&rsquo;s a not so large limit on the number of attributes - it&rsquo;s sometimes 8 or 16 or less!</p><p>If we haven&rsquo;t done so already, we need to bind our VBO using <code>glBindBuffer</code>. When we want to render our triangle, we will do so using the VAO. If we bind our VBO before calling <code>glVertexAttribPointer</code>, the VAO remembers what VBO it should use later on for rendering. In short, if we don&rsquo;t do this, the VAO doesn&rsquo;t keep track of what VBO to use, and we get no output to the screen!</p><p>Finally, we call <code>glVertexAttribPointer</code>. This is a beefy function! There&rsquo;s a lot of potential to accidentally provide the wrong data. So, let&rsquo;s break down what&rsquo;s going on here.</p><p>We call <code>glVertexAttribPointer</code> one time per attribute that we have enabled with <code>glEnableVertexAttribArray</code>. In this case, we only enabled one attribute, for vertex position, so we only need to call <code>glVertexAttribPointer</code> once, to provide the details for how the position data is laid out in the VBO. This is the first argument provided (<code>0</code>), which is the attribute index we are specifying data for.</p><p>The next two values are fairly simple: how many numbers per vertex, and what type are the numbers? Our vertex positions are defined as points in 3D space (x, y, z), and each one is a float. As such, we pass <code>3</code> and <code>GL_FLOAT</code>.</p><p>The next argument specifies whether we want the data to be normalized or not. For some data, like colors, this might make sense. For position data, this is not at all a good idea, so we say <code>GL_FALSE</code>.</p><p>The next argument is called &ldquo;stride&rdquo;, and it indicates whether our attribute data is tightly packed or interleaved amongst other data. A value of 0 indicates tight packing, whereas any other value indicates that there are 1, 2, 3, 4, etc bytes of other data between each vertex&rsquo;s attribute data. As described above, this can happen based on how you define your vertex data. We use <code>0</code> because we only have one attribute, so it&rsquo;s &ldquo;packed&rdquo; by default.</p><p>Finally, we have an offset into the VBO at which we can find the first instance of this attribute. Since we have only one attribute, the first instance is at offset 0, so we pass <code>NULL</code> (<code>0</code> would also work). If we had another attribute, like color, we would definitely need to provide an offset here.</p><p>At long last, we have a VBO and VAO defined, which we can use for rendering!</p><h2 id=rendering-the-vao>Rendering the VAO</h2><p>To render a VAO, we define a function called <code>Draw</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>VertexArray</span><span class=o>::</span><span class=n>Draw</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>glBindVertexArray</span><span class=p>(</span><span class=n>mVAO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>glDrawArrays</span><span class=p>(</span><span class=n>GL_TRIANGLES</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>mVertexCount</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We bind the VAO we want to render using <code>glBindVertexArray</code>. Finally, we issue the draw command <code>glDrawArrays</code>.</p><p><code>glDrawArrays</code> allows us to specify an offset into the vertex data to start rendering at, plus a count for the number of vertices to render. In our case, we want to start rendering at index 0, and we want to render all vertices (all 3 of them).</p><p>The first argument, <code>GL_TRIANGLES</code>, tells OpenGL how to render the vertex data. There are several options - here are a few examples:</p><ul><li><code>GL_TRIANGLES</code>: Interpret every 3 vertices as a single triangle.</li><li><code>GL_TRIANGLE_STRIP</code>: Interpret the first 3 vertices as a single triangle. After that, each new vertex creates a triangle with the previous 2 vertices.</li><li><code>GL_TRIANGLE_FAN</code>: The first vertex is shared between all triangles. Every vertex after the second vertex defines a triangle with the previous vertex and the first vertex.</li><li><code>GL_LINES</code>: Interpret every 2 vertices as a line.</li></ul><p>We&rsquo;ll often use <code>GL_TRIANGLES</code>, but we may have a need to use various other options as we implement different types of rendering.</p><p>Before we move on, don&rsquo;t forget the destructor for <code>VertexArray</code>, which deletes the objects we created in the constructor:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>VertexArray</span><span class=o>::~</span><span class=n>VertexArray</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>mVBO</span> <span class=o>!=</span> <span class=n>GL_NONE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>glDeleteBuffers</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mVBO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>mVAO</span> <span class=o>!=</span> <span class=n>GL_NONE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>glDeleteVertexArrays</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mVAO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=writing-a-shader>Writing a Shader</h1><p>After ALL that work to create our VBO and VAO, if we tried to render, we&rsquo;d get&mldr;nothing!</p><p>Though we have defined our vertex data and how to interpret it, we have not yet defined how to &ldquo;fill in&rdquo; the surfaces of the shape when it is drawn. For example, do we want to fill in the surface of the shape with a color? If so, what color? Or maybe we want to display a texture on the surface? We haven&rsquo;t specified that yet, and so nothing is rendered.</p><p>In modern graphics libraries, such decisions are usually expressed in a <strong>shader program</strong>. A simple shader program consists of two parts, a <strong>vertex shader</strong> and a <strong>fragment shader</strong> (the fragment shader is also sometimes called a <strong>pixel shader</strong>). The vertex shader executes first and is responsible for performing any operations on the individual vertices of the object being rendered. The fragment shader runs second and is responsible for performing operations on the individual output pixels in the color buffer.</p><p>The most critical function of a shader is this: for ever pixel on screen that will be used to render a 3D object, decide on a color value to use. It&rsquo;s that simple. That being said, properly deciding on a color value based on desired visual effects, lighting, and other considerations is another challenge entirely!</p><p>Both the vertex and fragment portions of a shader are written in a special programming language called a <strong>shader language</strong>. Unfortunately, there is not one single shader language - OpenGL uses a shader language called <strong>glsl</strong>, Direct3D uses another shader language called <strong>hlsl</strong>, and many other shader languages also exist. Many shader languages have similar syntaxes though, which is nice.</p><p>You write vertex and fragment shaders as text files containing the shader code for each part. At runtime, you load the text files, compile them, and link them into a final <strong>shader program</strong>. Compiling and linking of shaders at runtime can fail for a variety of reasons - a typo, a syntax error, unsupported features, etc. It&rsquo;s also possible to &ldquo;pre-compile&rdquo; shader programs and save them in a binary format (for performance reasons), but we won&rsquo;t worry about that for now.</p><p>For our simple triangle rendering needs, we can define two very simple files for our vertex and fragment shaders:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=cl><span class=c1>// Simple.vert</span>
</span></span><span class=line><span class=cl><span class=cp>#version 330</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>in</span> <span class=k>vec3</span> <span class=n>position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>void</span> <span class=n>main</span><span class=p>(</span><span class=k>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>gl_Position</span> <span class=o>=</span> <span class=k>vec4</span><span class=p>(</span><span class=n>position</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=cl><span class=c1>// Simple.frag</span>
</span></span><span class=line><span class=cl><span class=cp>#version 330</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>out</span> <span class=k>vec4</span> <span class=n>outColor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>void</span> <span class=n>main</span><span class=p>(</span><span class=k>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>outColor</span> <span class=o>=</span> <span class=k>vec4</span><span class=p>(</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Create two files called <code>Simple.vert</code> and <code>Simple.frag</code> with the above contents in each. Let&rsquo;s quickly review what these two files are doing.</p><h2 id=vertex-shader-explained>Vertex Shader Explained</h2><p>Remember, the vertex program runs first for every vertex of the object we want to render. For our simple triangle, this will run for all three vertices of the triangle. We could conceivably do much more in the vertex shader, and in the future, we will use the vertex shader to perform <em>transformations</em> that enable mesh instancing and a moveable 3D camera. For the time being, however, we keep it simple.</p><p>The version number line indicates to OpenGL what version of the <code>glsl</code> shader language we want to use. 330 is the version that came with OpenGL 3.3. You might choose one version or another because newer versions support additional features! Since we chose OpenGL 3.3 earlier, we&rsquo;ll use the version 330 compiler.</p><p>The <code>in vec3 position;</code> line defines what vertex attribute data we are expecting to get for each vertex. As described earlier in this post, we are only passing position data for each vertex. If we were passing other data, like color, we&rsquo;d have additional <code>in</code> lines specified here. There is a correlation between the lines here and the calls to <code>glEnableVertexAttribArray</code> we performed when creating the VAO.</p><p>Finally, we have our &ldquo;main&rdquo; function - this may look somewhat familiar from a C or C++ program! We are currently not doing anything special to our vertex position - we just pass it through as-is without modifying it.</p><p>During the vertex shader function, we must assign the special OpenGL variable <code>gl_Position</code> with our desired position, in 3D space, for the vertex. For the time being, we just want to use the exact same position we passed in. Since our &ldquo;in&rdquo; position is of type <code>vec3</code>, and <code>gl_Position</code> is a <code>vec4</code>, we must cast from <code>vec3</code> to <code>vec4</code>. We&rsquo;ll talk about &ldquo;vectors&rdquo; in a later blog post, but just know that a <code>vec3</code> has 3 elements (x, y, z) and a <code>vec4</code> has 4 elements (x, y, z, w). Both can be used to represent a position in 3D space.</p><h2 id=fragment-shader-explained>Fragment Shader Explained</h2><p>The fragment shader is not much different in structure from the vertex shader. But it&rsquo;s purpose is quite different - while our vertex shader runs once per vertex of the rendered object (3 times for our triangle), the fragment shader will run one time per output pixel for the rendered object. How many pixels does our triangle have? Well&mldr;it depends on the screen resolution and the object&rsquo;s position on screen! So, it is more difficult to quantify how many times the fragment shader will execute, but it almost certainly runs more times than our vertex shader.</p><p>The purpose of a fragment shader is also different. The fragment shader should decide on a final output color for each pixel of the rendered object.</p><p>In our case, we define an <code>out vec4 outColor;</code> variable - we just need to assign our final color to this variable by the end of the fragment shader &ldquo;main&rdquo; function. Our actual fragment shader function is quite simple too: we just set <code>outColor</code> to some color (purple), and that&rsquo;s it.</p><h1 id=loading-a-shader>Loading a Shader</h1><p>As mentioned earlier, writing the shaders is only part of the battle - we also need to load the shaders at runtime to use them for rendering! The process for this is fairly simple: we use the file I/O mechanisms of C++ to read in the contents of the files <code>Simple.vert</code> and <code>Simple.frag</code>. We pass the contents of each file to OpenGL to be compiled. If that succeeds, we then &ldquo;link&rdquo; the compiled vertex and fragment shaders to create a single &ldquo;shader program&rdquo; object.</p><p>The code for this isn&rsquo;t too tricky, but it&rsquo;s important to handle errors and log compiler errors to assist in debugging. I&rsquo;ll encapsulate the concept of a shader in a class called <code>Shader</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Shader.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#pragma once
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;GL/glew.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Shader</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Shader</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>vertShaderPath</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>fragShaderPath</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Shader</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsGood</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Activate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle to the compiled and linked GL shader program.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GLuint</span> <span class=n>mProgram</span> <span class=o>=</span> <span class=n>GL_NONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Did we encounter an error during compile/linking?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>mError</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>GLuint</span> <span class=nf>LoadAndCompileShaderFromFile</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>filePath</span><span class=p>,</span> <span class=n>GLuint</span> <span class=n>shaderType</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsShaderCompiled</span><span class=p>(</span><span class=n>GLuint</span> <span class=n>shader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsProgramLinked</span><span class=p>(</span><span class=n>GLuint</span> <span class=n>program</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Since reading in and compiling a shader is the same for both the vertex shader and fragment shader, we create a function that can do this for either:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>GLuint</span> <span class=n>Shader</span><span class=o>::</span><span class=n>LoadAndCompileShaderFromFile</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>filePath</span><span class=p>,</span> <span class=n>GLuint</span> <span class=n>shaderType</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Open the file, but freak out if not valid.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>ifstream</span> <span class=n>file</span><span class=p>(</span><span class=n>filePath</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>file</span><span class=p>.</span><span class=n>good</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Couldn&#39;t open shader file for loading: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>filePath</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>GL_NONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Read the file contents into a char buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>stringstream</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>buffer</span> <span class=o>&lt;&lt;</span> <span class=n>file</span><span class=p>.</span><span class=n>rdbuf</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>fileContentsStr</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>.</span><span class=n>str</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>fileContents</span> <span class=o>=</span> <span class=n>fileContentsStr</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create shader, load file contents into it, and compile it.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GLuint</span> <span class=n>shader</span> <span class=o>=</span> <span class=n>glCreateShader</span><span class=p>(</span><span class=n>shaderType</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>glShaderSource</span><span class=p>(</span><span class=n>shader</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fileContents</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>glCompileShader</span><span class=p>(</span><span class=n>shader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>shader</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>filePath</code> used must be relative to the working directory for the program, which will usually be the same directory the executable is in. When I build and run in Xcode, the working directory for the executable is some random build directory. So, for the above to work, we need to copy our shaders into the same folder as our executable, or tell Xcode/Visual Studio that our working directory should be something else!</p><p>After reading in the file contents as a <code>const char*</code>, we can create a shader handle (<code>glCreateShader</code>). The &ldquo;shaderType&rdquo; is either <code>GL_VERTEX_SHADER</code> or <code>GL_FRAGMENT_SHADER</code>.</p><p>The function <code>glShaderSource</code> copies the shader text into OpenGL, associating it with the given handle. The additional arguments allow for scenarios where you might pass in a shader one line at a time or something like that, but we&rsquo;ve just got the shader as one big string that is null terminated. So, we can simply say &ldquo;we&rsquo;ve got 1 string, here it is, no length value needed&rdquo;.</p><p>Finally, we call <code>glCompileShader</code>, which does the compiling. It may succeed, or it may fail. To find out, we need another function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Shader</span><span class=o>::</span><span class=n>IsShaderCompiled</span><span class=p>(</span><span class=n>GLuint</span> <span class=n>shader</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Ask GL whether compile succeeded for this shader.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GLint</span> <span class=n>compileSucceeded</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>glGetShaderiv</span><span class=p>(</span><span class=n>shader</span><span class=p>,</span> <span class=n>GL_COMPILE_STATUS</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>compileSucceeded</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If not, we&#39;ll output the error log and fail.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>compileSucceeded</span> <span class=o>==</span> <span class=n>GL_FALSE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>GLint</span> <span class=n>errorLength</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>glGetShaderiv</span><span class=p>(</span><span class=n>shader</span><span class=p>,</span> <span class=n>GL_INFO_LOG_LENGTH</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>errorLength</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>GLchar</span><span class=o>*</span> <span class=n>errorLog</span> <span class=o>=</span> <span class=k>new</span> <span class=n>GLchar</span><span class=p>[</span><span class=n>errorLength</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>glGetShaderInfoLog</span><span class=p>(</span><span class=n>shader</span><span class=p>,</span> <span class=n>errorLength</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>errorLength</span><span class=p>,</span> <span class=n>errorLog</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Error compiling shader: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>errorLog</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>errorLog</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// GL reports the compilation was successful!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can pass any shader handle from OpenGL to this function, and it&rsquo;ll return true or false for whether compilation succeeded. It&rsquo;ll even output any compiler errors if compilation failed.</p><p>Our <code>Shader</code> constructor uses these functions to load and compile the shader, given a file name:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Shader</span><span class=o>::</span><span class=n>Shader</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>vertShaderPath</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>fragShaderPath</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Compile default shader program.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GLuint</span> <span class=n>vertexShader</span> <span class=o>=</span> <span class=n>LoadAndCompileShaderFromFile</span><span class=p>(</span><span class=n>vertShaderPath</span><span class=p>,</span> <span class=n>GL_VERTEX_SHADER</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>GLuint</span> <span class=n>fragmentShader</span> <span class=o>=</span> <span class=n>LoadAndCompileShaderFromFile</span><span class=p>(</span><span class=n>fragShaderPath</span><span class=p>,</span> <span class=n>GL_FRAGMENT_SHADER</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>IsShaderCompiled</span><span class=p>(</span><span class=n>vertexShader</span><span class=p>)</span> <span class=o>||</span> <span class=o>!</span><span class=n>IsShaderCompiled</span><span class=p>(</span><span class=n>fragmentShader</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>glDeleteShader</span><span class=p>(</span><span class=n>vertexShader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>glDeleteShader</span><span class=p>(</span><span class=n>fragmentShader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>mError</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Assemble shader program.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mProgram</span> <span class=o>=</span> <span class=n>glCreateProgram</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>glAttachShader</span><span class=p>(</span><span class=n>mProgram</span><span class=p>,</span> <span class=n>vertexShader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>glAttachShader</span><span class=p>(</span><span class=n>mProgram</span><span class=p>,</span> <span class=n>fragmentShader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Link the program.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>glLinkProgram</span><span class=p>(</span><span class=n>mProgram</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If linking failed, clean up and return error.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>IsProgramLinked</span><span class=p>(</span><span class=n>mProgram</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>glDeleteProgram</span><span class=p>(</span><span class=n>mProgram</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>glDeleteShader</span><span class=p>(</span><span class=n>vertexShader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>glDeleteShader</span><span class=p>(</span><span class=n>fragmentShader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>mError</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Detach shaders after a successful link.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>glDetachShader</span><span class=p>(</span><span class=n>mProgram</span><span class=p>,</span> <span class=n>vertexShader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>glDetachShader</span><span class=p>(</span><span class=n>mProgram</span><span class=p>,</span> <span class=n>fragmentShader</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>First, we use our functions <code>LoadAndCompileShaderFromFile</code> and <code>IsShaderCompiled</code> to compile our vertex and fragment shaders. Then, we create a &ldquo;shader program&rdquo; handle with <code>glCreateProgram</code> - per usual with OpenGL, this is just a lightweight handle to a program. We then attach our two shaders to the program using <code>glAttachShader</code>.</p><p>We then &ldquo;link&rdquo; the program using <code>glLinkProgram</code>. If the link step succeeds, we can finally use our shader for rendering! After a successful link, we should detach the previously attached shaders with <code>glDetachShader</code>. If linking fails, we just clean up and return an error.</p><p>The function <code>IsProgramLinked</code> is one that I defined:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Shader</span><span class=o>::</span><span class=n>IsProgramLinked</span><span class=p>(</span><span class=n>GLuint</span> <span class=n>program</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Ask GL whether link succeeded for this program.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GLint</span> <span class=n>linkSucceeded</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>glGetProgramiv</span><span class=p>(</span><span class=n>program</span><span class=p>,</span> <span class=n>GL_LINK_STATUS</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>linkSucceeded</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If not, we&#39;ll output the error log and fail.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>linkSucceeded</span> <span class=o>==</span> <span class=n>GL_FALSE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>GLint</span> <span class=n>errorLength</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>glGetProgramiv</span><span class=p>(</span><span class=n>program</span><span class=p>,</span> <span class=n>GL_INFO_LOG_LENGTH</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>errorLength</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>GLchar</span><span class=o>*</span> <span class=n>errorLog</span> <span class=o>=</span> <span class=k>new</span> <span class=n>GLchar</span><span class=p>[</span><span class=n>errorLength</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>glGetProgramInfoLog</span><span class=p>(</span><span class=n>program</span><span class=p>,</span> <span class=n>errorLength</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>errorLength</span><span class=p>,</span> <span class=n>errorLog</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Error linking shader program: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>errorLog</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>errorLog</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// GL reports the linking was successful!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This function is similar to our <code>IsShaderCompiled</code> function - it checks with OpenGL that the program has linked successfully, and if not, it outputs an error log.</p><p>There are a couple more functions defined for <code>Shader</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Shader</span><span class=o>::~</span><span class=n>Shader</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>mProgram</span> <span class=o>!=</span> <span class=n>GL_NONE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>glDeleteProgram</span><span class=p>(</span><span class=n>mProgram</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Shader</span><span class=o>::</span><span class=n>IsGood</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>!</span><span class=n>mError</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Shader</span><span class=o>::</span><span class=n>Activate</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>glUseProgram</span><span class=p>(</span><span class=n>mProgram</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The destructor is needed so that we properly delete the program created in the constructor. <code>IsGood</code> simply returns whether we encountered any error with the shader loading/compiling/linking. Finally <code>Activate</code> must be called before rendering an object, so that this shader will be used when rendering - this just calls <code>glUseProgram</code>, which &ldquo;activates&rdquo; the shader program in OpenGL.</p><h1 id=bringing-it-all-together>Bringing It All Together</h1><p>We are finally ready to render our triangle. We add to our <code>Renderer::Initialize()</code> function to create our <code>VertexArray</code> and <code>Shader</code> objects:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Renderer</span><span class=o>::</span><span class=n>Initialize</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SDL, GL, and GLEW init omitted...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Load shader.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mShader</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Shader</span><span class=p>(</span><span class=s>&#34;Simple.vert&#34;</span><span class=p>,</span> <span class=s>&#34;Simple.frag&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>mShader</span><span class=o>-&gt;</span><span class=n>IsGood</span><span class=p>())</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create vertex array from triangle vertices.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mTriangle</span> <span class=o>=</span> <span class=k>new</span> <span class=n>VertexArray</span><span class=p>(</span><span class=n>triangle_vertices</span><span class=p>,</span> <span class=mi>9</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Init succeeded!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In <code>GEngine::GenerateOutputs</code>, we add this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>GEngine</span><span class=o>::</span><span class=n>GenerateOutputs</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mRenderer</span><span class=p>.</span><span class=n>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>mRenderer</span><span class=p>.</span><span class=n>Render</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>mRenderer</span><span class=p>.</span><span class=n>Present</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And at this point, our <code>Clear</code>, <code>Render</code>, and <code>Present</code> functions are quite simple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Renderer</span><span class=o>::</span><span class=n>Clear</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>glClear</span><span class=p>(</span><span class=n>GL_COLOR_BUFFER_BIT</span> <span class=o>|</span> <span class=n>GL_DEPTH_BUFFER_BIT</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Renderer</span><span class=o>::</span><span class=n>Render</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mShader</span><span class=o>-&gt;</span><span class=n>Activate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>mTriangle</span><span class=o>-&gt;</span><span class=n>Draw</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Renderer</span><span class=o>::</span><span class=n>Present</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_GL_SwapWindow</span><span class=p>(</span><span class=n>mWindow</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Every time we render, we must first clear the buffer using <code>glClear</code>. It&rsquo;s most critical that we clear the color buffer at this point.</p><p>Next, we actually render our various 3D objects to the now cleared buffer. For our triangle, we activate the shader (which calls <code>glUseProgram</code>) and then draw our triangle (which calls <code>glDrawArrays</code>).</p><p>Finally, since we are using double buffering, all this rendering thus far has occurred on the back buffer. In order for the user to see anything we rendered, we need to &ldquo;swap&rdquo; the back and front buffers. Our back buffer then becomes the front buffer, and next frame, we&rsquo;ll draw to our new back buffer, which was previously the front buffer. The act of swapping the front and back buffers is sometimes called &ldquo;swap&rdquo;, sometimes called &ldquo;present&rdquo;. The SDL command is <code>SDL_GL_SwapWindow</code>.</p><p>After all that, you should see on-screen something like this:</p><p><img src=/img/gengine/triangle_render.png#center alt="3D object made up of triangles/vertices"></p><p>Finally!</p><p>You can modify the color used in the fragment shader. If you&rsquo;re having trouble loading your shaders, make sure they are located in the right folder, wherever the program executable is.</p><h1 id=conclusion>Conclusion</h1><p>This post introduced three foundational rendering classes: <code>Renderer</code>, <code>VertexArray</code>, and <code>Shader</code>. Despite the large amount of groundwork required to even get a simple triangle rendering on-screen, the majority of what has been written can now be used to render any 3D object with relative ease.</p><p>If you run into issues, check out
<a href=https://github.com/kromenak/gengine/commit/5f1d8563d960dc1f5b18460e0dc532c98b38b02c target=_blank>the commit in the G-Engine repo</a> that contains this code. Note that I&rsquo;ve renamed and finessed a few things in this blog post for ease of reading and clarity, so the committed code is not exactly the same.</p><p>Now that we can render a 3D object, our next goal will be the ability to move the 3D object to a desired position in 3D space, plus the ability to move our camera. But before we do that, we&rsquo;ll need to implement some math classes for Vectors and Matrices - stay tuned!</p><div class=blog-tags><a href=https://clarkkromenaker.com//tags/g-engine/>G-Engine</a>&nbsp;
<a href=https://clarkkromenaker.com//tags/c++/>C++</a>&nbsp;
<a href=https://clarkkromenaker.com//tags/opengl/>OpenGL</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://clarkkromenaker.com/post/gengine-03-game-loop/ data-toggle=tooltip data-placement=top title="G-Engine #3: Game Loop">&larr; Previous Post</a></li><li class=next><a href=https://clarkkromenaker.com/post/csharp-structs/ data-toggle=tooltip data-placement=top title="Saving Memory with C# Structs">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2025</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://clarkkromenaker.com/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>