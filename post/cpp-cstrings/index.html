<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>C-Strings in C++ - Clark Kromenaker</title>
<meta name=description content="Strings in C are simply arrays of char values - or in other words, a contiguous block of memory containing chars. C++ inherits that representation, but also provides a safer and easier-to-use option called std::string. In C++, the old C-style strings are often called C-Strings.
Most C++ gurus would advise you to avoid C-Strings and just use std::string. And it is true that std::string is safer and easier to use than C-Strings. Whereas std::string manages memory for you and has a ton of built-in functionality, C-Strings are essentially just blocks of char memory that you must manipulate with error-prone and inconsistent functions.
However, avoiding C-Strings entirely is difficult - sometimes you inherit code that&rsquo;s using them, sometimes SDKs or libraries require you to use them, sometimes they are the most efficient option.
C-Strings can be confusing to work with. There are a variety of functions used to manipulate C-Strings, but some are deprecated or insecure, some are only available in certain compilers, and some have intricate ins and outs for using them properly.
So, my goal with this post is to catalogue some common operations you&rsquo;d want to perform on C-Strings and identify the best options available, what to avoid, and what pitfalls exist."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/clarkkromenaker.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/clarkkromenaker.com\/post\/cpp-cstrings\/","name":"C strings in c"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"C-Strings in C\u002b\u002b","description":"Strings in C are simply arrays of char values - or in other words, a contiguous block of memory containing chars. C\u002b\u002b inherits that representation, but also provides a safer and easier-to-use option called std::string. In C\u002b\u002b, the old C-style strings are often called C-Strings.\nMost C\u002b\u002b gurus would advise you to avoid C-Strings and just use std::string. And it is true that std::string is safer and easier to use than C-Strings. Whereas std::string manages memory for you and has a ton of built-in functionality, C-Strings are essentially just blocks of char memory that you must manipulate with error-prone and inconsistent functions.\nHowever, avoiding C-Strings entirely is difficult - sometimes you inherit code that\u0026rsquo;s using them, sometimes SDKs or libraries require you to use them, sometimes they are the most efficient option.\nC-Strings can be confusing to work with. There are a variety of functions used to manipulate C-Strings, but some are deprecated or insecure, some are only available in certain compilers, and some have intricate ins and outs for using them properly.\nSo, my goal with this post is to catalogue some common operations you\u0026rsquo;d want to perform on C-Strings and identify the best options available, what to avoid, and what pitfalls exist.\n","inLanguage":"en","wordCount":2737,"datePublished":"2022-05-29T00:00:00","dateModified":"2022-05-29T00:00:00","image":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","keywords":["C\u002b\u002b"],"mainEntityOfPage":"https:\/\/clarkkromenaker.com\/post\/cpp-cstrings\/","publisher":{"@type":"Organization","name":"https:\/\/clarkkromenaker.com\/","logo":{"@type":"ImageObject","url":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="C-Strings in C++"><meta property="og:description" content="Strings in C are simply arrays of char values - or in other words, a contiguous block of memory containing chars. C++ inherits that representation, but also provides a safer and easier-to-use option called std::string. In C++, the old C-style strings are often called C-Strings.
Most C++ gurus would advise you to avoid C-Strings and just use std::string. And it is true that std::string is safer and easier to use than C-Strings. Whereas std::string manages memory for you and has a ton of built-in functionality, C-Strings are essentially just blocks of char memory that you must manipulate with error-prone and inconsistent functions.
However, avoiding C-Strings entirely is difficult - sometimes you inherit code that&rsquo;s using them, sometimes SDKs or libraries require you to use them, sometimes they are the most efficient option.
C-Strings can be confusing to work with. There are a variety of functions used to manipulate C-Strings, but some are deprecated or insecure, some are only available in certain compilers, and some have intricate ins and outs for using them properly.
So, my goal with this post is to catalogue some common operations you&rsquo;d want to perform on C-Strings and identify the best options available, what to avoid, and what pitfalls exist."><meta property="og:image" content="https://clarkkromenaker.com/img/avatar-icon.png"><meta property="og:url" content="https://clarkkromenaker.com/post/cpp-cstrings/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="C-Strings in C++"><meta name=twitter:description content="Strings in C are simply arrays of char values - or in other words, a contiguous block of memory containing chars. C++ inherits that representation, but also provides a safer and easier-to-use option â€¦"><meta name=twitter:image content="https://clarkkromenaker.com/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://clarkkromenaker.com/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://clarkkromenaker.com/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://clarkkromenaker.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://clarkkromenaker.com/css/syntax.css><link rel=stylesheet href=https://clarkkromenaker.com/css/codeblock.css><link rel=stylesheet href=https://clarkkromenaker.com//css/portfolio.css><link rel=stylesheet href=https://clarkkromenaker.com//css/misc.css><link rel=stylesheet href=https://clarkkromenaker.com//css/overrides.css><script src=https://clarkkromenaker.com//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://clarkkromenaker.com/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://clarkkromenaker.com/><img class=avatar-img src=https://clarkkromenaker.com/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>C-Strings in C++</h1><span class=post-meta><i class=fas></i>Posted on May 29, 2022</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>Strings in C are simply arrays of <code>char</code> values - or in other words, a contiguous block of memory containing <code>chars</code>. C++ inherits that representation, but also provides a safer and easier-to-use option called <code>std::string</code>. In C++, the old C-style strings are often called <strong>C-Strings</strong>.</p><p>Most C++ gurus would advise you to avoid C-Strings and just use <code>std::string</code>. And it is true that <code>std::string</code> is safer and easier to use than C-Strings. Whereas <code>std::string</code> manages memory for you and has a ton of built-in functionality, C-Strings are essentially just blocks of <code>char</code> memory that you must manipulate with error-prone and inconsistent functions.</p><p>However, avoiding C-Strings entirely is difficult - sometimes you inherit code that&rsquo;s using them, sometimes SDKs or libraries require you to use them, sometimes they are the most efficient option.</p><p>C-Strings can be confusing to work with. There are a variety of functions used to manipulate C-Strings, but some are deprecated or insecure, some are only available in certain compilers, and some have intricate ins and outs for using them properly.</p><p>So, my goal with this post is to catalogue some common operations you&rsquo;d want to perform on C-Strings and identify the best options available, what to avoid, and what pitfalls exist.</p><h1 id=creating-c-strings>Creating C-Strings</h1><p>You may think that creating a C-String is very simple, but that isn&rsquo;t necessarily the case. C-Strings are inherently tied to concepts like memory, pointers, and arrays, so some understanding of those concepts is required.</p><p>The simplest option is to create a C-String using a <strong>string literal</strong> (that is, a sequence of characters in double quotes):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span></code></pre></div><p>String literals are stored in read-only memory at runtime, so you aren&rsquo;t supposed to modify them. To reflect this, string literals should be stored in variables of type <code>const char*</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str1</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span> <span class=c1>// correct
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span><span class=o>*</span> <span class=n>str2</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span> <span class=c1>// this should generate a warning
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>str2</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;x&#39;</span><span class=p>;</span> <span class=c1>// this will cause a crash or exception
</span></span></span></code></pre></div><p>If you want to modify a C-String that is created using a string literal, you need to use slightly different creation syntax that copies the string literal into a writable array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span> <span class=c1>// creates an array and copies literal into it
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>str</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;x&#39;</span><span class=p>;</span> <span class=c1>// ok to modify our local copy
</span></span></span></code></pre></div><p>We did not specify the size of the char array - it was calculated automatically based on the size of the string literal. How big do you think the array is?</p><p>The word &ldquo;Hello&rdquo; consists of 5 characters. But actually the size of the array is 6! This is because all C-Strings end with a special character called the <strong>null-terminator</strong> (<code>\0</code>). All C-Strings should end with a null-terminator character, as this is the only way to detect the end of a C-String when you don&rsquo;t have the length stored elsewhere.</p><p>So, the contents of the above array is actually <code>Hello\0</code>.</p><p>We can also specify an explicit size:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span> <span class=c1>// can hold 255 chars, plus the null-terminator
</span></span></span></code></pre></div><p>The contents of that array are undefined - it is not guaranteed to be filled with a specific value. Depending on your needs, you may want to initialize the contents of the array in some way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span> <span class=c1>// all elements are zeroed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span> <span class=c1>// first 6 elements contain Hello\0, rest is zeroed out
</span></span></span></code></pre></div><p>Arrays and pointers in C++ are closely related, and generally you can treat arrays as pointers and vice-versa. It is very important to understand this, since the majority of C-String operations take in a <code>char*</code> or <code>const char*</code> as an argument. Passing an array is totally fine:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>strPtr</span> <span class=o>=</span> <span class=n>str</span><span class=p>;</span> <span class=c1>// strPtr points to first element of array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>strPtr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;x&#39;</span><span class=p>;</span> <span class=c1>// we can use array accessors on pointers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>printf</span><span class=p>(</span><span class=n>str</span><span class=p>);</span> <span class=c1>// can pass an array as a char* argument
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>printf</span><span class=p>(</span><span class=n>strPtr</span><span class=p>);</span> <span class=c1>// or pass the pointer if you prefer
</span></span></span></code></pre></div><h2 id=dynamic-size-c-strings>Dynamic Size C-Strings</h2><p>All the above examples use a maximum array size known at compile time. The size is either a constant, or the size can be derived by the compiler (the compiler can calculate that <code>Hello</code> is 6 characters long, including the null terminator).</p><p>If you need a C-String that is variable length, you must allocate the C-String on the heap:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=nf>AllocCString</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>size</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Of course, if the C-String is allocated on the heap, it must be deleted at a later time.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>cstring</span> <span class=o>=</span> <span class=n>AllocCString</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>delete</span><span class=p>[]</span> <span class=n>cstring</span><span class=p>;</span>
</span></span></code></pre></div><h1 id=modifying-c-strings>Modifying C-Strings</h1><p>Once you&rsquo;ve created a C-String, modifying the contents is not very easy or intuitive. It requires some memory manipulation that is sometimes error-prone or dangerous.</p><p>As mentioned earlier, if the C-String points at a string literal in read-only memory, you <em>cannot</em> modify it. Doing so will crash the program. To guard against this, always store these types of C-Strings as <code>const char*</code> (the compiler should warn you about this if you forget).</p><p>But even if a C-String is writable, modifying it isn&rsquo;t immediately clear:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>array</span><span class=p>[</span><span class=mi>256</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span> <span class=o>=</span> <span class=s>&#34;Goodbye&#34;</span><span class=p>;</span> <span class=c1>// Doesn&#39;t work!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>array</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;Goodbye&#34;</span><span class=p>;</span> <span class=c1>// Also doesn&#39;t work!
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Works, but tedious
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>array</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;G&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;o&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;o&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;d&#39;</span><span class=p>;</span>
</span></span></code></pre></div><p>If you want to modify just a single element of the string, use the array accessors as shown above. But if you want to do more complex manipulation, dedicated functions are preferred.</p><p>The standard library provides many different functions to change a C-String&rsquo;s contents. It can be unclear which option to choose.</p><h2 id=strcpy>strcpy</h2><p>The most basic option is <code>strcpy</code>, which copies the contents of one C-String to another:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Ah&#34;</span><span class=p>);</span> <span class=c1>// copies &#34;Ah\0&#34; (the source) into str (the dest)
</span></span></span></code></pre></div><p>Note that this simply overwrites existing characters and leaves any extra characters alone. After the above operation, the array contains <code>Ah\0lo\0</code>.</p><p><code>strcpy</code> is a bit dangerous because you might accidentally specify a source string that is longer than the destination buffer size. This can lead to dangerous memory corruption that is hard to detect.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span> <span class=c1>// the char array is 6 elements long
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Bad Idea&#34;</span><span class=p>);</span> <span class=c1>// copy 9 chars into a 6-element array - not good!
</span></span></span></code></pre></div><p>This produces no error or warning or exception, and it&rsquo;ll appear to work fine. However, we just modified memory outside the bounds of C-string array, possibly corrupting unrelated memory. The program may crash or malfunction later, and it&rsquo;ll be hard to determine that this was the cause.</p><h2 id=strncpy>strncpy</h2><p>To avoid that problem, you can instead use <code>strncpy</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>strncpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Wow&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>);</span> <span class=c1>// memory corruption is not possible
</span></span></span></code></pre></div><p>The whole point of <code>strncpy</code> is that you specify the max number of chars to write to the destination. In most cases, this should just be the size of the destination array, which can be derived using <code>sizeof</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>strncpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Wow&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>str</span><span class=p>));</span> <span class=c1>// memory corruption is not possible
</span></span></span></code></pre></div><p>However, <code>strncpy</code> has one fatal flaw. It will avoid writing too much data to the destination buffer, BUT it will not add the null terminator if the source string is longer than the size specified:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>strncpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Bad Idea&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>str</span><span class=p>));</span> <span class=c1>// no null terminator!
</span></span></span></code></pre></div><p>This leaves the contents of <code>str</code> as <code>Bad Id</code> with no null terminator. As a result, it isn&rsquo;t a valid C-String, and other operations that depend on the null-terminator will probably fail or crash or behave oddly. Dangerous stuff.</p><p>So, neither <code>strcpy</code> nor <code>strncpy</code> are ideal. Both are only safe if you KNOW that the source C-String is same size or smaller than the destination C-String. Alternatively, you need to add checks for string length and manually add a null-terminator &ldquo;just in case.&rdquo;</p><p>But fortunately, there are additional functions that fix these problems AND provide a ton of useful formatting options.</p><h1 id=formatting-c-strings>Formatting C-Strings</h1><p>Sometimes, you want to change the contents of a C-String, but the new contents contain some variable elements. For example, you might want the user to input their name and age and then save a C-String that contains <code>My name is X and I'm Y years old</code>.</p><p>Fortunately, the standard library provides <code>sprintf</code> and <code>snprintf</code> to enable this sort of C-String formatting.</p><p><code>sprintf</code> functions by specifying a special format string, which is a string literal, but with dynamic parts replaced by special symbols indicting the type of data to replace them with later:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Clark&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>age</span> <span class=o>=</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>sprintf</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;My name is %s and I&#39;m %i years old.&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>age</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// str contains &#34;My name is Clark and I&#39;m 32 years old.\0&#34;
</span></span></span></code></pre></div><p>In the format string, anything starting with <code>%</code> is meant to be replaced with a provided variable. The letter after the <code>%</code> indicates the type of variable.</p><ul><li><code>%s</code> is a C-String</li><li><code>%i</code> is an int</li><li><code>%f</code> is a float</li><li><a href=https://www.cplusplus.com/reference/cstdio/printf/ target=_blank>See a full list here</a></li></ul><p><code>sprintf</code> has the same problem as <code>strcpy</code> - it&rsquo;s possible for the destination to be too small, causing you to overwrite memory outside the C-String. And like <code>strcpy</code>, this is resolved by using a separate version of the function that takes in the size of the destination buffer.</p><p><code>snprintf</code> does just that - it formats a destination C-String, but also takes in the size of the destination to avoid overflow:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>snprintf</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>str</span><span class=p>),</span> <span class=s>&#34;My name is %s and I&#39;m %i years old.&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>age</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// str contains &#34;My name is Clark and I&#39;m 32 years old.\0&#34;
</span></span></span></code></pre></div><p><code>snprintf</code> is probably the safest option for modifying the contents of a string. Not only does it avoid writing outside of the destination buffer, it also <strong>always appends a null terminator</strong>, meaning that the resulting C-String is always valid. So, regardless of whether the destination buffer is big enough, at least memory won&rsquo;t be corrupted.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span> <span class=c1>// way too small buffer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>snprintf</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>str</span><span class=p>),</span> <span class=s>&#34;My name is %s and I&#39;m %i years old.&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>age</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// str contains &#34;My n\0&#34; - not ideal, but also not dangerous!
</span></span></span></code></pre></div><p><code>snprintf</code> can be used as an alternative to <code>strncpy</code> if you use a very simple format string. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>snprintf</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>str</span><span class=p>),</span> <span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=s>&#34;Goodbye&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// str contains &#34;Goodbye\0&#34;
</span></span></span></code></pre></div><p>One other cool use for <code>snprintf</code> is determining the amount of memory you need for a dynamic char array. If you pass in <code>nullptr</code> as the destination buffer, the function will return the number of characters needed for the formatted text. This can then be used to allocate a buffer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>snprintf</span><span class=p>(</span><span class=k>nullptr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=s>&#34;Hello %s&#34;</span><span class=p>,</span> <span class=s>&#34;Clark&#34;</span><span class=p>);</span> <span class=c1>// returns 11 (doesn&#39;t include null-terminator)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span><span class=o>*</span> <span class=n>str</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=c1>// need +1 for null terminator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>snprintf</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=n>size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=s>&#34;Hello %s&#34;</span><span class=p>,</span> <span class=s>&#34;Clark&#34;</span><span class=p>);</span> <span class=c1>// actually copy formatted string into str
</span></span></span></code></pre></div><p>So, to summarize:</p><ul><li><code>snprintf</code> is the safest and most feature-rich way to modify the contents of a C-String. Prefer it over <code>strcpy</code>, <code>strncpy</code>, or <code>sprintf</code>.</li><li>Because they don&rsquo;t do any formatting, <code>strcpy</code> or <code>strncpy</code> may be faster if speed is of utmost importance. Just use with caution.</li><li>If you plan to use these functions frequently, consider using wrappers to hide the boilerplate and gotchas in one place.</li></ul><h1 id=concatenating-c-strings>Concatenating C-Strings</h1><p>Unfortunately, you can&rsquo;t use the <code>+</code> operator to concatenate C-Strings. You can use <code>strcat</code> to concatenate one C-String onto another:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>strcat</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Goodbye&#34;</span><span class=p>);</span> <span class=c1>// str now contains &#34;HelloGoodbye&#34;
</span></span></span></code></pre></div><p>As you might guess, this function has the same buffer overflow issues as <code>strcpy</code> or <code>sprintf</code>. If the C-String is not big enough to hold the original contents plus the appended text, you&rsquo;ll corrupt your memory.</p><p>There is a <code>strncat</code> variant to help alleviate this, but it annoyingly takes the max number of characters to append, rather than the size of the destination buffer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>strncat</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Goodbye&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>str</span><span class=p>)</span> <span class=o>-</span> <span class=mi>6</span><span class=p>);</span> <span class=c1>// Append max of (256 - 6) chars.
</span></span></span></code></pre></div><p>In the above example, you can&rsquo;t simply pass <code>sizeof(str)</code> because that gives 256 and the available space for concatenation is really only 250 due to the existing <code>Hello</code> text and space needed by the null terminator.</p><p>You might think we can again turn to <code>snprintf</code> to get a clever solution:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>snprintf</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>str</span><span class=p>),</span> <span class=s>&#34;%s%s&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=s>&#34;Goodbye&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>This <em>might</em> work, but it is dangerous to pass the destination buffer as a source object. This seemed to work when I tested it on my compiler, but I would not risk it!</p><p>Ultimately, concatenation is surprisingly problematic. It&rsquo;s important to be absolutely sure you have enough space available at the end of the destination buffer to hold the appended text. Consider creating a wrapper function to hide complexity and gotchas.</p><h1 id=c-string-length>C-String Length</h1><p>Taking the length of a C-String is one of the simplest operations, using <code>strlen</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>256</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>length</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>str</span><span class=p>);</span> <span class=c1>// would return 5 (null terminator not included in count)
</span></span></span></code></pre></div><p>Note that <code>strlen</code> does not include the null-terminator in the count. Though &ldquo;Hello&rdquo; would take up 6 chars with the null-terminator, <code>strlen</code> only returns 5.</p><p>Taking the length of a C-String is fairly inefficient. The length is not stored, so it must be computed each time the function is called.
This is an O(n) operation, since the entire array must be iterated until a null terminator is discovered. To see how this can be problematic in practice, check out
<a href=https://nee.lv/2021/02/28/How-I-cut-GTA-Online-loading-times-by-70/ target=_blank>this fun case study</a> highlighting how this oversight tanked loading times in GTA V for years.</p><p>If you just need to know whether the string is empty or not, it can be a lot more efficient to just check whether the first element is a null terminator or not!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>CStringEmpty</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Assuming we are passed a valid C-String.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// If first char is not null terminator, we&#39;ll consider this a non-empty string.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>str</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=comparing-c-strings>Comparing C-Strings</h1><p>You can&rsquo;t use the <code>==</code> operator to compare the contents of two C-Strings. Instead, you must use <code>strcmp</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Hello&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// str is equal to &#34;Hello&#34; 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// str is not equal to &#34;Hello&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>strcmp</code> will return zero if the two C-Strings are equal.</p><p>To perform an equality check, it does what you&rsquo;d probably expect: it iterates both strings, comparing the char at each position. If they aren&rsquo;t the same char, or a null terminator is found in one string but not the other, then they aren&rsquo;t equal.</p><p>You might think you can be clever and do a length check to early out - after all, two strings can&rsquo;t be equal if they&rsquo;re different lengths. However, this is actually less efficient because both length check and comparison must iterate the elements of the C-Strings. At least with <code>strcmp</code> it can early out when the values aren&rsquo;t equal.</p><p>If you want to compare only the start of the string (perhaps to check for a prefix), you can use <code>strncmp</code>, which compares only the first <strong>n</strong> letters of the strings.</p><p>One final note: case-insensitive comparisons are unfortunately not part of the standard library. You can use <code>toupper</code> or <code>tolower</code> to do a case-insensitive comparison. I would recommend creating a wrapper/utility function for this.</p><h1 id=conclusion>Conclusion</h1><p>Even if you try to avoid C-Strings, they are bound to pop up from time to time in just about any application. <code>std::string</code> is built upon C-Strings, so you&rsquo;re using them whether you like it or not!</p><p>Determining the correct functions to use for various C-String operations can be an adventure. There are many non-standard and non-portable functions out there, and there are plenty of Stack Overflow answers recommending that you use this or that helper function that only works on Windows or isn&rsquo;t part of the standard. Be careful, and always check before using! In my opinion, stick to the core set in the standard, plus your own wrappers, and you&rsquo;ll do fine.</p><p>By the way, notice how many times I mentioned wrapper functions in this post? I can&rsquo;t stress enough how valuable wrapping this complexity can be:</p><ol><li><p>To use many of these functions safely, you need null checks, length checks, etc. Instead of copy/pasting boilerplate a million times, put it in a single spot.</p></li><li><p>Does every programmer on your team know the ins and outs of <code>strcpy</code>, <code>strncpy</code>, <code>sprintf</code>, <code>snprintf</code>, etc? Which one will they choose when they need to do string manipulation? To maintain consistency in your codebase, create wrappers and require everyone to use them.</p></li><li><p>The standard library doesn&rsquo;t provide everything (case-insensitive searches are a good example). Along with basic wrappers, you can also build your own additional C-String functions using a consistent singular API.</p></li></ol><div class=blog-tags><a href=https://clarkkromenaker.com//tags/c++/>C++</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://clarkkromenaker.com/post/cpp-manager-access/ data-toggle=tooltip data-placement=top title="Accessing Managers in C++">&larr; Previous Post</a></li><li class=next><a href=https://clarkkromenaker.com/post/cpp-eof/ data-toggle=tooltip data-placement=top title="Reading to EOF">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2025</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://clarkkromenaker.com/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>