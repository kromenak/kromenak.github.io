<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Optimizing Texture Loads in G-Engine - Clark Kromenaker</title>
<meta name=description content="The texture loading code for 
G-Engine was written early in development, when I was eager to see some on-screen graphics to demonstrate tangible progress on the project. And then that code stayed relatively untouched for years. However, a 
recent GitHub issue highlighted a bottleneck - installing a mod containing very large textures caused scene load times to skyrocket!
In this post, I&rsquo;ll explain how this problem was investigated and fixed. It may be a helpful read if you want to learn more about loading image data to be used by a graphics API such as OpenGL, or if you want to see how naive texture loading code can be improved."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/clarkkromenaker.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/clarkkromenaker.com\/post\/gfx-texture-loading\/","name":"Optimizing texture loads in g engine"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"Optimizing Texture Loads in G-Engine","description":"The texture loading code for G-Engine was written early in development, when I was eager to see some on-screen graphics to demonstrate tangible progress on the project. And then that code stayed relatively untouched for years. However, a recent GitHub issue highlighted a bottleneck - installing a mod containing very large textures caused scene load times to skyrocket!\nIn this post, I\u0026rsquo;ll explain how this problem was investigated and fixed. It may be a helpful read if you want to learn more about loading image data to be used by a graphics API such as OpenGL, or if you want to see how naive texture loading code can be improved.\n","inLanguage":"en","wordCount":2722,"datePublished":"2025-10-05T00:00:00","dateModified":"2025-10-05T00:00:00","image":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","keywords":["C\u002b\u002b, OpenGL"],"mainEntityOfPage":"https:\/\/clarkkromenaker.com\/post\/gfx-texture-loading\/","publisher":{"@type":"Organization","name":"https:\/\/clarkkromenaker.com\/","logo":{"@type":"ImageObject","url":"https:\/\/clarkkromenaker.com\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="Optimizing Texture Loads in G-Engine"><meta property="og:description" content="The texture loading code for 
G-Engine was written early in development, when I was eager to see some on-screen graphics to demonstrate tangible progress on the project. And then that code stayed relatively untouched for years. However, a 
recent GitHub issue highlighted a bottleneck - installing a mod containing very large textures caused scene load times to skyrocket!
In this post, I&rsquo;ll explain how this problem was investigated and fixed. It may be a helpful read if you want to learn more about loading image data to be used by a graphics API such as OpenGL, or if you want to see how naive texture loading code can be improved."><meta property="og:image" content="https://clarkkromenaker.com/img/avatar-icon.png"><meta property="og:url" content="https://clarkkromenaker.com/post/gfx-texture-loading/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="Optimizing Texture Loads in G-Engine"><meta name=twitter:description content="The texture loading code for 
G-Engine was written early in development, when I was eager to see some on-screen graphics to demonstrate tangible progress on the project. And then that code stayed â€¦"><meta name=twitter:image content="https://clarkkromenaker.com/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://clarkkromenaker.com/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://clarkkromenaker.com/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://clarkkromenaker.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://clarkkromenaker.com/css/syntax.css><link rel=stylesheet href=https://clarkkromenaker.com/css/codeblock.css><link rel=stylesheet href=https://clarkkromenaker.com//css/portfolio.css><link rel=stylesheet href=https://clarkkromenaker.com//css/misc.css><link rel=stylesheet href=https://clarkkromenaker.com//css/overrides.css><script src=https://clarkkromenaker.com//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://clarkkromenaker.com/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://clarkkromenaker.com/><img class=avatar-img src=https://clarkkromenaker.com/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Optimizing Texture Loads in G-Engine</h1><span class=post-meta><i class=fas></i>Posted on October 5, 2025</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>The texture loading code for
<a href=https://github.com/kromenak/gengine target=_blank>G-Engine</a> was written early in development, when I was eager to see some on-screen graphics to demonstrate tangible progress on the project. And then that code stayed relatively untouched for years. However, a
<a href=https://github.com/kromenak/gengine/issues/27 target=_blank>recent GitHub issue</a> highlighted a bottleneck - installing a mod containing very large textures caused scene load times to skyrocket!</p><p>In this post, I&rsquo;ll explain how this problem was investigated and fixed. It may be a helpful read if you want to learn more about loading image data to be used by a graphics API such as OpenGL, or if you want to see how naive texture loading code can be improved.</p><h1 id=whats-the-problem>What&rsquo;s the Problem?</h1><p>G-Engine is built to load and parse the data files from Gabriel Knight 3, so it&rsquo;s texture loading code is geared towards the specific data set for that game. All image files shipped with the game are
<a href=https://en.wikipedia.org/wiki/BMP_file_format target=_blank>BMP format</a>. The vast majority use a proprietary compression technique, with a few uncompressed BMP files mixed in as well. Of the uncompressed BMP files, there&rsquo;s a mix of 24-bit and 8-bit (palettized) images.</p><p>The BMP image format isn&rsquo;t too complex, and the C++ code to load BMP image data is pretty straightforward. When tested against Gabriel Knight 3&rsquo;s image assets, loading was quick and the rendered output was correct. All seemed well, so I didn&rsquo;t spend more time optimizing it further.</p><p>However, a fan created a
<a href=http://larrylaffer.net/non-lsl-games/gabriel-knight-3-texture-upgrade target=_blank>hi-res texture pack mod</a> which swaps the original BMP files for ones that are much higher resolution. These replacement BMP files do not use the proprietary compression technique mentioned earlier - they&rsquo;re just normal 24-bit BMP images. When the game loads these files, it results in an atypical use case for the code:</p><ol><li>Rather than mostly loading compressed BMP files, the balance shifts to mostly loading normal 24-bit BMP files.</li><li>Rather than loading relatively small BMP files, the game is loading very large BMP files. The unmodded game rarely uses textures larger than 256x256. The mod contains files that are 512x512, 1024x1024, or even 2048x2048 and beyond!</li></ol><p>When using the hi-res texture pack, each scene transition in G-Engine took significantly longer - sometimes up to 10 seconds! The original game&rsquo;s engine was able to load these large textures very quickly in comparison - this signaled that the problem wasn&rsquo;t the large textures, it was my texture loading code!</p><h1 id=identifying-the-cause>Identifying the Cause</h1><p>Clearly something about reading in textures and sending them to the GPU wasn&rsquo;t scaling. This is essentially a three step process:</p><ol><li>The image data initially exists on the disk. First, we load it into a byte buffer with a single call to <code>std::ifstream::read</code>.</li><li>Once in memory, the byte buffer is interpreted into a <code>Texture</code> class instance. This class acts as a single runtime and in-memory representation of a texture in the engine. One of the main things done here is reading the pixel data from the byte buffer into a dedicated <code>mPixels</code> array.</li><li>The pixel data is sent to the graphics system so it can be used for rendering. In OpenGL, this is done with a single call to <code>glTexImage2D</code>.</li></ol><p>Steps 1 and 3 already seemed about as efficient as they could be - just one API call to copy a contiguous buffer of data. So I focused on bottlenecks that might exist in step 2.</p><p>The textures in this mod were all standard 24-bit BMP images, so I focused on the code that parses BMP data into a <code>Texture</code> instance. The code which reads data in pixel-by-pixel seemed suspicious:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Read in BMP file data pixel-by-pixel.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>rowSize</span> <span class=o>=</span> <span class=n>CalculateBmpRowSize</span><span class=p>(</span><span class=n>bitsPerPixel</span><span class=p>,</span> <span class=n>mWidth</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=n>mHeight</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>y</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=o>--</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bytesRead</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>mWidth</span><span class=p>;</span> <span class=o>++</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Calculate index into pixels array.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=p>(</span><span class=n>y</span> <span class=o>*</span> <span class=n>mWidth</span> <span class=o>+</span> <span class=n>x</span><span class=p>)</span> <span class=o>*</span> <span class=n>mBytesPerPixel</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Pixel data in the BMP file is BGR.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mPixels</span><span class=p>[</span><span class=n>index</span> <span class=o>+</span> <span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>reader</span><span class=p>.</span><span class=n>ReadByte</span><span class=p>();</span> <span class=c1>// Blue
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mPixels</span><span class=p>[</span><span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>reader</span><span class=p>.</span><span class=n>ReadByte</span><span class=p>();</span> <span class=c1>// Green
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mPixels</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>reader</span><span class=p>.</span><span class=n>ReadByte</span><span class=p>();</span>     <span class=c1>// Red
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>bytesRead</span> <span class=o>+=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// BI_RGB format doesn&#39;t save any alpha, even if 32 bits per pixel.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// We&#39;ll use a placeholder of 255 (fully opaque).
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mPixels</span><span class=p>[</span><span class=n>index</span> <span class=o>+</span> <span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=mi>255</span><span class=p>;</span> <span class=c1>// Alpha
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Skip padding that may be present to ensure 4-byte alignment.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>bytesRead</span> <span class=o>&lt;</span> <span class=n>rowSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reader</span><span class=p>.</span><span class=n>Skip</span><span class=p>(</span><span class=n>rowSize</span> <span class=o>-</span> <span class=n>bytesRead</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This seems like a bit of code that doesn&rsquo;t scale particularly well. It reads one pixel at a time, and reads one byte of the pixel at a time. Assuming a square image with width/height of <code>n</code>, this code is <code>O(n^2)</code>, using
<a href=https://www.bigocheatsheet.com/ target=_blank>big-O notation</a>.</p><p>One of my go-to techniques to isolate problem code is via deduction: if I comment out a block of code, and the problem disappears, the problem is likely caused by that code block. In this case, commenting out the code obviously causes all textures in the game to look incorrect, but it DOES fix the long loading time issue. So, this is part of the problem, if not the whole problem!</p><h1 id=how-to-fix-this>How to Fix This?</h1><p>You might look at the above code and think: can&rsquo;t we just read the pixel data as a single block of memory, rather than reading one byte at a time? We can! This code reads in the whole image in one fell swoop, and it&rsquo;s a lot faster:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Just read the pixel data in one giant block!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mPixels</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>uint8_t</span><span class=p>[</span><span class=n>mWidth</span> <span class=o>*</span> <span class=n>mHeight</span> <span class=o>*</span> <span class=n>mBytesPerPixel</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>reader</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>mPixels</span><span class=p>,</span> <span class=n>mWidth</span> <span class=o>*</span> <span class=n>mHeight</span> <span class=o>*</span> <span class=n>mBytesPerPixel</span><span class=p>);</span>
</span></span></code></pre></div><p>But before we celebrate, let&rsquo;s realize we&rsquo;re overlooking some important details:</p><ol><li><p>The inefficient code has logic to skip padding bytes that may be present. This more efficient approach includes padding bytes in the pixel data.</p></li><li><p>The inefficient code changes the pixel component order as each pixel is read in. The BMP format stores pixel data in blue/green/red (BGR) order, but the code in the <code>Texture</code> class assumes red/greed/blue/alpha (RGBA) order. The efficient code is not changing the pixel component order.</p></li><li><p>The inefficient code flips the pixel array as it reads in the data. BMP files store pixel data from the bottom-left corner, but this <code>Texture</code> class stores pixel data from the top-left corner. The efficient code is not performing this flip.</p></li></ol><p>To use the efficient code, we need to find ways to address each of these problems - either by addressing them or avoiding them entirely. Let&rsquo;s consider if there&rsquo;s any way we can overcome these challenges and achieve blazing fast loading of large BMP files!</p><h1 id=dealing-with-padding-bytes>Dealing with Padding Bytes</h1><p>BMP files store pixel data in rows. If an image has a height of 512, it means there are 512 rows of pixel data in the image. Each row of pixel data must be 4-byte aligned. If the byte size of a row is not divisible by 4, padding bytes are added.</p><p>A simple way to solve this problem (and perhaps the preferred way) is to simply leave the padding bytes present. Graphics APIs can account for these padding bytes, and OpenGL actually uses 4-byte alignment by default. DirectX seems to have a strong preference for 4-byte alignment, and it&rsquo;s even required in newer versions.</p><p>For the current task though, I decided to remove padding bytes. Why? Well, it&rsquo;s a combination of things:</p><ol><li><p>When I first wrote the <code>Texture</code> class, I didn&rsquo;t realize you could just leave the padding bytes and pass them to the GPU - they seemed like an archaic aspect of BMP files, as opposed to a common convention supported by the graphics APIs. So, chalk this up to not knowing what I was doing.</p></li><li><p>Over time, many of the algorithms in the <code>Texture</code> class for manipulating pixel data do not account for padding bytes. This could be refactored (and perhaps I will do so in the future). But to solve the current problem at hand, I&rsquo;d like to avoid making that change right now.</p></li></ol><p>If we don&rsquo;t want padding bytes, their presence throws a wrench in our efficient block-copy approach. Fortunately though, we can calculate whether padding bytes will be present. If the number of bytes needed to store a row is divisible by 4, we won&rsquo;t have padding!</p><p>For example, consider a 32-bit image, which has 4 bytes per pixel. Such an image is ALWAYS 4-byte aligned, so no padding will ever be needed. On the other hand, a 24-bit (3 bytes per pixel) BMP image <em>may</em> need padding. If the width is 1024, it turns out that the byte count <code>(3 * 1024)</code> is divisible by 4. If the width was 1025, it would no longer be divisible by 4, requiring padding bytes.</p><p>All the BMPs in GK3 are 24-bit (3 bytes per pixel), so 4-byte alignment is not guaranteed. Fortunately, 24-bit BMP images are always aligned if the width is a power-of-two greater than or equal to four. Widths of 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048 (and so on) give us no padding bytes to deal with.</p><p>And wouldn&rsquo;t you know it: <em>almost</em> all of GK3&rsquo;s BMP files use power-of-two widths. So, such files can take the optimized &ldquo;block copy&rdquo; approach. Fortunately, the hi-res mod follows suit and still uses power-of-two widths as well.</p><p>What if we encounter an image with padding bytes? Our parsing code needs to be able to handle both scenarios:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>if</span><span class=p>(((</span><span class=n>mBytesPerPixel</span> <span class=o>*</span> <span class=n>mWidth</span><span class=p>)</span> <span class=o>%</span> <span class=mi>4</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reader</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>mPixels</span><span class=p>,</span> <span class=n>mWidth</span> <span class=o>*</span> <span class=n>mHeight</span> <span class=o>*</span> <span class=n>mBytesPerPixel</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl><span class=p>{</span>    
</span></span><span class=line><span class=cl>    <span class=c1>// Use a less efficient approach that reads line-by-line.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>There&rsquo;s one final thing to do, which is to ensure the graphics API is configured to allow pixel data that is not 4-byte aligned. As mentioned earlier, OpenGL assumes 4-byte alignment by default, but you can call <code>glPixelStorei(GL_UNPACK_ALIGNMENT, 1)</code>, which then allows 1-byte alignment. I&rsquo;m not sure of the equivalent in DirectX - it may actually be required to instead keep padding bytes in that case.</p><h1 id=dealing-with-pixel-formats>Dealing with Pixel Formats</h1><p>For simplicity, the <code>Texture</code> class (as originally written) always stored pixel data in RGBA order. Since BMP files store pixel data in BGR order, one function of the inefficient code was to reorder the pixel data. How can we do this when we use an efficient block copy?</p><p>In this case, I had to rethink my assumption of always storing pixel data internally in RGBA format. Doing so simplifies some pixel manipulation code, but it now seems to be negatively impacting performance.</p><p>So yes, the solution I employed was to drop the requirement that the internal pixels array always be in RGBA order. We store the pixel data as a byte buffer, but we also store the format of that byte buffer separately.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>Format</span> <span class=o>:</span> <span class=kt>uint8_t</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 24 bpp
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BGR</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RGB</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 32 bpp
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BGRA</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RGBA</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The number of bytes per pixel for this image.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint8_t</span> <span class=n>mBytesPerPixel</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The format of the pixel data. This matches exactly the data stored in the pixels array.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Format</span> <span class=n>mFormat</span> <span class=o>=</span> <span class=n>Format</span><span class=o>::</span><span class=n>RGBA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Pixel data, from the top-left corner of the image.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint8_t</span><span class=o>*</span> <span class=n>mPixels</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span></code></pre></div><p>The effect of this change is that the data in the <code>mPixels</code> array can&rsquo;t always be treated as RGBA data. When a <code>Texture</code> is created from a BMP image, the format is going to be <code>Format::BGR</code>. The PNG decoder generates RGBA pixels, so the format for a <code>Texture</code> created from a PNG image will have the format <code>Format::RBGA</code>.</p><p>Functions that deal with texture manipulation become more complex, since the pixel data may be either 3 or 4 bytes per pixel, and the pixel components may be in different orders. <code>Texture::SetColor</code> and <code>Texture::GetColor</code> functions are more complex because the exact code required depends on the format. Functions like <code>Texture::FlipVertically</code> now need to deal with various byte-per-pixel counts. A function like <code>Texture::BlendPixels</code> (which blends one texture&rsquo;s pixels into another texture&rsquo;s pixels) is now limited to only work if the texture formats are the same. If a function like <code>Texture::ApplyAlphaMask</code> is called on a non-RGBA image, the image must be converted to RGBA format. Functions to convert between formats can also become fairly complex.</p><p>Finally, when creating textures in OpenGL (or other graphics systems), you can no longer assume RGBA format. When creating a texture in the graphics system, you must specify the correct format. In OpenGL, when creating the texture with <code>glTexImage2D</code>, this means the format argument is sometimes GL_BGR, sometimes GL_RGBA, sometimes GL_BGRA, etc.</p><h1 id=dealing-with-pixel-order>Dealing with Pixel Order</h1><p>As mentioned earlier, BMP files store pixel data starting at the bottom-left corner and going up. But the <code>Texture</code> class assumes pixel data is stored starting at top-left and going down. Clearly this conflict ruins the efficient block-copy plan. Or does it?</p><p>One possible way to solve this problem is to remove the requirement that <code>mPixels</code> must store data from the top-left corner - could we store the &ldquo;texture origin&rdquo; as a separate variable? Unfortunately, I think this approach would be too complex and likely error-prone: pixel data sent to the graphics system would be inconsistently ordered, but all UVs would be the same. The result would be chaos. A system where UVs are flipped depending on what texture is being used, while possible, seems complicated and convoluted.</p><p>Another idea is to simply change the <code>Texture</code> class&rsquo;s assumption of starting at the top-left corner and instead align with the BMP format. This <em>could</em> work, but we&rsquo;ll encounter conflicts where other image formats store from top-left. For example, PNG files store pixel data from top-left - since we support both BMP and PNG imports, we can&rsquo;t satisfy everyone!</p><p>The actual solution used seems non-ideal, but actually works OK: I just read in the pixel data using the efficient block-copy, and then I vertically flip the image:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>reader</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>mPixels</span><span class=p>,</span> <span class=n>mWidth</span> <span class=o>*</span> <span class=n>mHeight</span> <span class=o>*</span> <span class=n>mBytesPerPixel</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>FlipVertically</span><span class=p>();</span>
</span></span></code></pre></div><p>The initial reaction might be that this is terribly inefficient. But in practice, it works well, even with larger image files. A vertical flip only needs to iterate half the image&rsquo;s height, and the flip itself can be done pretty efficiently. I see some opportunities to optimize the <code>FlipVertically</code> function - but even without those optimizations, it performs quite well.</p><h1 id=results>Results</h1><p>Qualitatively, the optimized code runs a lot faster. Whereas the hi-res mod previously had a noticeable delay when loading into a new scene, it now appears to load as quickly as the unmodded game. Even if it is slower (since there is certainly more work to do when more pixels are present), it isn&rsquo;t <em>noticeably</em> slower.</p><p>Using a stopwatch class, I also measured the actual time difference between the normal and modded game with the inefficient and optimized versions of the code. Here are some readings from my desktop (AMD Ryzen 7 9700X) in Release mode. These readings measure the time required to load the first scene of the game when hitting the &ldquo;Play&rdquo; button from the title screen:</p><table><thead><tr><th>Test</th><th>Time</th></tr></thead><tbody><tr><td>Unmodded, Unoptimized</td><td>0.187 seconds</td></tr><tr><td>Unmodded, Optimized</td><td>0.187 seconds</td></tr><tr><td>Modded, Unoptimized</td><td>2.986 seconds</td></tr><tr><td>Modded, Optimized</td><td>0.253 seconds</td></tr></tbody></table><h1 id=conclusion>Conclusion</h1><p>At first glance, the lesson from this investigation is something most programmers already know: reading/copying data in a large block is more efficient than reading/copying data byte by byte. The compiler is able to greatly optimize straightforward data reads/copies. Prefer such reads/copies when possible.</p><p>I think there&rsquo;s also a lesson here about premature optimization. Sure, the unoptimized code presented in this article needed to be improved, but it was &ldquo;good enough&rdquo; for several years. It was appropriate for the data set it was authored for. But when the data set changed, the code needed to be optimized.</p><p>And sometimes you think a solution won&rsquo;t work because it&rsquo;ll be &ldquo;too slow&rdquo;, but then you try it, and it actually works fine for the use case. The idea of &ldquo;vertically flipping&rdquo; the image data after loading is an example of this. A brute force approach can be effective, so don&rsquo;t discount it. At least try it, use it as a starting point, and you can optimize from there!</p><p>Finally, I think investigating and solving this problem gave me some insight into why game engines handle textures the way they do, and why it&rsquo;s pretty reasonable to support storing pixel data in multiple formats instead of &ldquo;forcing&rdquo; the internal format to always be RGBA. Though these changes make the <code>Texture</code> class more complex, they also clearly improve performance, and I think they move the class closer to being a more fleshed out general-purpose implementation.</p><div class=blog-tags><a href=https://clarkkromenaker.com//tags/c++/>C++</a>&nbsp;
<a href=https://clarkkromenaker.com//tags/opengl/>OpenGL</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://clarkkromenaker.com/post/library-dynamic-loading-linux/ data-toggle=tooltip data-placement=top title="Loading Shared Libraries on Linux">&larr; Previous Post</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2025</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://clarkkromenaker.com/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>