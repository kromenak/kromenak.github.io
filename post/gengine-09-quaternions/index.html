<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>G-Engine #9: Quaternions - Clark Kromenaker</title>
<meta name=description content="Way back in 
G-Engine #4, we rendered a triangle, and there was much rejoicing. Since then, the posts in this series have primarily focused on implementing mathematical constructs in code. This point is the final math pre-requisite before we can move on to more interesting things.
Think of a game engine as its own little universe: at first, there is nothing - the void. Concepts such as time, position, and orientation don&rsquo;t exist yet. Suddenly, the game loop and delta time introduces the concept of time. With vectors, we can convey positions, directions, and distances. Slowly, our universe takes shape and we can convey important concepts in code.
But what about rotations? Vectors can store position, direction, and scale data, but they are not effective structures for 3D rotations. We need some other option to convey rotations in code.
One structure that is very effective for 3D rotations is the Quaternion. Much-maligned for their apparant complexity, Quaternions allow us to efficiently store and use 3D rotation data. In this post, we&rsquo;ll explore why we use quaternions, what they are, how to perform common operations with them, and finally I&rsquo;ll provide some tips for writing your own Quaternion class."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"http:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"http:\/\/clarkkromenaker.com\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http:\/\/clarkkromenaker.com\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"http:\/\/clarkkromenaker.com\/post\/gengine-09-quaternions\/","name":"G engine #9 quaternions"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"G-Engine #9: Quaternions","description":"Way back in G-Engine #4, we rendered a triangle, and there was much rejoicing. Since then, the posts in this series have primarily focused on implementing mathematical constructs in code. This point is the final math pre-requisite before we can move on to more interesting things.\nThink of a game engine as its own little universe: at first, there is nothing - the void. Concepts such as time, position, and orientation don\u0026rsquo;t exist yet. Suddenly, the game loop and delta time introduces the concept of time. With vectors, we can convey positions, directions, and distances. Slowly, our universe takes shape and we can convey important concepts in code.\nBut what about rotations? Vectors can store position, direction, and scale data, but they are not effective structures for 3D rotations. We need some other option to convey rotations in code.\nOne structure that is very effective for 3D rotations is the Quaternion. Much-maligned for their apparant complexity, Quaternions allow us to efficiently store and use 3D rotation data. In this post, we\u0026rsquo;ll explore why we use quaternions, what they are, how to perform common operations with them, and finally I\u0026rsquo;ll provide some tips for writing your own Quaternion class.\n","inLanguage":"en","wordCount":3630,"datePublished":"2020-10-16T00:00:00","dateModified":"2020-10-16T00:00:00","image":"http:\/\/clarkkromenaker.com\/img\/avatar-icon.png","keywords":["G-Engine, C\u002b\u002b, Math"],"mainEntityOfPage":"http:\/\/clarkkromenaker.com\/post\/gengine-09-quaternions\/","publisher":{"@type":"Organization","name":"http:\/\/clarkkromenaker.com\/","logo":{"@type":"ImageObject","url":"http:\/\/clarkkromenaker.com\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="G-Engine #9: Quaternions"><meta property="og:description" content="Way back in 
G-Engine #4, we rendered a triangle, and there was much rejoicing. Since then, the posts in this series have primarily focused on implementing mathematical constructs in code. This point is the final math pre-requisite before we can move on to more interesting things.
Think of a game engine as its own little universe: at first, there is nothing - the void. Concepts such as time, position, and orientation don&rsquo;t exist yet. Suddenly, the game loop and delta time introduces the concept of time. With vectors, we can convey positions, directions, and distances. Slowly, our universe takes shape and we can convey important concepts in code.
But what about rotations? Vectors can store position, direction, and scale data, but they are not effective structures for 3D rotations. We need some other option to convey rotations in code.
One structure that is very effective for 3D rotations is the Quaternion. Much-maligned for their apparant complexity, Quaternions allow us to efficiently store and use 3D rotation data. In this post, we&rsquo;ll explore why we use quaternions, what they are, how to perform common operations with them, and finally I&rsquo;ll provide some tips for writing your own Quaternion class."><meta property="og:image" content="http://clarkkromenaker.com/img/avatar-icon.png"><meta property="og:url" content="http://clarkkromenaker.com/post/gengine-09-quaternions/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="G-Engine #9: Quaternions"><meta name=twitter:description content="Way back in 
G-Engine #4, we rendered a triangle, and there was much rejoicing. Since then, the posts in this series have primarily focused on implementing mathematical constructs in code. This point …"><meta name=twitter:image content="http://clarkkromenaker.com/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=http://clarkkromenaker.com/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=http://clarkkromenaker.com/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=http://clarkkromenaker.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=http://clarkkromenaker.com/css/syntax.css><link rel=stylesheet href=http://clarkkromenaker.com/css/codeblock.css><link rel=stylesheet href=http://clarkkromenaker.com//css/portfolio.css><link rel=stylesheet href=http://clarkkromenaker.com//css/misc.css><link rel=stylesheet href=http://clarkkromenaker.com//css/overrides.css><script src=http://clarkkromenaker.com//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=http://clarkkromenaker.com/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=http://clarkkromenaker.com/><img class=avatar-img src=http://clarkkromenaker.com/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>G-Engine #9: Quaternions</h1><span class=post-meta><i class=fas></i>Posted on October 16, 2020</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>Way back in
<a href=/post/gengine-04-rendering>G-Engine #4</a>, we rendered a triangle, and there was much rejoicing. Since then, the posts in this series have primarily focused on implementing mathematical constructs in code. This point is the final math pre-requisite before we can move on to more interesting things.</p><p>Think of a game engine as its own little universe: at first, there is nothing - the void. Concepts such as time, position, and orientation don&rsquo;t exist yet. Suddenly, the game loop and delta time introduces the concept of time. With vectors, we can convey positions, directions, and distances. Slowly, our universe takes shape and we can convey important concepts in code.</p><p>But what about rotations? Vectors can store position, direction, and scale data, but they are not effective structures for 3D rotations. We need some other option to convey rotations in code.</p><p>One structure that is very effective for 3D rotations is the <strong>Quaternion</strong>. Much-maligned for their apparant complexity, Quaternions allow us to efficiently store and use 3D rotation data. In this post, we&rsquo;ll explore why we use quaternions, what they are, how to perform common operations with them, and finally I&rsquo;ll provide some tips for writing your own <code>Quaternion</code> class.</p><h1 id=rotation-basics>Rotation Basics</h1><p>A 3D rotation can be defined in terms of two pieces of information: the <strong>axis of rotation</strong> and the <strong>angle of rotation</strong>.</p><p>For example, if you stand up and turn your head to the left or right, the axis of rotation points straight up in the air and the angle of rotation will be either a positive or negative number depending on which direction and how far you turned your head.</p><p>Rotations are commonly described like so: &ldquo;a rotation of A units about the X axis.&rdquo; In that description, the axis of rotation is the X axis, and the angle of rotation is A.</p><p>Usually, a rotation angle&rsquo;s units will be either degrees or radians. A full rotation is 360 degrees or 2π radians. A half rotation is 180 degrees or π radians. The
<a href=https://upload.wikimedia.org/wikipedia/commons/4/4c/Unit_circle_angles_color.svg target=_blank>unit circle</a> can be helpful to visualize the full range of angles.</p><p>The coordinate axes X, Y, and Z are commonly used as axes of rotation. However, any unit-length vector can be used as an axis of rotation. For example, <code>(0.707, 0.707, 0)</code> is an axis halfway between the X and Y axes.</p><h2 id=what-does-a-rotation-do>What Does a Rotation Do?</h2><p>Conceptually, a rotation changes an object&rsquo;s orientation. If you are facing north, and you &ldquo;rotate 90 degrees about the up axis&rdquo;, you&rsquo;ll be facing west (assuming that positive angles are counter-clockwise). A rotation is <strong>applied</strong> to an object to change its orientation.</p><p>In a virtual world, changing an object&rsquo;s orientation means changing its facing direction or its position. When the object is a 3D model, this means that each of the model&rsquo;s vertices are rotated. Generally, we can say that rotations in a 3D world primarily function by modifying a vector in some way (since we usually respresent positions and directions using vectors).</p><p>When a rotation is applied to a vector, the portion of the vector that is parallel to the axis of rotation does not change, but the portion that is perpendicular to the axis does change. Though we describe rotations as being &ldquo;about&rdquo; an axis, the rotation actually affects everything on the 2D plane perpendicular to the axis.</p><h2 id=handedness>Handedness</h2><p>In the earlier example about facing north and rotating 90 degrees, it was unclear whether you&rsquo;d end up facing east or west after rotation unless you specify whether positive angles are clockwise or counter-clockwise.</p><p>This decision speaks to the <strong>handedness</strong> of the rotation. It is so-called because you can choose either a &ldquo;left-handed&rdquo; system or a &ldquo;right-handed&rdquo; system. In a left-handed system, positive angles are clockwise. In a right-handed system, positive angles are counter-clockwise.</p><p>The concept of handedness comes from a handy (hah) method of remembering what convention is being used: point your thumb in the direction of the axis of rotation; your fingers curl in the direction of a positive rotation. If you point your thumb/axis towards your face, your fingers curl clockwise on your left hand and counter-clockwise on your right hand.</p><p>Handedness is a topic we briefly touched on when discussing the cross product, and we will discuss it again in more detail when we dig into transforms and coordinate systems in a future post.</p><h1 id=rotation-representations>Rotation Representations</h1><p>In 2D, a rotation can be represented by a single <code>float</code> value (the angle of rotation). A 2D game only has one 2D plane to rotation, so there&rsquo;s only one possible axis of rotation!</p><p>In 3D, a rotation can occur about any of the three coordinate axes or an arbitrary axis. The possible rotations are more vast than in 2D, so the method for representing them also becomes more complex.</p><p>There are a few different methods we <em>could</em> use to represent 3D rotations. But what makes a good representation? The primary criteria are:</p><ul><li>Doesn&rsquo;t take up too much memory.</li><li>Concatenating multiple rotations into a single rotation should be efficient.</li><li>Rotating a vector should be efficient.</li><li>Converting to and from matrix form should be efficient.</li></ul><p>Some secondary criteria worth considering:</p><ul><li>When animating objects, rotations need to be interpolated. So, interpolating ought to be correct and efficient.</li><li>A physics simulation can affect an object&rsquo;s rotation. So, a representation that can be easily used in numeric integration would be nice.</li></ul><p>Based on these criteria, let&rsquo;s briefly discuss a few possible representation options: Euler angles, axis/angles, matrices, and finally quaternions.</p><h2 id=euler-angle-representation>Euler Angle Representation</h2><p>Perhaps the most intuitive way to represent a 3D rotation is with three <code>float</code> values, each representing an angle of rotation about the x, y, and z coordinate axes. This seems like a natural extension of a 2D rotation.</p><p>This representation has two benefits: it takes up little memory, and it is fairly intuitive. But otherwise, this representation has some downsides.</p><p>Concatenating rotations and rotating vectors are not straightforward or efficient operations. Interpolating between rotations also doesn&rsquo;t work correctly. Converting to and from matrix representation is not efficient and has some limitations. This representation also suffers from a phenomonon called
<a href=https://en.wikipedia.org/wiki/Gimbal_lock#Loss_of_a_degree_of_freedom_with_Euler_angles target=_blank>gimbal lock</a>.</p><p>Because Euler angles are so intuitive and easy to visualize, they are often used in 3D modeling package and commercial game engine interfaces to specify rotations. However, they are usually converted to/from another internal format to avoid the problems outlined above.</p><h2 id=axisangle-representation>Axis/Angle Representation</h2><p>Another way to represent a 3D rotation is by specifying an axis of rotation and a rotation about that axis. Using this method, it is possible to represent any 3D rotation using just four <code>float</code> values (three for the axis vector, one for the angle).</p><p>This representation doesn&rsquo;t suffer from gimbal lock and it only uses four <code>float</code> values. However, it still has a lot of the problems of Euler angles: concatenating rotations and rotating vectors are both inefficient. Converting to matrix form is doable, but converting back has some limitations.</p><p>The <em>idea</em> of axis/angle is powerful, easy to understand, and easy to visualize. If only we could use the axis/angle concept with a more efficient structure&mldr; <em>(mysterious music and foreshadowing)</em></p><h2 id=matrix-representation>Matrix Representation</h2><p>3D graphics APIs require that scale, rotation, and translation data be provided in a matrix structure, so it seems reasonable to just store rotations in a matrix directly and be done with it.</p><p>Actually, this is not a bad idea! A matrix allows us to concatenate rotations and rotate vectors efficiently using matrix multiplication. Matrices also interpolate pretty well, and they can be used in physics simulations. And obviously, there&rsquo;s no need to convert to/from matrix form in this case!</p><p>Matrices do take up more space than other options. A 3D rotation requires a 3x3 matrix, or nine <code>float</code> values.</p><p>Matrices tick a lot of our boxes, but quaternions usually edge them out by being somewhat more performance and memory efficient. Position and scale are represented as vectors before being converting to matrix form for the rendering system - rotations can also benefit from an intermediate representation.</p><h2 id=quaternion-representation>Quaternion Representation</h2><p>Quaternions are fairly complex mathematical objects, but when used to represent rotations, you can think of them as axis/angle rotations. Quaternions allow us to use the <em>idea</em> of axis/angle representation, but take advantage of a more efficient structure.</p><p>The benefits of quaternions include:</p><ul><li>Memory efficient, at only four <code>float</code> values.</li><li>Concatenating rotations is efficient.</li><li>Rotating a vector is (fairly) efficient.</li><li>Converting to and from matrix form is efficient.</li><li>Interpolation works well and is more efficient than matrix interpolation.</li><li>They work well in physics simulations.</li></ul><p>There are two downsides to quaternions. First, the math is somewhat obtuse and difficult to understand. Second, vector rotation is slightly less efficient than in matrix form - if you need to rotate a lot of vectors, consider converting to matrix form first.</p><p>Because of the benefits quaternions provide and the minimal downsides, they are commonly used in game engines, and they&rsquo;re what I&rsquo;ll spend the rest of this post discussing.</p><h1 id=what-is-a-quaternion>What is a Quaternion?</h1><p>Quaternions were originally divised as a way to work with
<a href=https://en.wikipedia.org/wiki/Complex_number target=_blank>complex numbers</a>. If, like me, you are rusty with complex numbers, that&rsquo;s OK! Quaternions used as rotations do not require a deep knowledge of complex numbers.</p><p>A quaternion consists of four values: x, y, z, w. The <code>(x, y, z)</code> portion is called the <strong>vector part</strong> and <code>w</code> is called the <strong>scalar part</strong>.</p><p>The vector part <em>roughly</em> correlates to an axis of rotation, while the scalar part <em>roughly</em> correlates to an angle of rotation. The axis and angle data are encoded in these values, but some math is required to extract them.</p><p>A quaternion may seem similar to a 4D vector - both consist of four <code>float</code> values called x, y, z, w. Though not interchangeable, it&rsquo;s true that some quaternion operations behave just like vector operations, and they even share some of the same terminology.</p><h1 id=quaternion-operations>Quaternion Operations</h1><p>Fortunately, there are only a few quaternion operations that we need to define to use them for 3D rotations.</p><h2 id=addition-and-subtraction>Addition and Subtraction</h2><p>Let&rsquo;s start with something simple: to add and subtract quaternions, simply add or subtract corresponding components.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=o>-</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>7</span><span class=p>)</span>
</span></span></code></pre></div><p>You might expect that adding two rotation quaternions together would concatenate the two rotations, but that isn&rsquo;t the case.</p><h2 id=multiplication>Multiplication</h2><p>Multiplying two rotation quaternions has the effect of concatenating the rotations. So, it&rsquo;s a pretty important operation!</p><p>Quaternions have unique multiplication rules that also act as their defining characteristic.
<a href=https://en.wikipedia.org/wiki/Quaternion#Multiplication_of_basis_elements target=_blank>This wikipedia section</a> explains the multiplication rules in a pretty digestible way (keeping in mind the imaginary number equality <em>i</em> <sup>2</sup> = -1).</p><p>Given two quaternions <code>q1</code> and <code>q2</code>, consider the vector parts and scalar parts separately. Say <code>q1.v</code> refers to the vector part and <code>q1.s</code> refers to the scalar part.</p><p>Multiplication can then be performed like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>result.v <span class=o>=</span> <span class=o>(</span>q1.v ⨯ q2.v<span class=o>)</span> + <span class=o>(</span>q1.s * q2.v<span class=o>)</span> + <span class=o>(</span>q2.s * q1.v<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>result.s <span class=o>=</span> <span class=o>(</span>q1.s * q2.s<span class=o>)</span> - <span class=o>(</span>q1.v • q2.v<span class=o>)</span><span class=p>;</span>
</span></span></code></pre></div><p>In other words, the result&rsquo;s vector part is calculated by summing three things:</p><ul><li>Cross product of the two vector parts.</li><li><code>q1</code>&rsquo;s scalar part multiplied by <code>q2</code>&rsquo;s vector part</li><li><code>q2</code>&rsquo;s scalar part multiplied by <code>q1</code>&rsquo;s vector part</li></ul><p>And the result&rsquo;s scalar part is the product of the two scalar parts minus the dot product of the two vector parts.</p><p>The order of multiplication affects the result. <code>q1 * q2</code> has the effect of rotating by <code>q2</code> and then by <code>q1</code>; <code>q2 * q1</code> has the effect of rotation by <code>q1</code> and then <code>q2</code>. In other words, concatenated rotations occur in right-to-left order.</p><h2 id=length-and-normalization>Length and Normalization</h2><p>In this regard, vectors and quaternions share behavior and terminology. You can calculate the length of a quaternion using the Pythagorean theorem:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>length</span> <span class=o>=</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>x</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=n>z</span> <span class=o>*</span> <span class=n>z</span> <span class=o>+</span> <span class=n>w</span> <span class=o>*</span> <span class=n>w</span><span class=p>);</span>
</span></span></code></pre></div><p>A <strong>unit quaternion</strong> has a length of <code>1</code>. To normalize, divide each component of the quaternion by the quaternion&rsquo;s length.</p><p>Quaternions used for 3D rotations should always be unit length. This usually makes the math simpler and more efficient. But it also means that accidentally using a non-unit quaternion will give incorrect results.</p><p>Multiplying two unit-length quaternions always results in another unit-length quaternion. But be careful of other operations that might de-normalize the quaternion (many floating-point operations or interpolation). If a quaternion has recently been subjected to a lot of operations, it may be a good idea to normalize it before using it to rotate something.</p><h2 id=scalar-multiplication>Scalar Multiplication</h2><p>As with vectors, you can multiply a quaternion by a scalar value, which multiplies each component by the scalar value and affects the length of the quaternion.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=mi>5</span> <span class=o>*</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span> <span class=o>*</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>5</span> <span class=o>*</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>5</span> <span class=o>*</span> <span class=mf>0.5</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=mi>15</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>40</span><span class=p>,</span> <span class=mf>2.5</span><span class=p>)</span>
</span></span></code></pre></div><p>You might expect that negating a quaternion (multiplying by <code>-1</code>) would negate the rotation it represents. But actually, a negated quaternion represents the <em>exact same</em> rotation as the original quaternion!</p><p>Negation will negate both the axis of rotation and the angle of rotation. Imagine a counter-clockwise rotation about an axis. Negating the axis causes the angle of rotation to flip to clockwise. But negating the angle causes the angle to flip <em>again</em> back to counter-clockwise!</p><p>If we want to actually negate a rotation, we have to negate the axis or the angle, but not both. To do this, we can use quaternion inversion.</p><h2 id=inversion>Inversion</h2><p>As with matrices, multiplying a quaternion by its inverse gives us the <strong>Identity quaternion</strong>, which has a vector part of <code>(0, 0, 0)</code> and a scalar part of <code>1</code>.</p><p>If a quaternion represents a rotation about an axis, the inverse represents the opposite rotation about that axis. The inverse undoes the rotation performed by the original quaternion.</p><p>Fortunately, the inverse is simple to calculate for quaternions.</p><p>Quaternions have a concept borrowed from complex numbers called the <strong>conjugate</strong>. A quaternion&rsquo;s conjugate has the same scalar part, but the vector part is negated.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>conjugate</span><span class=p>.</span><span class=n>v</span> <span class=o>=</span> <span class=o>-</span><span class=n>q</span><span class=p>.</span><span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>conjugate</span><span class=p>.</span><span class=n>s</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>s</span><span class=p>;</span>
</span></span></code></pre></div><p>A quaternion&rsquo;s inverse can then be calculated as <code>conjugate / lengthSquared</code>. Since the quaternions we use for rotations are unit length, this equation simplifies: <strong>a unit-length quaternion&rsquo;s inverse is equal to its conjugate!</strong></p><p>Negating only the axis via inversion causes the angle to negate, which is exactly what we want in order to calculate an opposite rotation.</p><h2 id=vector-rotation>Vector Rotation</h2><p>Applying a quaternion to a vector causes the vector to rotate about the axis. As described previously, the portion of the vector that is perpendicular to the axis of rotation is modified, while the parallel part does not change.</p><p>To rotate a 3D vector using a quaternion, we first treat the vector as though it was a quaternion with a <code>w</code> value of zero. We can then use quaternion multiplication to rotate the vector using this equation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>rotatedVector</span> <span class=o>=</span> <span class=n>quat</span> <span class=o>*</span> <span class=n>vector</span> <span class=o>*</span> <span class=n>quatInverse</span><span class=p>;</span>
</span></span></code></pre></div><p>In other words:</p><ol><li>Multiply the vector by the quaternion.</li><li>Multiply the result by the quaternion&rsquo;s inverse.</li></ol><p>This somewhat unusual structure is called a <strong>sandwich product</strong> because the vector is &ldquo;sandwiched&rdquo; between the quaternion and the quaternion&rsquo;s inverse.</p><p>The reason this causes the vector to be rotated correctly involves some fairly complex mathematical manipulation - I recommend one of the resources mentioned at the end of this post if you&rsquo;re interested in learning more.</p><h1 id=conversions>Conversions</h1><p>Quaternions are efficient, but the problem remains that other representations like Euler angles and axis/angle format are easier to manipulate and debug. We must also be able to convert to matrix form to send rotation data to the rendering system.</p><p>So, let&rsquo;s discuss how we can convert between quaternions and other representations.</p><h2 id=axisangle-conversion>Axis/Angle Conversion</h2><p>If the vector rotation equation is expanded and some substitutions are performed, you end up with this equality:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>quaternion</span> <span class=o>=</span> <span class=n>sin</span><span class=p>(</span><span class=n>angle</span><span class=o>/</span><span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=n>axis</span> <span class=o>+</span> <span class=n>cos</span><span class=p>(</span><span class=n>angle</span><span class=o>/</span><span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><p>This tells us a few interesting things:</p><ul><li>The scalar part <code>w</code> of a quaternion is equal to <code>cos(angle/2)</code>.</li><li>The vector part <code>(x, y, z)</code> of a quaternion is equal to <code>axis * sin(angle/2)</code>.</li><li>The length of the vector part is <code>sin(angle/2)</code>.</li></ul><p>Using this, we have a fairly simple way to create a quaternion from an axis and an angle:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Assuming the axis is normalized...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>q</span><span class=p>.</span><span class=n>s</span> <span class=o>=</span> <span class=n>cos</span><span class=p>(</span><span class=n>angle</span> <span class=o>*</span> <span class=mf>0.5f</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>q</span><span class=p>.</span><span class=n>v</span> <span class=o>=</span> <span class=n>sin</span><span class=p>(</span><span class=n>angle</span> <span class=o>*</span> <span class=mf>0.5f</span><span class=p>)</span> <span class=o>*</span> <span class=n>axis</span><span class=p>;</span>
</span></span></code></pre></div><p>To do the opposite (quaternion to axis/angle), we just need to reverse this math:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>angle</span> <span class=o>=</span> <span class=n>acos</span><span class=p>(</span><span class=n>q</span><span class=p>.</span><span class=n>s</span><span class=p>)</span> <span class=o>*</span> <span class=mf>2.0f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>axis</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>v</span> <span class=o>/</span> <span class=n>sin</span><span class=p>(</span><span class=n>angle</span> <span class=o>*</span> <span class=mf>0.5f</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=euler-angles-conversion>Euler Angles Conversion</h2><p>Each Euler angle is a rotation about the X/Y/Z coordinate axes - represent each one as an axis/angle. From there, generate one quaternion per axis. Finally, concatenate the three quaternions to get the final quaternion.</p><p>Converting from a quaternion to Euler angles is not inefficient, but it is complex. I&rsquo;m not sure I could fully explain these equations if I tried! See
<a href=https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles target=_blank>this wikipedia page</a> for full details, and of course the G-Engine source code for source code.</p><h2 id=matrix-conversion>Matrix Conversion</h2><p>Converting a matrix to a quaternion exploits some fortunate observations about the matrix format:</p><ol><li>The trace of a rotation matrix (the sum of diagonal elements) equals <code>2 * cos(θ) + 1</code>. We&rsquo;ll use this as the scalar part of the quaternion.</li><li>Subtracting certain symmetric elements of a rotation matrix for each component of a vector gives us <code>2 * sin(θ) * axis</code>. We&rsquo;ll use this as the vector part of the quaternion.</li></ol><p>These two pieces of data are very close, but not quite, the data required to calculate a quaternion from an axis/angle. To get it in the right form, it&rsquo;s actually possible to simply:</p><ol><li>Add <code>1</code> to the scalar part (resulting in <code>2 * cos(θ) + 2</code>).</li><li>Normalize the quaternion.</li></ol><p>And that&rsquo;s it! Surprisingly, these operations cause the quaternion to fit the equation mentioned in the axis/angle section above, and we&rsquo;re good to go.</p><p>Converting a quaternion to a matrix simply requires populating each entry in the matrix using specific values from the quaternion. The values required for each entry are outlined
<a href=https://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToMatrix/index.htm target=_blank>here</a>.</p><h1 id=writing-a-quaternion-class>Writing a Quaternion Class</h1><p>Unlike vectors and matrices, we only need one quaternion class. The class should support at least the following operations:</p><ul><li>Construction, Copy Construction, and Assignment</li><li>Equality checks</li><li>Addition and subtraction</li><li>Quaternion multiplication</li><li>Scalar multiplication</li><li>Length calculation and normalization</li><li>Inverse calculation</li><li>Vector rotation</li><li>Extraction of axis/angle and euler angles</li></ul><p>You can view the G-Engine quaternion class
<a href=https://github.com/kromenak/gengine/blob/master/Source/Quaternion.h target=_blank>header</a> and
<a href=https://github.com/kromenak/gengine/blob/master/Source/Quaternion.cpp target=_blank>source</a>.</p><p>Next, I&rsquo;ll highlight some considerations when writing a quaternion class.</p><h2 id=naming>Naming</h2><p>I decided to name my class <code>Quaternion</code> (shocking, I know). If you don&rsquo;t like typing, I&rsquo;ve also seen <code>Quat</code> used. As always, we want the name to be clear!</p><h2 id=data-layout>Data Layout</h2><p>Like a 4D vector, the x/y/z/w elements should all be <code>float</code> values, and they should be laid out sequentially in memory. There should be no other data members in the class.</p><h2 id=constructors--accessors>Constructors & Accessors</h2><p>You want this class to hide the internal complexity of quaternion math and expose an easy to use public interface. This allows developers to use quaternions to perform rotations without having to understand everything happening under the hood.</p><p>One way you can do this is by providing a set of constructors that allow you to generate quaternions from various friendlier representations. In addition to the default constructor and a constructor that lets you set the x/y/z/w component directly, I&rsquo;d recommend having constructors that take in axis/angle, matrix, and euler angle representations.</p><p>Likewise, you will want accessors that allow users to convert a quaternion back to axis/angle or Euler angle representations. You could also have a function to convert to a matrix, but this logic commonly exists inside separate functions related to transformation matrices (something I&rsquo;ll cover in a future post).</p><h2 id=data-access>Data Access</h2><p>As with vectors, I think it&rsquo;s OK to leave the data members public on a quaternion. The structure of the internal data is well-defined and unlikely to ever change.</p><p>There are times when it may be valuable to directly manipulate or access the internal values. For example, direct access results in more readable code when writing out equations involving quaternions.</p><h2 id=string-output>String Output</h2><p>It can be helpful to output a quaternion to the log for debugging or data recording. You can overload <code>operator&lt;&lt;</code> as a convenient way to do this.</p><p>When debugging rotation issues, the x/y/z/w values of the quaternion are not very helpful - it&rsquo;s hard to tell whether the values are correct or not. For this reason, I usually output the quaternion in axis/angle format. This makes it more obvious when there&rsquo;s a bug in rotation code (maybe the axis is pointing the wrong way or the angle is obviously wrong).</p><p>For similar reasons, I usually output angles in degrees instead of radians. I think most people find degrees a little more intuitive than radians, but it&rsquo;s a matter of personal preference.</p><h2 id=pre-defined-quaternions>Pre-Defined Quaternions</h2><p>Defining some static quaternions for <code>Identity</code> and <code>Zero</code> are useful. The Identity quaternion has a vector part of <code>(0, 0, 0)</code> and a scalar part of <code>1</code>. The Zero quaternion has all zeros.</p><h1 id=conclusion>Conclusion</h1><p>The vector, matrix, and quaternion classes form a core set of math classes from which we can start to build a 3D transform system and rendering pipeline. The next post in this series will finally start to dive into this more exciting material!</p><p>If you plan to write your own game engine, creating these low-level mathematical constructs can be a huge hurdle. Some aspects are difficult to understand, it&rsquo;s easy to make mistakes, and it must be done before you can see 3D objects moving around a 3D world. Hopefully, these last few posts act as a helpful guide!</p><p>As with previous math topics, I&rsquo;ve tried to provide enough info to enable effective use of quaternions in a game engine. If you want more in-depth explanations for some of the math and derivations that I glossed over, check out these resources:</p><ul><li><a href=/reading#lengyel-math>Foundations of Game Engine Development, Volume 1: Mathematics</a></li><li><a href=/reading#essential-math>Essential Mathematics for Games and Interactive Applications</a></li></ul><div class=blog-tags><a href=http://clarkkromenaker.com//tags/g-engine/>G-Engine</a>&nbsp;
<a href=http://clarkkromenaker.com//tags/c++/>C++</a>&nbsp;
<a href=http://clarkkromenaker.com//tags/math/>Math</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=http://clarkkromenaker.com/post/gengine-08-matrices/ data-toggle=tooltip data-placement=top title="G-Engine #8: Matrices">&larr; Previous Post</a></li><li class=next><a href=http://clarkkromenaker.com/post/library-dynamic-loading-mac/ data-toggle=tooltip data-placement=top title="Loading Dynamic Libraries on Mac">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2024</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=http://clarkkromenaker.com/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>