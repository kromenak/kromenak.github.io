<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Loading Dynamic Libraries on Mac - Clark Kromenaker</title>
<meta name=description content="G-Engine uses various third-party libraries: ffmpeg for video playback, fmod for audio playback, zlib for decompression, etc. In all these cases, the library is included as a &ldquo;dynamic library&rdquo; (as opposed to a &ldquo;static library&rdquo;).
On Windows, when an executable needs a dynamic library, it searches for it in a few predefined locations, such as &ldquo;the same directory as the executable&rdquo;. On Mac and Linux, however, the situation is different and requires some consideration.
I was recently learning how Mac and Linux machines load dynamic libraries, so I thought I&rsquo;d write a quick post about it."><meta name=author content="Clark Kromenaker"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Clark Kromenaker","url":"https:\/\/kromenak.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/kromenak.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/kromenak.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/kromenak.github.io\/post\/library-dynamic-loading-mac\/","name":"Loading dynamic libraries on MAC"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Clark Kromenaker"},"headline":"Loading Dynamic Libraries on Mac","description":"G-Engine uses various third-party libraries: ffmpeg for video playback, fmod for audio playback, zlib for decompression, etc. In all these cases, the library is included as a \u0026ldquo;dynamic library\u0026rdquo; (as opposed to a \u0026ldquo;static library\u0026rdquo;).\nOn Windows, when an executable needs a dynamic library, it searches for it in a few predefined locations, such as \u0026ldquo;the same directory as the executable\u0026rdquo;. On Mac and Linux, however, the situation is different and requires some consideration.\nI was recently learning how Mac and Linux machines load dynamic libraries, so I thought I\u0026rsquo;d write a quick post about it.\n","inLanguage":"en","wordCount":3345,"datePublished":"2020-11-07T00:00:00","dateModified":"2020-11-07T00:00:00","image":"https:\/\/kromenak.github.io\/img\/avatar-icon.png","keywords":["Mac, Linux, Build, Libraries"],"mainEntityOfPage":"https:\/\/kromenak.github.io\/post\/library-dynamic-loading-mac\/","publisher":{"@type":"Organization","name":"https:\/\/kromenak.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/kromenak.github.io\/img\/avatar-icon.png","height":60,"width":60}}}</script><meta property="og:title" content="Loading Dynamic Libraries on Mac"><meta property="og:description" content="G-Engine uses various third-party libraries: ffmpeg for video playback, fmod for audio playback, zlib for decompression, etc. In all these cases, the library is included as a &ldquo;dynamic library&rdquo; (as opposed to a &ldquo;static library&rdquo;).
On Windows, when an executable needs a dynamic library, it searches for it in a few predefined locations, such as &ldquo;the same directory as the executable&rdquo;. On Mac and Linux, however, the situation is different and requires some consideration.
I was recently learning how Mac and Linux machines load dynamic libraries, so I thought I&rsquo;d write a quick post about it."><meta property="og:image" content="https://kromenak.github.io/img/avatar-icon.png"><meta property="og:url" content="https://kromenak.github.io/post/library-dynamic-loading-mac/"><meta property="og:type" content="website"><meta property="og:site_name" content="Clark Kromenaker"><meta name=twitter:title content="Loading Dynamic Libraries on Mac"><meta name=twitter:description content="G-Engine uses various third-party libraries: ffmpeg for video playback, fmod for audio playback, zlib for decompression, etc. In all these cases, the library is included as a &ldquo;dynamic â€¦"><meta name=twitter:image content="https://kromenak.github.io/img/avatar-icon.png"><meta name=twitter:card content="summary_large_image"><link href=https://kromenak.github.io/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.133.1"><link rel=alternate href=https://kromenak.github.io/index.xml type=application/rss+xml title="Clark Kromenaker"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://kromenak.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://kromenak.github.io/css/syntax.css><link rel=stylesheet href=https://kromenak.github.io/css/codeblock.css><link rel=stylesheet href=https://kromenak.github.io//css/portfolio.css><link rel=stylesheet href=https://kromenak.github.io//css/misc.css><link rel=stylesheet href=https://kromenak.github.io//css/overrides.css><script src=https://kromenak.github.io//js/darkModeToggle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://kromenak.github.io/>Clark Kromenaker</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Portfolio href=/portfolio>Portfolio</a></li><li><a title=About href=/about>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li class=navlinks-container id=dark-mode-toggle><a href=javascript:toggleColorScheme();><i id=icon-sun class="fas fa-sun"></i>
<i id=icon-moon class="fas fa-moon"></i></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Clark Kromenaker" href=https://kromenak.github.io/><img class=avatar-img src=https://kromenak.github.io/img/avatar-icon.png alt="Clark Kromenaker"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Loading Dynamic Libraries on Mac</h1><span class=post-meta><i class=fas></i>Posted on November 7, 2020</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>G-Engine uses various third-party libraries: ffmpeg for video playback, fmod for audio playback, zlib for decompression, etc. In all these cases, the library is included as a &ldquo;dynamic library&rdquo; (as opposed to a &ldquo;static library&rdquo;).</p><p>On Windows, when an executable needs a dynamic library, it searches for it in a few predefined locations, such as &ldquo;the same directory as the executable&rdquo;. On Mac and Linux, however, the situation is different and requires some consideration.</p><p>I was recently learning how Mac and Linux machines load dynamic libraries, so I thought I&rsquo;d write a quick post about it.</p><h1 id=how-dynamic-libraries-work>How Dynamic Libraries Work</h1><p>If you download someone else&rsquo;s code and want to use it in your application, there are a few ways you could go about it:</p><ol><li>Copy the source files directly into your own source code directory and compile them as part of your application.</li><li>Create a &ldquo;static library,&rdquo; which can then be included in your executable when you compile it.</li><li>Create a &ldquo;dynamic library,&rdquo; which can then be referenced by your executable when it runs.</li></ol><p>Options 1 and 2 result in the external code residing directly inside your executable, so it actually causes the executable&rsquo;s size to increase. This is fine in some cases, but there can be legal and functional reasons that you do not want to include someone else&rsquo;s code directly in your executable.</p><p>Dynamic libraries allow you to store compiled code in separate files that are loaded by your executable at runtime. When you start the executable, it reviews its list of dynamic libraries and tries to load them.</p><p>You can spot dynamic libraries by their extensions. On Windows, these are <code>.dll</code> files. On Mac, these are <code>.dylib</code> files (or <code>.framework</code> files, which you can think of as &ldquo;fancy&rdquo; dynamic libraries). On Linux, these are <code>.so</code> files.</p><p>There&rsquo;s a possibility that the executable will fail to find one or more libraries it needs to run. In this case, the application will likely abort and provide some sort of error message:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>dyld: Library not loaded: libavcodec.dylib
</span></span><span class=line><span class=cl>  Referenced from: /Path/To/Executable
</span></span><span class=line><span class=cl>  Reason: image not found
</span></span></code></pre></div><p>This message indicates that the dynamic library loader failed to load a library referenced from the executable.</p><p>It&rsquo;s also possible for dynamic libraries to reference <em>other</em> dynamic libraries. In this situation, the <em>other</em> dynamic libraries must also be present, or you&rsquo;ll get a similar error.</p><h1 id=how-dynamic-libraries-are-located>How Dynamic Libraries are Located</h1><p>On Mac and Linux, the system doesn&rsquo;t make assumptions about the locations of dynamic libraries when you try to load them. Instead, the location of the dynamic library is actually <strong>embedded</strong> directly inside the executable. The executable loads each library in turn using the file path embedded inside the executable. And if that location is wrong, you get an error message like the one earlier.</p><p>In my (limited) experience, it&rsquo;s common for the dynamic library location to be incorrect, especially if you are trying to bundle a library with your executable, rather than using one provided by the OS. It can be a frustrating and unexpected hurdle, but it isn&rsquo;t too tricky to resolve on your own.</p><h1 id=viewing-dependencies>Viewing Dependencies</h1><p>To view an executable&rsquo;s or library&rsquo;s dependencies, you can run this on the command line:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>otool -l EXE_OR_LIB_PATH
</span></span></code></pre></div><p>Here&rsquo;s a portion of the output for the G-Engine executable:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>Load command 12
</span></span><span class=line><span class=cl>          cmd LC_LOAD_DYLIB
</span></span><span class=line><span class=cl>      cmdsize 48
</span></span><span class=line><span class=cl>         name /usr/lib/libc++.1.dylib (offset 24)
</span></span><span class=line><span class=cl>   time stamp 2 Wed Dec 31 16:00:02 1969
</span></span><span class=line><span class=cl>      current version 902.1.0
</span></span><span class=line><span class=cl>compatibility version 1.0.0
</span></span><span class=line><span class=cl>Load command 13
</span></span><span class=line><span class=cl>          cmd LC_LOAD_DYLIB
</span></span><span class=line><span class=cl>      cmdsize 48
</span></span><span class=line><span class=cl>         name @rpath/libfmod.dylib (offset 24)
</span></span><span class=line><span class=cl>   time stamp 2 Wed Dec 31 16:00:02 1969
</span></span><span class=line><span class=cl>      current version 1.0.0
</span></span><span class=line><span class=cl>compatibility version 1.0.0
</span></span><span class=line><span class=cl>Load command 14
</span></span><span class=line><span class=cl>          cmd LC_LOAD_DYLIB
</span></span><span class=line><span class=cl>      cmdsize 48
</span></span><span class=line><span class=cl>         name out/bin/libavutil.dylib (offset 24)
</span></span><span class=line><span class=cl>   time stamp 2 Wed Dec 31 16:00:02 1969
</span></span><span class=line><span class=cl>      current version 56.60.100
</span></span><span class=line><span class=cl>compatibility version 56.0.0
</span></span></code></pre></div><p>We&rsquo;re primarily interested in blocks with the <code>LC_LOAD_DYLIB</code> keyword. This is the command to load a dynamic library at a particular path. If any of these fail to load because the path is invalid, the application will abort.</p><p>There are a few variations of dynamic library paths in that example:</p><ul><li>The first one (libc++) uses an absolute path, which is common for libraries installed on the user&rsquo;s machine. Some libraries are guaranteed to be installed by the OS, but that&rsquo;s not always the case.</li><li>The second one (libfmod) uses a curious path with the <code>@rpath</code> keyword. We&rsquo;ll discuss these keywords in a bit.</li><li>The third one (libavutil) uses a relative path, which is almost certainly wrong. These are relative to the directory you run the executable from, rather than the directory in which the executable is located. Since users can run executables from any arbitrary directory, this is usually not safe.</li></ul><h1 id=how-dynamic-library-paths-are-chosen>How Dynamic Library Paths are Chosen</h1><p>The paths that <code>otool</code> lists are baked into the executable or library at build time. How are these paths determined?</p><p>The executable or library being built pulls the path directly from the dependent library. If you run <code>otool -l &lt;LIB></code> on the dependent library, there&rsquo;ll be a <code>LC_ID_DYLIB</code> command.</p><p>For example, here&rsquo;s what I see if I run <code>otool -l libavutil.dylib</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>Load command 4
</span></span><span class=line><span class=cl>          cmd LC_ID_DYLIB
</span></span><span class=line><span class=cl>      cmdsize 48
</span></span><span class=line><span class=cl>         name out/bin/libavutil.dylib (offset 24)
</span></span><span class=line><span class=cl>   time stamp 1 Wed Dec 31 16:00:01 1969
</span></span><span class=line><span class=cl>      current version 58.111.101
</span></span><span class=line><span class=cl>compatibility version 58.0.0
</span></span></code></pre></div><p>As you can see, this library&rsquo;s <code>LC_ID_DYLIB</code> field is copied directly into the executable&rsquo;s <code>LC_LOAD_DYLIB</code> field.</p><p>In other words, a dynamic library tells anyone using it where to load it at runtime.</p><p>During development, a library&rsquo;s <code>LC_ID_DYLIB</code> field is often not equal to its actual location. For example, this library is located at <code>Libraries/ffmpeg/lib/mac</code> in the G-Engine repo, but after the game is built, the library is loaded from the runtime location specified by its <code>LC_ID_DYLIB</code> field.</p><h1 id=how-dynamic-libraries-choose-ids>How Dynamic Libraries Choose IDs</h1><p>So, how does the dependent library choose it&rsquo;s <code>LC_ID_DYLIB</code> field?</p><p>The <code>LC_ID_DYLIB</code> field is determined when the dependent library is built (whether through Xcode, a makefile, or some other means).</p><p>Often, this field is set assuming that the library will be &ldquo;installed&rdquo; on the local machine in a location like <code>/user/local</code>. When using a makefile, the default location is in fact <code>/user/local</code> unless you change it. In Xcode, this is specified using the &ldquo;Dynamic Library Install Name&rdquo; build setting.</p><p>To view a library&rsquo;s <code>LC_ID_DYLIB</code> field, you can find the value in the <code>otool</code> output. Alternatively, you can run <code>otool -D LIB_PATH</code>, which will output <em>only</em> the ID field:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>libavcodec.dylib:
</span></span><span class=line><span class=cl>ID_FIELD
</span></span></code></pre></div><h1 id=special-keywords-for-library-ids>Special Keywords for Library IDs</h1><p>Let&rsquo;s say we want to specify a dynamic library&rsquo;s <code>LC_ID_DYLIB</code> field in such a way that the executable will always look in its own directory, or a directory relative to the executable, for the library.</p><p>Neither absolute nor relative paths can achieve this:</p><ol><li>Absolute paths make assumptions about the user&rsquo;s filesystem and what software they have installed.</li><li>Relative paths make assumptions about where the user will run the application from. If the user executes the program from a different directory, relative paths give the wrong result.</li></ol><p>Fortunately, the operating system provides a few keywords we can include in <code>LC_ID_DYLIB</code> to overcome these problems.</p><h2 id=executable_path>@executable_path</h2><p>This keyword resolves to the executable&rsquo;s path at runtime.</p><p>Therefore, if we set a library&rsquo;s <code>LC_ID_DYLIB</code> field to <code>@executable_path/LIB_NAME.dylib</code>, it will search for the library in the same directory as the executable. The seems to be exactly what we want, but there are reasons you might not choose this option.</p><h2 id=loader_path>@loader_path</h2><p>This keyword resolves to the loading object&rsquo;s path at runtime. Note I said &ldquo;loading object&rdquo; and not &ldquo;executable.&rdquo; This is primarily meant for situations where libraries depend on other libraries.</p><p>Let&rsquo;s say we have this directory structure where the executable loads <code>libcool.dylib</code>, which in turn loads <code>libinternal.dylib</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>executable
</span></span><span class=line><span class=cl>/CoolLib
</span></span><span class=line><span class=cl>    libcool.dylib
</span></span><span class=line><span class=cl>    /InternalLib
</span></span><span class=line><span class=cl>        libinternal.dylib
</span></span></code></pre></div><p>Using <code>@loader_path</code>, the <code>LC_ID_DYLIB</code> field for <code>libinternal.dylib</code> can be set to <code>@loader_path/InternalLib/libinternal.dylib</code>. In other words, the path is relative to <code>libcool.dylib</code> instead of the executable.</p><p>You can use <code>@loader_path</code> when loading from the executable too - in this case, it has the exact same value as <code>@executable_path</code>.</p><h2 id=rpath>@rpath</h2><p>This keyword instructs the loader to search a list of paths to find the dynamic library. The list of paths is also embedded in the executable, in the <code>LC_RPATH</code> field. This is actually quite powerful because it lets the executable specify where the library will be located.</p><p>Let&rsquo;s say you have a dynamic library that is used in two separate applications: one is a command line tool, and one is a macOS app. For the command line tool, we can put the library in the same directory as the executable. For the macOS app, we may want to put the library in a &ldquo;Libraries&rdquo; folder separate from the executable.</p><p>If we have a library with the <code>LC_ID_DYLIB</code> field set to <code>@rpath/libcool.dylib</code>, it can be used in both scenarios without modification. Each application just needs to specify an appropriate <code>LC_RPATH</code> field.</p><p>For the command line tool, we can use <code>@executable_path</code> as the <code>LC_RPATH</code> field. For the macOS app, we can use <code>@executable_path/../Libraries</code>.</p><p>Keep in mind that <code>LC_RPATH</code> can be a list of paths, rather than just one path. This is helpful if you want the executable to search for a library in multiple prioritized locations. For example, use a system library UNLESS the library is found in the executable directory.</p><h1 id=changing-dynamic-library-ids>Changing Dynamic Library IDs</h1><p>Let&rsquo;s say you have a dynamic library whose <code>LC_ID_DYLIB</code> field is incorrect. Perhaps the library was built with a different use case in mind, or perhaps the field was errantly set to something nonsensical when the library was built.</p><p>Fortunately, it&rsquo;s possible to change this field without rebuilding the library using <code>install_name_tool</code> on the command line!</p><p>To change a library&rsquo;s <code>LC_ID_DYLIB</code> field, simply use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>install_name_tool -id NEW_ID LIB_PATH
</span></span></code></pre></div><h1 id=changing-loader-paths>Changing Loader Paths</h1><p>On the flipside, you may have an executable or library with an incorrect <code>LC_LOAD_DYLIB</code> field. Perhaps the library&rsquo;s location changed or perhaps the value is errantly set.</p><p>This can also be achieved with <code>install_name_tool</code>. To change a library load path, use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>install_name_tool -change OLD_PATH NEW_PATH LIB_PATH
</span></span></code></pre></div><p>In this case, you must specify the old and new values, so it acts like a find/replace. This is because there may be numerous <code>LC_LOAD_DYLIB</code> fields, so you must specify exactly which one to change.</p><h1 id=a-real-world-example-ffmpeg>A Real-World Example: ffmpeg</h1><p>I thought it&rsquo;d be valuable to put the above info into a practical context. Since I recently wrangled ffmpeg into G-Engine, we&rsquo;ll use that as an example.</p><p>ffmpeg has some characteristics that make it an interesting and complex example:</p><ul><li>The build instructions for ffmpeg assume that you want to install the libraries on your local machine, rather than bundle them with an executable. So, we&rsquo;ll need to do some custom processing of the libraries in order to bundle ffmpeg.</li><li>The built libraries contain versioned files with symlinks used for redirects. We&rsquo;ll need to decide how to handle that.</li><li>ffmpeg consists of multiple dynamic libraries with interdependencies between one another. So, we&rsquo;ll have to make sure not only that our executable can load an ffmpeg library, but also that the ffmpeg library can load its dependencies.</li></ul><h2 id=building-ffmpeg>Building ffmpeg</h2><p>You can download ffmpeg&rsquo;s source code
<a href=https://ffmpeg.org/download.html target=_blank>here</a>. Once downloaded, <code>INSTALL.md</code> outlines how to build and install ffmpeg. At a high level, the steps are pretty simple:</p><ol><li>Run <code>configure</code> to configure build options.</li><li>Run <code>make</code> to build the libraries.</li><li>Run <code>make install</code> to &ldquo;install&rdquo; the libraries.</li></ol><p>The first step (configure) is potentially the most complex because of the sheer number of options available, plus it&rsquo;s unlikely that the default options will be exactly what you want. Here&rsquo;s what I used for G-Engine:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./configure --prefix<span class=o>=</span>out --disable-static --enable-shared <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>			--disable-doc --disable-avdevice --disable-avfilter --disable-postproc --disable-network --disable-debug <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>			--disable-encoders --disable-muxers --disable-hwaccels --disable-parsers --disable-bsfs --disable-indevs --disable-outdevs --disable-filters <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>			--disable-decoders --enable-decoder<span class=o>=</span>bink --enable-decoder<span class=o>=</span>binkaudio_rdft --enable-decoder<span class=o>=</span>msrle --enable-decoder<span class=o>=</span>pcm_s16le <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>			--disable-demuxers --enable-demuxer<span class=o>=</span>bink --enable-demuxer<span class=o>=</span>avi <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>			--disable-protocols --enable-protocol<span class=o>=</span>file
</span></span></code></pre></div><p>This builds a shared library to the &ldquo;out&rdquo; directory, disables modules/features I don&rsquo;t need and specifically enables the decoders, demuxers, and protocols that I do need. This is actually pretty important because it reduces the library size from 15MB to 464KB!</p><p>If you run <code>make</code>, the libraries are created, but they are all in separate locations in the directory structure. Running <code>make install</code> consolidates them all into the desired install directory (<code>/user/local</code> by default, but I switched it to a relative &ldquo;out&rdquo; directory using <code>--prefix=out</code> on the configure step).</p><p>So now, if I go to <code>FFMPEG_DIR/out/lib</code>, I see all the libraries in one place!</p><h2 id=handling-versioned-files-and-symlinks>Handling Versioned Files and Symlinks</h2><p>After building ffmpeg, the output files look something like this:</p><ul><li>libavcodec.dylib (symlink to actual file)</li><li>libavcodec.56.dylib (symlink to actual file)</li><li>libavcodec.56.60.100.dylib (actual file)</li></ul><p>Two of the files are &ldquo;symlinks&rdquo;, meaning they are aliases or redirects to another file. In this case, both symlinks redirect to the actual library file <code>libavcodec.56.60.100.dylib</code>.</p><p>Why is it structured this way? It allows installing and using any number of different versions of the library on your machine. Here are some examples:</p><ul><li>Let&rsquo;s say we install version 56.60.100 on our machine, and then we later install new version 56.60.200. The symlink <code>libavcodec.56.dylib</code> will update to point to the new version. Any application using that symlink is now automatically pointed to the new version.</li><li>Let&rsquo;s say new version 57.0.0 is installed. The symlink <code>libavcodec.dylib</code> will always point to the latest version, so it updates to point at this new version. The <code>libavcodec.56.dylib</code> still points to the latest 56.x.x version. A new symlink called <code>libavcodec.57.dylib</code> exists for the 57.x.x libraries.</li></ul><p>This kind of versioning logic is helpful to handle installations on a user&rsquo;s machine, but again, that is not my use case: I want to bundle this library with an executable. I could use symlinks and library versioning, but it&rsquo;s kind of overkill for my needs.</p><p>Therefore, I am planning to do the following: ignore the symlinks. Rename the actual file to just <code>libavutil.dylib</code> when copying it to the executable location.</p><h2 id=bundling-the-library>Bundling the Library</h2><p>When <code>make</code> creates the library file, it sets the library&rsquo;s <code>LC_ID_DYLIB</code> field to the install directory. In my case, I changed the install directory with configure, so the field is set to <code>out/lib/libavcodec.dylib</code>.</p><p>Here&rsquo;s what I get when I run <code>otool -D libavcodec.dylib</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>libavcodec.dylib:
</span></span><span class=line><span class=cl>out/bin/libavcodec.dylib
</span></span></code></pre></div><p>This ID is obviously incorrect if my intention is to bundle the library with my executable. To fix this, I need to run <code>install_name_tool</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>install_name_tool -id @rpath/libavcodec.dylib out/lib/libavcodec.dylib
</span></span></code></pre></div><p>Running <code>otool -D libavcodec.dylib</code> now gives me:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>libavcodec.dylib:
</span></span><span class=line><span class=cl>@rpath/libavcodec.dylib
</span></span></code></pre></div><p>Because I used <code>@rpath</code>, the executable must specify a list of search paths in <code>LC_RPATH</code>. I&rsquo;ll cover that shortly.</p><h2 id=changing-library-dependencies>Changing Library Dependencies</h2><p>You won&rsquo;t run into this for every library, but ffmpeg is complex enough where it consists of multiple dynamic libraries with interdependencies. For example, the library <code>libavutil.dylib</code> is a dependency for most of the other libraries.</p><p>If we run <code>otool -l libavcodec.dylib</code>, we see this <code>LC_LOAD_DYLIB</code> entry:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>Load command 11
</span></span><span class=line><span class=cl>          cmd LC_LOAD_DYLIB
</span></span><span class=line><span class=cl>      cmdsize 48
</span></span><span class=line><span class=cl>         name out/lib/libavutil.56.dylib (offset 24)
</span></span><span class=line><span class=cl>   time stamp 2 Wed Dec 31 16:00:02 1969
</span></span><span class=line><span class=cl>      current version 56.60.100
</span></span><span class=line><span class=cl>compatibility version 56.0.0
</span></span></code></pre></div><p>Again, this path makes sense based on how we used <code>make install</code>, but it won&rsquo;t work when bundled with an executable. In my case, I plan to put all my library files into the same folder. So, I need to change this path using <code>install_name_tool</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>install_name_tool -change out/lib/libavutil.56.dylib @rpath/libavutil.dylib out/lib/libavcodec.dylib
</span></span></code></pre></div><p>You may notice that I replaced the versioned path with the unversioned path. As mentioned earlier, I am planning to eschew version data for the bundled versions of the library.</p><p>Now, running <code>otool -l libavcodec.dylib</code> reflects the change:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>Load command 11
</span></span><span class=line><span class=cl>          cmd LC_LOAD_DYLIB
</span></span><span class=line><span class=cl>      cmdsize 48
</span></span><span class=line><span class=cl>         name @rpath/libavutil.dylib (offset 24)
</span></span><span class=line><span class=cl>   time stamp 2 Wed Dec 31 16:00:02 1969
</span></span><span class=line><span class=cl>      current version 56.60.100
</span></span><span class=line><span class=cl>compatibility version 56.0.0
</span></span></code></pre></div><p>In this case, we could use either <code>@rpath</code> or <code>@loader_path</code> - since all libraries will be in the same directory, they will both work.</p><h2 id=including-libraries-in-executable>Including Libraries in Executable</h2><p>After generating the dynamic libraries and fixing up their <code>LC_ID_DYLIB</code> and <code>LC_LOAD_DYLIB</code> entries, I copied the libraries into a subdirectory of G-Engine (<code>Libraries/ffmpeg/lib/mac</code>).</p><p>From there, I can include the library by updating the library search paths and linker flags in build settings.</p><ul><li>For the library search path, I added <code>$(SRCROOT)/../Libraries/ffmpeg/lib/mac</code>.</li><li>For linker flags, I added <code>-lavutil -lavformat -lavcodec -lswresample -lswscale</code>.</li></ul><p>Finally, I have a script that copies libraries from dev locations to the executable directory after a build. I needed to add these lines:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cp <span class=s2>&#34;</span><span class=nv>$SRCROOT</span><span class=s2>&#34;</span>/../Libraries/ffmpeg/lib/mac/libavcodec.dylib <span class=nv>$LIB_DIR</span>
</span></span><span class=line><span class=cl>cp <span class=s2>&#34;</span><span class=nv>$SRCROOT</span><span class=s2>&#34;</span>/../Libraries/ffmpeg/lib/mac/libavformat.dylib <span class=nv>$LIB_DIR</span>
</span></span><span class=line><span class=cl>cp <span class=s2>&#34;</span><span class=nv>$SRCROOT</span><span class=s2>&#34;</span>/../Libraries/ffmpeg/lib/mac/libavutil.dylib <span class=nv>$LIB_DIR</span>
</span></span><span class=line><span class=cl>cp <span class=s2>&#34;</span><span class=nv>$SRCROOT</span><span class=s2>&#34;</span>/../Libraries/ffmpeg/lib/mac/libswresample.dylib <span class=nv>$LIB_DIR</span>
</span></span><span class=line><span class=cl>cp <span class=s2>&#34;</span><span class=nv>$SRCROOT</span><span class=s2>&#34;</span>/../Libraries/ffmpeg/lib/mac/libswscale.dylib <span class=nv>$LIB_DIR</span>
</span></span></code></pre></div><p>Note that these <code>cp</code> commands are copying the symlinks, but that&rsquo;s OK - it properly follows the redirects, copying over the correct file to the executable directory with the correct name.</p><p>For me, <code>LIB_DIR</code> is actually different depending on whether I&rsquo;m building a console app or a macOS app. For the console app, this is equal to the executable directory. For a macOS app, you can&rsquo;t include libraries in the executable folder, so I put them in <code>../Libraries</code> in the app bundle.</p><p>This also means that the executable&rsquo;s <code>LC_RPATH</code> needs to be set directly, since I used <code>@rpath</code> for many of these libraries. For the console app, I used <code>@executable_path</code> for this. For the macOS app, I used <code>@executable_path/../Libraries</code>. These can be specified in Xcode in the &ldquo;Runtime Search Paths&rdquo; build setting.</p><p>Now, the engine runs while properly linking and including ffmpeg! But that&rsquo;s just the start of the battle - actually using ffmpeg effectively is&mldr; uhhh&mldr; not exactly straightforward. I&rsquo;ll chronicle that experience in a future blog post. :P</p><h1 id=other-notes>Other Notes</h1><p>Before wrapping up, I wanted to address a couple loose ends.</p><h2 id=why-rpath>Why @rpath?</h2><p>At first, it seemed to me that I could simply use <code>@executable_path</code> for library <code>LC_ID_DYLIB</code> values. But then I realized that this was problematic when the library needs to be located in different locations (relative to the executable) in different situations.</p><p>So <code>@rpath</code> is actually quite useful and shouldn&rsquo;t be discounted, especially if the library may need to be used by more than one executable.</p><h2 id=what-about-linux>What about Linux?</h2><p>This post explains how to perform dynamic library operations on a Mac. On Linux, the situation is similar, but names, tools, and syntaxes are different.</p><p>Dynamic libraries on Linux have a <code>.so</code> extension, rather than <code>.dylib</code>. Library formats are also different. Mac libraries use the
<a href=https://en.wikipedia.org/wiki/Mach-O target=_blank>Mach-O</a> while Linux typically uses the
<a href=https://en.wikipedia.org/wiki/Executable_and_Linkable_Format target=_blank>ELF</a> format. This leads to a need for different tools.</p><p>Field names for IDs and loader paths are different. I found this
<a href=https://flameeyes.blog/2010/06/20/the-why-and-how-of-rpath/ target=_blank>explanation of RPATH</a> enlightening.</p><p>Instead of <code>otool</code> to view library/executable dependencies, you can use
<a href=https://man7.org/linux/man-pages/man1/ldd.1.html target=_blank>ldd</a> to get a list of dependencies. The tools <code>nm</code> and <code>objdump</code> also provide helpful output.</p><p>Instead of <code>install_name_tool</code>, you can use
<a href=https://github.com/NixOS/patchelf target=_blank>patchelf</a> to change paths of already built executables or libraries. There is also a tool called <code>chrpath</code> that is more limited in functionality, but may be more widely available.</p><p>I don&rsquo;t have specific instructions for Linux, as I&rsquo;m less familiar with it, and I haven&rsquo;t (yet) had to use it in practice. But hopefully this gives you a starting point.</p><h2 id=verifyingtroubleshooting-loaded-libraries>Verifying/Troubleshooting Loaded Libraries</h2><p>If you want to view what libraries an executable is loading, you can set the environment variable <code>DYLD_PRINT_LIBRARIES</code> to 1 before running the program. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>DYLD_PRINT_LIBRARIES</span><span class=o>=</span><span class=m>1</span> ./GEngine-MacOS
</span></span></code></pre></div><p>This produces a long list of libraries that the executable is loading. Here&rsquo;s a snippet:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>dyld: loaded: &lt;793D9643-CD83-3AAC-8B96-88D548FAB620&gt; /usr/lib/libz.1.dylib
</span></span><span class=line><span class=cl>dyld: loaded: &lt;9ECC9339-79E4-3539-B907-0EC66E522467&gt; /usr/local/lib/libGLEW.2.1.dylib
</span></span><span class=line><span class=cl>dyld: loaded: &lt;8E048273-192C-3E52-A3E4-625409FEF4B9&gt; /Users/Clark/Library/Developer/Xcode/DerivedData/GEngine-bkvltqfkyvldabcaovheyyhxdmji/Build/Products/Debug/libfmod.dylib
</span></span><span class=line><span class=cl>dyld: loaded: &lt;A53A7AD0-F7AC-3B8C-BF67-C20D17B80E32&gt; /Users/Clark/Library/Developer/Xcode/DerivedData/GEngine-bkvltqfkyvldabcaovheyyhxdmji/Build/Products/Debug/libavutil.dylib
</span></span><span class=line><span class=cl>dyld: loaded: &lt;2AEC4083-1BAC-33D5-A7CE-F6D8162ADB84&gt; /Users/Clark/Library/Developer/Xcode/DerivedData/GEngine-bkvltqfkyvldabcaovheyyhxdmji/Build/Products/Debug/libavformat.dylib
</span></span></code></pre></div><p>This actually revealed something surprising to me: despite my intention to bundle zlib and GLEW with my executable, it is actually using the system-installed libraries!</p><p>Upon closer inspection, this was because the <code>LC_ID_DYLIB</code> fields for those two libraries was not set correctly. But it still worked &ldquo;by chance&rdquo; because I happened to have those two libraries installed on my machine.</p><p>It goes to show - it&rsquo;s a good idea to verify loader paths before distributing an executable!</p><h1 id=conclusion>Conclusion</h1><p>If you&rsquo;re new to developing with dynamic libraries, all this complexity can come as a bit of a surprise, and though it is all documented in one way or another, it&rsquo;s rather scattered and hard to find.</p><p>Hopefully, this post provides a reasonably clear explanation of dynamic libraries, their <code>LC_ID_DYLIB</code> fields, how they&rsquo;re loaded using <code>LC_LOAD_DYLIB</code> loader commands, and a concrete example of it all coming together.</p><p>For further reading, I found these resources helpful:</p><ul><li><a href=https://medium.com/@donblas/fun-with-rpath-otool-and-install-name-tool-e3e41ae86172 target=_blank>Fun with rpath, otool, and install_name_tool</a></li><li><a href=https://wincent.com/wiki/@executable_path,_@load_path_and_@rpath target=_blank>@executable_path, @loader_path, and @rpath</a></li><li><a href=https://blog.krzyzanowskim.com/2018/12/05/rpath-what/ target=_blank>@rpath what?</a></li></ul><div class=blog-tags><a href=https://kromenak.github.io//tags/mac/>Mac</a>&nbsp;
<a href=https://kromenak.github.io//tags/linux/>Linux</a>&nbsp;
<a href=https://kromenak.github.io//tags/build/>Build</a>&nbsp;
<a href=https://kromenak.github.io//tags/libraries/>Libraries</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://kromenak.github.io/post/gengine-09-quaternions/ data-toggle=tooltip data-placement=top title="G-Engine #9: Quaternions">&larr; Previous Post</a></li><li class=next><a href=https://kromenak.github.io/post/cpp-manager-access/ data-toggle=tooltip data-placement=top title="Accessing Managers in C++">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//clarkkromenaker.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:kromenak@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/kromenak title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/clarkkromenaker title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Clark Kromenaker
&nbsp;&bull;&nbsp;&copy;
2024</p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Powered by Hugo v0.133.1</a> &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://kromenak.github.io/js/main.js></script><script>renderMathInElement(document.body)</script></body></html>